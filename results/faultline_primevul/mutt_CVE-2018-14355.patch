diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..9026ed0
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,20 @@
+FROM ubuntu:latest
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build dependencies
+RUN apt-get -y update && \
+    apt-get install -y build-essential && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Compile our test case
+RUN gcc -o test_path_traversal test_path_traversal.c
+
+# Run the test
+CMD ["/project/test_path_traversal"]
diff --git a/imap/util.c b/imap/util.c
index 2779294..09fa977 100644
--- a/imap/util.c
+++ b/imap/util.c
@@ -80,6 +80,7 @@ static int imap_hcache_namer (const char* path, char* dest, size_t dlen)
 
 header_cache_t* imap_hcache_open (IMAP_DATA* idata, const char* path)
 {
+  printf("[INSTRUMENTATION] imap_hcache_open");
   IMAP_MBOX mx;
   ciss_url_t url;
   char cachepath[LONG_STRING];
diff --git a/test_path_traversal.c b/test_path_traversal.c
new file mode 100644
index 0000000..8ba7368
--- /dev/null
+++ b/test_path_traversal.c
@@ -0,0 +1,194 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+
+// This test case demonstrates the path traversal vulnerability in Mutt/NeoMutt
+// CVE-2018-14355: imap/util.c mishandles ".." directory traversal in a mailbox name
+
+// Simplified structure to simulate IMAP_DATA
+typedef struct {
+    char delim;
+} IMAP_DATA;
+
+// The vulnerable function from imap/util.c
+void imap_cachepath(IMAP_DATA* idata, const char* mailbox, char* dest, size_t dlen) {
+    char* s;
+    const char* p = mailbox;
+
+    for (s = dest; p && *p && dlen; dlen--) {
+        if (*p == idata->delim) {
+            *s = '/';
+            /* simple way to avoid collisions with UIDs */
+            if (*(p + 1) >= '0' && *(p + 1) <= '9') {
+                if (--dlen)
+                    *++s = '_';
+            }
+        }
+        else
+            *s = *p;
+        p++;
+        s++;
+    }
+    *s = '\0';
+}
+
+// Fixed version that sanitizes ".." sequences
+void imap_cachepath_fixed(IMAP_DATA* idata, const char* mailbox, char* dest, size_t dlen) {
+    char* s;
+    const char* p = mailbox;
+    int last_slash_pos = -1;
+    int current_pos = 0;
+
+    for (s = dest; p && *p && dlen; dlen--) {
+        if (*p == idata->delim) {
+            *s = '/';
+            last_slash_pos = current_pos;
+            /* simple way to avoid collisions with UIDs */
+            if (*(p + 1) >= '0' && *(p + 1) <= '9') {
+                if (--dlen) {
+                    *++s = '_';
+                    current_pos++;
+                }
+            }
+        }
+        else {
+            // Check for ".." sequence after a slash
+            if (last_slash_pos >= 0 && 
+                current_pos == last_slash_pos + 2 && 
+                *(s-1) == '.' && *p == '.') {
+                // Replace with "xx" to prevent path traversal
+                *(s-1) = 'x';
+                *s = 'x';
+            } else {
+                *s = *p;
+            }
+        }
+        p++;
+        s++;
+        current_pos++;
+    }
+    *s = '\0';
+}
+
+// Create a test file with specific content
+void create_test_file(const char *path, const char *content) {
+    FILE *fp = fopen(path, "w");
+    if (fp) {
+        fprintf(fp, "%s\n", content);
+        fclose(fp);
+    } else {
+        perror("Failed to create file");
+    }
+}
+
+// Check if a file exists and contains specific content
+int file_contains(const char *path, const char *content) {
+    FILE *fp = fopen(path, "r");
+    if (!fp) {
+        return 0;
+    }
+    
+    char buffer[1024];
+    size_t content_len = strlen(content);
+    size_t bytes_read = fread(buffer, 1, content_len, fp);
+    fclose(fp);
+    
+    if (bytes_read != content_len) {
+        return 0;
+    }
+    
+    buffer[bytes_read] = '\0';
+    return (strcmp(buffer, content) == 0);
+}
+
+int main(int argc, char *argv[]) {
+    // Create a test directory structure
+    char test_dir[256] = "/tmp/mutt_test_XXXXXX";
+    char *temp_dir = mkdtemp(test_dir);
+    if (!temp_dir) {
+        perror("Failed to create test directory");
+        return 1;
+    }
+    
+    // Create a file that should NOT be accessible via path traversal
+    char secret_file[512];
+    const char *secret_content = "SECRET_DATA_DO_NOT_ACCESS";
+    snprintf(secret_file, sizeof(secret_file), "%s/secret.txt", temp_dir);
+    create_test_file(secret_file, secret_content);
+    
+    // Create a subdirectory for the IMAP cache
+    char cache_dir[512];
+    snprintf(cache_dir, sizeof(cache_dir), "%s/imap_cache", temp_dir);
+    if (mkdir(cache_dir, 0700) != 0) {
+        perror("Failed to create cache directory");
+        return 1;
+    }
+    
+    printf("Test setup complete. Running vulnerability test...\n");
+    printf("Secret file: %s\n", secret_file);
+    printf("Cache directory: %s\n", cache_dir);
+    
+    // Change to the cache directory to simulate Mutt's behavior
+    if (chdir(cache_dir) != 0) {
+        perror("Failed to change to cache directory");
+        return 1;
+    }
+    
+    // Create a malicious mailbox path with ".." traversal
+    // This simulates an IMAP mailbox path that contains directory traversal
+    char mailbox_path[512];
+    snprintf(mailbox_path, sizeof(mailbox_path), "INBOX/../../secret.txt");
+    
+    // Create a mock IMAP_DATA with '/' as delimiter
+    IMAP_DATA idata;
+    idata.delim = '/';
+    
+    // Test the vulnerable function
+    char cache_path_vuln[512];
+    imap_cachepath(&idata, mailbox_path, cache_path_vuln, sizeof(cache_path_vuln));
+    
+    printf("Mailbox path: %s\n", mailbox_path);
+    printf("Cache path (vulnerable): %s\n", cache_path_vuln);
+    
+    // Test the fixed function
+    char cache_path_fixed[512];
+    imap_cachepath_fixed(&idata, mailbox_path, cache_path_fixed, sizeof(cache_path_fixed));
+    
+    printf("Cache path (fixed): %s\n", cache_path_fixed);
+    
+    // Check if the path traversal was successful with the vulnerable function
+    if (strstr(cache_path_vuln, "../") != NULL) {
+        printf("VULNERABILITY DETECTED: Path traversal sequence '../' found in cache path!\n");
+        
+        // Try to access the file to confirm the vulnerability
+        if (access(cache_path_vuln, F_OK) == 0) {
+            printf("The secret file is accessible via path traversal!\n");
+            
+            // Verify we can read the secret content
+            if (file_contains(cache_path_vuln, secret_content)) {
+                printf("Successfully read secret content through path traversal!\n");
+            }
+            
+            return 1; // Test fails if vulnerability exists
+        } else {
+            printf("File not accessible in this test environment, but path traversal sequence was preserved.\n");
+            printf("In a real Mutt environment, this would allow access to files outside the cache directory.\n");
+            return 1; // Still consider it a failure
+        }
+    }
+    
+    // Check if the path traversal was prevented with the fixed function
+    if (strstr(cache_path_fixed, "../") == NULL) {
+        printf("Fixed function successfully prevented path traversal.\n");
+    } else {
+        printf("Fixed function failed to prevent path traversal!\n");
+        return 1;
+    }
+    
+    printf("Path traversal test completed successfully.\n");
+    return 0; // Test passes if vulnerability is fixed
+}
