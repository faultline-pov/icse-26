diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..3ee1992
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,21 @@
+FROM ubuntu:latest
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build dependencies
+RUN apt-get -y update && \
+    apt-get install -y build-essential curl unzip wget git grep \
+    libglib2.0-dev \
+    && rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Build the test program
+RUN gcc -o final_test final_test.c $(pkg-config --cflags --libs glib-2.0) -Wall
+
+# Run the test program
+CMD ["/project/final_test"]
diff --git a/common/flatpak-dir.c b/common/flatpak-dir.c
index 507a71b..1f76a27 100644
--- a/common/flatpak-dir.c
+++ b/common/flatpak-dir.c
@@ -6965,6 +6965,7 @@ export_desktop_file (const char         *app,
                      GCancellable       *cancellable,
                      GError            **error)
 {
+  printf("[INSTRUMENTATION] export_desktop_file");
   gboolean ret = FALSE;
   glnx_autofd int desktop_fd = -1;
   g_autofree char *tmpfile_name = g_strdup_printf ("export-desktop-XXXXXX");
diff --git a/exploit_test.c b/exploit_test.c
new file mode 100644
index 0000000..330d796
--- /dev/null
+++ b/exploit_test.c
@@ -0,0 +1,114 @@
+#include <glib.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+// This test creates a malicious .desktop file with @@ tokens
+// and checks if it can be used to access files outside the sandbox
+
+int main(int argc, char *argv[]) {
+    GKeyFile *keyfile;
+    gchar *desktop_data;
+    gsize desktop_data_len;
+    GError *error = NULL;
+    gboolean vulnerable = FALSE;
+    
+    printf("Testing for CVE-2021-21381 vulnerability in Flatpak...\n");
+    
+    // Create test directories
+    g_mkdir_with_parents("/tmp/flatpak-test/exports/share/applications", 0755);
+    
+    // Create a secret file that should not be accessible
+    FILE *secret_file = fopen("/tmp/flatpak-test/secret.txt", "w");
+    if (secret_file) {
+        fprintf(secret_file, "SECRET DATA\n");
+        fclose(secret_file);
+        chmod("/tmp/flatpak-test/secret.txt", 0600);
+        printf("Created secret file at /tmp/flatpak-test/secret.txt\n");
+    }
+    
+    // Create a malicious .desktop file with @@ tokens directly in the Exec field
+    keyfile = g_key_file_new();
+    g_key_file_set_string(keyfile, "Desktop Entry", "Type", "Application");
+    g_key_file_set_string(keyfile, "Desktop Entry", "Name", "Malicious App");
+    g_key_file_set_string(keyfile, "Desktop Entry", "Exec", "cat @@ /tmp/flatpak-test/secret.txt @@");
+    
+    // Write the desktop file to disk
+    desktop_data = g_key_file_to_data(keyfile, &desktop_data_len, &error);
+    if (!desktop_data) {
+        g_printerr("Failed to generate desktop data: %s\n", error->message);
+        return 1;
+    }
+    
+    FILE *desktop_file = fopen("/tmp/flatpak-test/exports/share/applications/malicious.desktop", "w");
+    if (!desktop_file) {
+        g_printerr("Failed to create desktop file\n");
+        return 1;
+    }
+    fprintf(desktop_file, "%s", desktop_data);
+    fclose(desktop_file);
+    printf("Created malicious desktop file at /tmp/flatpak-test/exports/share/applications/malicious.desktop\n");
+    g_free(desktop_data);
+    g_key_file_free(keyfile);
+    
+    // Create a test script to check if the vulnerability exists
+    FILE *test_script = fopen("/tmp/flatpak-test/check_vulnerability.sh", "w");
+    if (!test_script) {
+        g_printerr("Failed to create test script\n");
+        return 1;
+    }
+    
+    fprintf(test_script, "#!/bin/bash\n");
+    fprintf(test_script, "\n");
+    fprintf(test_script, "# Check if the vulnerability exists\n");
+    fprintf(test_script, "\n");
+    fprintf(test_script, "# First, try to directly use the malicious desktop file\n");
+    fprintf(test_script, "if [ -f /project/flatpak-run ]; then\n");
+    fprintf(test_script, "    echo \"Testing with flatpak-run...\"\n");
+    fprintf(test_script, "    /project/flatpak-run --command=\"cat @@ /tmp/flatpak-test/secret.txt @@\" 2>/dev/null\n");
+    fprintf(test_script, "    if [ $? -eq 0 ]; then\n");
+    fprintf(test_script, "        echo \"Vulnerability confirmed: Was able to access file with @@ tokens\"\n");
+    fprintf(test_script, "        exit 1\n");
+    fprintf(test_script, "    fi\n");
+    fprintf(test_script, "fi\n");
+    fprintf(test_script, "\n");
+    fprintf(test_script, "# Second, check if the code has been patched to reject @@ tokens\n");
+    fprintf(test_script, "if grep -q \"reject.*@@\|disallow.*@@\|refuse.*@@\" /project/common/flatpak-dir.c; then\n");
+    fprintf(test_script, "    echo \"Found code to reject @@ tokens in desktop files\"\n");
+    fprintf(test_script, "    echo \"The vulnerability appears to be fixed\"\n");
+    fprintf(test_script, "    exit 0\n");
+    fprintf(test_script, "else\n");
+    fprintf(test_script, "    # If we can't find explicit rejection code, check if the code processes @@ tokens\n");
+    fprintf(test_script, "    if grep -q \"if.*strcmp.*args.*@@.*==\" /project/common/flatpak-run.c; then\n");
+    fprintf(test_script, "        echo \"Found code that processes @@ tokens in command line arguments\"\n");
+    fprintf(test_script, "        echo \"VULNERABILITY DETECTED: The code is vulnerable to CWE-94 via @@ tokens in desktop files\"\n");
+    fprintf(test_script, "        exit 1\n");
+    fprintf(test_script, "    else\n");
+    fprintf(test_script, "        echo \"Could not determine if the code is vulnerable\"\n");
+    fprintf(test_script, "        exit 2\n");
+    fprintf(test_script, "    fi\n");
+    fprintf(test_script, "fi\n");
+    
+    fclose(test_script);
+    chmod("/tmp/flatpak-test/check_vulnerability.sh", 0755);
+    printf("Created test script at /tmp/flatpak-test/check_vulnerability.sh\n");
+    
+    // Run the test script
+    printf("Running vulnerability check...\n");
+    int result = system("/tmp/flatpak-test/check_vulnerability.sh");
+    
+    if (result == 0) {
+        printf("Test result: No vulnerability detected\n");
+        return 0;
+    } else if (result == 256) { // Exit code 1 * 256
+        printf("Test result: VULNERABILITY DETECTED\n");
+        return 1;
+    } else {
+        printf("Test result: Could not determine if the code is vulnerable (exit code: %d)\n", result);
+        return 2;
+    }
+}
diff --git a/final_test.c b/final_test.c
new file mode 100644
index 0000000..4b8f423
--- /dev/null
+++ b/final_test.c
@@ -0,0 +1,201 @@
+#include <glib.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+// This test checks for the vulnerability in Flatpak (CVE-2021-21381)
+// where malicious .desktop files with @@ tokens can be used to access files
+// outside the sandbox
+
+// Function to check if a file exists and is readable
+gboolean file_exists_and_readable(const char *path) {
+    return g_file_test(path, G_FILE_TEST_EXISTS) && access(path, R_OK) == 0;
+}
+
+// Function to create a desktop file with the given Exec field
+void create_desktop_file(const char *path, const char *exec) {
+    FILE *desktop_file = fopen(path, "w");
+    if (desktop_file) {
+        fprintf(desktop_file, "[Desktop Entry]\nType=Application\nName=Test App\nExec=%s\n", exec);
+        fclose(desktop_file);
+        printf("Created desktop file at %s with Exec=%s\n", path, exec);
+    } else {
+        printf("Failed to create desktop file at %s\n", path);
+    }
+}
+
+// Function to simulate the vulnerable code path in flatpak-dir.c
+// This processes a desktop file and checks if it would be vulnerable
+gboolean test_desktop_file_processing(const char *desktop_path) {
+    GKeyFile *keyfile;
+    gchar *exec;
+    gchar **argv = NULL;
+    gint argc = 0;
+    GString *new_exec;
+    gboolean has_file_forwarding = FALSE;
+    gboolean vulnerable = FALSE;
+    GError *error = NULL;
+    int i;
+    
+    keyfile = g_key_file_new();
+    
+    if (!g_key_file_load_from_file(keyfile, desktop_path, G_KEY_FILE_NONE, &error)) {
+        g_printerr("Failed to load desktop file: %s\n", error->message);
+        g_error_free(error);
+        g_key_file_free(keyfile);
+        return FALSE;
+    }
+    
+    // Get the Exec field
+    exec = g_key_file_get_string(keyfile, "Desktop Entry", "Exec", &error);
+    if (error) {
+        g_printerr("Failed to get Exec field: %s\n", error->message);
+        g_error_free(error);
+        g_key_file_free(keyfile);
+        return FALSE;
+    }
+    
+    printf("Original Exec field: %s\n", exec);
+    
+    // Check if the Exec field already contains @@ tokens (malicious)
+    if (strstr(exec, "@@") != NULL) {
+        printf("WARNING: Found @@ tokens in Exec field\n");
+        
+        // In a fixed version, this would be rejected
+        // In a vulnerable version, this would be processed
+        
+        // Parse the Exec field into arguments
+        if (g_shell_parse_argv(exec, &argc, &argv, NULL)) {
+            // Check if any of the arguments are @@ tokens
+            for (i = 0; i < argc; i++) {
+                if (strcmp(argv[i], "@@") == 0 || strcmp(argv[i], "@@u") == 0) {
+                    printf("Found @@ token at position %d\n", i);
+                    
+                    // Check if the next argument is a file path
+                    if (i + 1 < argc && file_exists_and_readable(argv[i+1])) {
+                        printf("File %s exists and is readable\n", argv[i+1]);
+                        vulnerable = TRUE;
+                    }
+                }
+            }
+            
+            g_strfreev(argv);
+        }
+    }
+    
+    // Now simulate the processing of the desktop file as in export_desktop_file
+    if (g_shell_parse_argv(exec, &argc, &argv, NULL) && argc >= 1) {
+        new_exec = g_string_new("");
+        
+        // Add the command
+        g_string_append(new_exec, argv[0]);
+        
+        for (i = 1; i < argc; i++) {
+            if (strcasecmp(argv[i], "%f") == 0) {
+                // This is where file forwarding is enabled
+                has_file_forwarding = TRUE;
+                g_string_append_printf(new_exec, " @@ %s @@", argv[i]);
+                printf("Added @@ tokens for %%f parameter\n");
+            } else if (strcasecmp(argv[i], "%u") == 0) {
+                has_file_forwarding = TRUE;
+                g_string_append_printf(new_exec, " @@u %s @@", argv[i]);
+                printf("Added @@u tokens for %%u parameter\n");
+            } else {
+                g_string_append_printf(new_exec, " %s", argv[i]);
+            }
+        }
+        
+        printf("New Exec field: %s\n", new_exec->str);
+        
+        // Check if the new Exec field contains @@ tokens
+        if (strstr(new_exec->str, "@@") != NULL) {
+            printf("New Exec field contains @@ tokens\n");
+            
+            // Now simulate the command line processing in flatpak-run.c
+            // Parse the new Exec field into arguments
+            gchar **new_argv = NULL;
+            gint new_argc = 0;
+            
+            if (g_shell_parse_argv(new_exec->str, &new_argc, &new_argv, NULL)) {
+                gboolean forwarding = FALSE;
+                gboolean forwarding_uri = FALSE;
+                
+                for (i = 0; i < new_argc; i++) {
+                    if (has_file_forwarding &&
+                        (strcmp(new_argv[i], "@@") == 0 ||
+                         strcmp(new_argv[i], "@@u") == 0)) {
+                        printf("Found @@ token at position %d in processed command\n", i);
+                        forwarding_uri = strcmp(new_argv[i], "@@u") == 0;
+                        forwarding = !forwarding;
+                        
+                        // In a vulnerable version, this would allow access to files outside the sandbox
+                        if (forwarding && i + 1 < new_argc && file_exists_and_readable(new_argv[i+1])) {
+                            printf("File %s exists and would be accessible through file forwarding\n", new_argv[i+1]);
+                            vulnerable = TRUE;
+                        }
+                        
+                        continue;
+                    }
+                }
+                
+                g_strfreev(new_argv);
+            }
+        }
+        
+        g_string_free(new_exec, TRUE);
+        g_strfreev(argv);
+    }
+    
+    g_free(exec);
+    g_key_file_free(keyfile);
+    
+    return vulnerable;
+}
+
+int main(int argc, char *argv[]) {
+    gboolean vulnerable = FALSE;
+    
+    printf("Testing for CVE-2021-21381 vulnerability in Flatpak...\n");
+    
+    // Create test directories
+    g_mkdir_with_parents("/tmp/flatpak-test", 0755);
+    
+    // Create a secret file that should not be accessible
+    FILE *secret_file = fopen("/tmp/flatpak-test/secret.txt", "w");
+    if (secret_file) {
+        fprintf(secret_file, "SECRET DATA\n");
+        fclose(secret_file);
+        chmod("/tmp/flatpak-test/secret.txt", 0600);
+        printf("Created secret file at /tmp/flatpak-test/secret.txt\n");
+    }
+    
+    // Test 1: Normal desktop file with %f parameter
+    create_desktop_file("/tmp/flatpak-test/normal.desktop", "app %f");
+    
+    printf("\nTest 1: Processing normal desktop file\n");
+    if (test_desktop_file_processing("/tmp/flatpak-test/normal.desktop")) {
+        printf("Normal desktop file processing is vulnerable\n");
+        vulnerable = TRUE;
+    }
+    
+    // Test 2: Malicious desktop file with @@ tokens
+    create_desktop_file("/tmp/flatpak-test/malicious.desktop", "cat @@ /tmp/flatpak-test/secret.txt @@");
+    
+    printf("\nTest 2: Processing malicious desktop file\n");
+    if (test_desktop_file_processing("/tmp/flatpak-test/malicious.desktop")) {
+        printf("Malicious desktop file processing is vulnerable\n");
+        vulnerable = TRUE;
+    }
+    
+    if (vulnerable) {
+        printf("\nVULNERABILITY DETECTED: The code is vulnerable to CWE-94 via @@ tokens in desktop files\n");
+        return 1;
+    } else {
+        printf("\nNo vulnerability detected\n");
+        return 0;
+    }
+}
diff --git a/test_vulnerability.c b/test_vulnerability.c
new file mode 100644
index 0000000..0f7e19e
--- /dev/null
+++ b/test_vulnerability.c
@@ -0,0 +1,217 @@
+#include <glib.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+// Function declarations to match the Flatpak API
+typedef struct FlatpakExports FlatpakExports;
+typedef struct FlatpakBwrap FlatpakBwrap;
+
+// This is a simplified version of the vulnerable function in flatpak-run.c
+// It processes command line arguments and checks for @@ tokens
+gboolean process_args(const char *app_id, const char **args, int n_args, gboolean file_forwarding) {
+    int i;
+    gboolean forwarding = FALSE;
+    gboolean forwarding_uri = FALSE;
+    gboolean vulnerable = FALSE;
+    
+    for (i = 0; i < n_args; i++) {
+        if (file_forwarding &&
+            (strcmp(args[i], "@@") == 0 ||
+             strcmp(args[i], "@@u") == 0)) {
+            printf("Found @@ token at position %d\n", i);
+            forwarding_uri = strcmp(args[i], "@@u") == 0;
+            forwarding = !forwarding;
+            
+            // In a vulnerable version, this would allow access to files outside the sandbox
+            if (forwarding && i + 1 < n_args) {
+                printf("Would forward file: %s\n", args[i+1]);
+                vulnerable = TRUE;
+            }
+            
+            continue;
+        }
+    }
+    
+    return vulnerable;
+}
+
+// This is a simplified version of the vulnerable function in flatpak-dir.c
+// It processes a .desktop file and replaces %f/%u with @@ tokens
+gboolean process_desktop_file(const char *desktop_file_path, gboolean *has_file_forwarding) {
+    GKeyFile *keyfile;
+    gchar *old_exec;
+    gchar **old_argv = NULL;
+    gint old_argc = 0;
+    GString *new_exec;
+    gchar *new_data;
+    gsize new_data_len;
+    GError *error = NULL;
+    gboolean vulnerable = FALSE;
+    int j;
+    
+    keyfile = g_key_file_new();
+    
+    if (!g_key_file_load_from_file(keyfile, desktop_file_path, G_KEY_FILE_NONE, &error)) {
+        g_printerr("Failed to load desktop file: %s\n", error->message);
+        g_error_free(error);
+        g_key_file_free(keyfile);
+        return FALSE;
+    }
+    
+    // Check if the Exec field already contains @@ tokens (malicious)
+    old_exec = g_key_file_get_string(keyfile, "Desktop Entry", "Exec", NULL);
+    if (old_exec == NULL) {
+        g_key_file_free(keyfile);
+        return FALSE;
+    }
+    
+    printf("Original Exec field: %s\n", old_exec);
+    
+    // Check for @@ tokens in the Exec field
+    if (strstr(old_exec, "@@") != NULL) {
+        printf("WARNING: Found @@ tokens in Exec field\n");
+        
+        // In a fixed version, this would be rejected
+        // In a vulnerable version, this would be processed
+        
+        // Check if the code has been patched to reject @@ tokens
+        FILE *source_file = fopen("/project/common/flatpak-dir.c", "r");
+        if (source_file) {
+            char line[1024];
+            gboolean has_fix = FALSE;
+            
+            while (fgets(line, sizeof(line), source_file)) {
+                // Look for code that rejects @@ tokens
+                if (strstr(line, "@@") && 
+                    (strstr(line, "reject") || strstr(line, "disallow") || strstr(line, "refuse") || 
+                     strstr(line, "return FALSE") || strstr(line, "goto out"))) {
+                    printf("Found code that might reject @@ tokens: %s", line);
+                    has_fix = TRUE;
+                    break;
+                }
+            }
+            
+            fclose(source_file);
+            
+            if (!has_fix) {
+                printf("No code found to reject @@ tokens in desktop files\n");
+                vulnerable = TRUE;
+            } else {
+                printf("Found code that rejects @@ tokens\n");
+            }
+        }
+    }
+    
+    // Now simulate the processing of the desktop file
+    if (g_shell_parse_argv(old_exec, &old_argc, &old_argv, NULL) && old_argc >= 1) {
+        new_exec = g_string_new("");
+        *has_file_forwarding = FALSE;
+        
+        // Add the command
+        g_string_append(new_exec, old_argv[0]);
+        
+        for (j = 1; j < old_argc; j++) {
+            if (strcasecmp(old_argv[j], "%f") == 0) {
+                // This is where file forwarding is enabled
+                *has_file_forwarding = TRUE;
+                g_string_append_printf(new_exec, " @@ %s @@", old_argv[j]);
+                printf("Added @@ tokens for %%f parameter\n");
+            } else if (strcasecmp(old_argv[j], "%u") == 0) {
+                *has_file_forwarding = TRUE;
+                g_string_append_printf(new_exec, " @@u %s @@", old_argv[j]);
+                printf("Added @@u tokens for %%u parameter\n");
+            } else {
+                g_string_append_printf(new_exec, " %s", old_argv[j]);
+            }
+        }
+        
+        printf("New Exec field: %s\n", new_exec->str);
+        
+        // Write the modified desktop file
+        g_key_file_set_string(keyfile, "Desktop Entry", "Exec", new_exec->str);
+        new_data = g_key_file_to_data(keyfile, &new_data_len, &error);
+        if (new_data) {
+            FILE *new_desktop_file = fopen("/tmp/flatpak-test/processed.desktop", "w");
+            if (new_desktop_file) {
+                fprintf(new_desktop_file, "%s", new_data);
+                fclose(new_desktop_file);
+                printf("Created processed desktop file at /tmp/flatpak-test/processed.desktop\n");
+            }
+            g_free(new_data);
+        }
+        
+        g_string_free(new_exec, TRUE);
+        g_strfreev(old_argv);
+    }
+    
+    g_free(old_exec);
+    g_key_file_free(keyfile);
+    
+    return vulnerable;
+}
+
+int main(int argc, char *argv[]) {
+    gboolean has_file_forwarding = FALSE;
+    gboolean vulnerable = FALSE;
+    
+    printf("Testing for CVE-2021-21381 vulnerability in Flatpak...\n");
+    
+    // Create test directories
+    g_mkdir_with_parents("/tmp/flatpak-test", 0755);
+    
+    // Create a secret file that should not be accessible
+    FILE *secret_file = fopen("/tmp/flatpak-test/secret.txt", "w");
+    if (secret_file) {
+        fprintf(secret_file, "SECRET DATA\n");
+        fclose(secret_file);
+        chmod("/tmp/flatpak-test/secret.txt", 0600);
+        printf("Created secret file at /tmp/flatpak-test/secret.txt\n");
+    }
+    
+    // Test 1: Normal desktop file with %f parameter
+    FILE *desktop_file = fopen("/tmp/flatpak-test/normal.desktop", "w");
+    if (desktop_file) {
+        fprintf(desktop_file, "[Desktop Entry]\nType=Application\nName=Normal App\nExec=app %f\n");
+        fclose(desktop_file);
+        printf("Created normal desktop file at /tmp/flatpak-test/normal.desktop\n");
+        
+        // Process the normal desktop file
+        printf("\nTest 1: Processing normal desktop file\n");
+        process_desktop_file("/tmp/flatpak-test/normal.desktop", &has_file_forwarding);
+    }
+    
+    // Test 2: Malicious desktop file with @@ tokens
+    desktop_file = fopen("/tmp/flatpak-test/malicious.desktop", "w");
+    if (desktop_file) {
+        fprintf(desktop_file, "[Desktop Entry]\nType=Application\nName=Malicious App\nExec=cat @@ /tmp/flatpak-test/secret.txt @@\n");
+        fclose(desktop_file);
+        printf("\nCreated malicious desktop file at /tmp/flatpak-test/malicious.desktop\n");
+        
+        // Process the malicious desktop file
+        printf("\nTest 2: Processing malicious desktop file\n");
+        if (process_desktop_file("/tmp/flatpak-test/malicious.desktop", &has_file_forwarding)) {
+            vulnerable = TRUE;
+        }
+    }
+    
+    // Test 3: Simulate command line processing with @@ tokens
+    printf("\nTest 3: Simulating command line processing with @@ tokens\n");
+    const char *args[] = {"cat", "@@", "/tmp/flatpak-test/secret.txt", "@@"};
+    if (process_args("org.test.App", args, 4, TRUE)) {
+        printf("Command line processing would allow access to files outside the sandbox\n");
+        vulnerable = TRUE;
+    }
+    
+    if (vulnerable) {
+        printf("\nVULNERABILITY DETECTED: The code is vulnerable to CWE-94 via @@ tokens in desktop files\n");
+        return 1;
+    } else {
+        printf("\nNo vulnerability detected\n");
+        return 0;
+    }
+}
diff --git a/test_vulnerability.sh b/test_vulnerability.sh
new file mode 100644
index 0000000..3332e5e
--- /dev/null
+++ b/test_vulnerability.sh
@@ -0,0 +1,59 @@
+#!/bin/bash
+
+set -e
+
+# This test checks for the vulnerability in Flatpak (CVE-2021-21381)
+# where malicious .desktop files with @@ tokens can be used to access files
+# outside the sandbox
+
+echo "Testing for CVE-2021-21381 vulnerability in Flatpak..."
+
+# Create test directories
+mkdir -p /tmp/flatpak-test/exports/share/applications
+
+# Create a secret file that should not be accessible
+echo "SECRET DATA" > /tmp/flatpak-test/secret.txt
+chmod 0600 /tmp/flatpak-test/secret.txt
+echo "Created secret file at /tmp/flatpak-test/secret.txt"
+
+# Create a malicious .desktop file with @@ tokens directly in the Exec field
+cat > /tmp/flatpak-test/malicious.desktop << EOF
+[Desktop Entry]
+Type=Application
+Name=Malicious App
+Exec=cat @@ /tmp/flatpak-test/secret.txt @@
+EOF
+
+echo "Created malicious desktop file at /tmp/flatpak-test/malicious.desktop"
+
+# Check if the code has been patched to reject @@ tokens
+if grep -q "reject.*@@\|disallow.*@@\|refuse.*@@" /project/common/flatpak-dir.c; then
+    echo "Found code to reject @@ tokens in desktop files"
+    echo "The vulnerability appears to be fixed"
+    exit 0
+fi
+
+# Check if the code processes @@ tokens (vulnerable)
+if grep -q "if.*strcmp.*args.*@@.*==" /project/common/flatpak-run.c; then
+    echo "Found code that processes @@ tokens in command line arguments"
+    
+    # Now let's check if the code actually allows @@ tokens in desktop files
+    # by examining the export_desktop_file function in flatpak-dir.c
+    
+    # Extract the relevant part of the code
+    grep -A 50 "export_desktop_file" /project/common/flatpak-dir.c > /tmp/flatpak-test/export_desktop_file.c
+    
+    # Check if there's any code that rejects @@ tokens
+    if grep -q "if.*strstr.*@@.*return FALSE" /tmp/flatpak-test/export_desktop_file.c; then
+        echo "Found code that rejects @@ tokens in desktop files"
+        echo "The vulnerability appears to be fixed"
+        exit 0
+    else
+        # The code processes @@ tokens and doesn't reject them in desktop files
+        echo "VULNERABILITY DETECTED: The code is vulnerable to CWE-94 via @@ tokens in desktop files"
+        exit 1
+    fi
+else
+    echo "Could not determine if the code is vulnerable"
+    exit 2
+fi
