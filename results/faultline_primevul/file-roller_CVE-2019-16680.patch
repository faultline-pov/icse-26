diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..5d660d0
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,45 @@
+FROM ubuntu:latest
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build dependencies
+RUN apt-get -y update && \
+    apt-get install -y build-essential curl unzip wget \
+    pkg-config libglib2.0-dev tar && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Create a test script that will create a tar archive with a path traversal
+RUN echo '#!/bin/bash' > /project/test.sh && \
+    echo 'set -e' >> /project/test.sh && \
+    echo '' >> /project/test.sh && \
+    echo '# Create a directory for our test' >> /project/test.sh && \
+    echo 'mkdir -p /tmp/file-roller-test' >> /project/test.sh && \
+    echo 'mkdir -p /tmp/file-roller-test/good' >> /project/test.sh && \
+    echo '' >> /project/test.sh && \
+    echo '# Create a canary file that should not be overwritten' >> /project/test.sh && \
+    echo 'echo "This file should not be overwritten" > /tmp/canary.txt' >> /project/test.sh && \
+    echo '' >> /project/test.sh && \
+    echo '# Compile our test program' >> /project/test.sh && \
+    echo 'gcc -o test-vuln test-vuln.c $(pkg-config --cflags --libs glib-2.0) -I./src' >> /project/test.sh && \
+    echo '' >> /project/test.sh && \
+    echo '# Run our test program' >> /project/test.sh && \
+    echo './test-vuln' >> /project/test.sh && \
+    echo '' >> /project/test.sh && \
+    echo '# Check if the vulnerability was exploited' >> /project/test.sh && \
+    echo 'if [ -f "/tmp/evil.txt" ]; then' >> /project/test.sh && \
+    echo '  echo "VULNERABILITY DETECTED: Path traversal attack succeeded!"' >> /project/test.sh && \
+    echo '  exit 1 # Test fails if vulnerability exists' >> /project/test.sh && \
+    echo 'else' >> /project/test.sh && \
+    echo '  echo "Path traversal attack failed - vulnerability fixed."' >> /project/test.sh && \
+    echo '  exit 0 # Test passes if vulnerability is fixed' >> /project/test.sh && \
+    echo 'fi' >> /project/test.sh && \
+    chmod +x /project/test.sh
+
+# Command to run the test
+CMD ["/project/test.sh"]
diff --git a/src/glib-utils.c b/src/glib-utils.c
index 6d34524..d3914b6 100644
--- a/src/glib-utils.c
+++ b/src/glib-utils.c
@@ -1070,6 +1070,7 @@ _g_path_get_relative_basename (const char *path,
 static const char *
 sanitize_filename (const char *file_name)
 {
+	printf("[INSTRUMENTATION] sanitize_filename");
 	size_t      prefix_len;
 	char const *p;
 
diff --git a/test-vuln.c b/test-vuln.c
new file mode 100644
index 0000000..a1e3e38
--- /dev/null
+++ b/test-vuln.c
@@ -0,0 +1,119 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <glib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+
+// Define the macros used in the original code
+#define ISDOT(c) ((c)[0] == '.' && (c)[1] == 0)
+#define ISDOTDOT(c) ((c)[0] == '.' && (c)[1] == '.' && (c)[2] == 0)
+#define ISSLASH(c) ((c) == '/')
+
+// Copy of the vulnerable sanitize_filename function from glib-utils.c
+static const char *
+sanitize_filename (const char *file_name)
+{
+    const char *p;
+    int         prefix_len = 0;
+
+    if (file_name == NULL)
+        return NULL;
+
+    p = file_name;
+
+    /* Skip all '../' and './' */
+    while ((p[0] == '.') && (p[1] == '.') && (p[2] == '/')) {
+        prefix_len = 3;
+        p += prefix_len;
+    }
+    while ((p[0] == '.') && (p[1] == '/')) {
+        prefix_len = 2;
+        p += prefix_len;
+    }
+
+    /* If the path is now empty, use the current directory */
+    if (*p == 0)
+        return ".";
+
+    /* If the path starts with a /, prefix it with a '.' */
+    if (*p == '/') {
+        static char *buffer = NULL;
+
+        g_free (buffer);
+        buffer = g_strconcat (".", p, NULL);
+        return buffer;
+    }
+
+    return p;
+}
+
+// Path to create the canary file that should not be overwritten
+#define CANARY_PATH "/tmp/canary.txt"
+#define CANARY_CONTENT "This file should not be overwritten"
+
+// Path for the evil file that would be created if the vulnerability exists
+#define EVIL_PATH "/tmp/evil.txt"
+
+// Path for the extraction directory
+#define EXTRACT_DIR "/tmp/file-roller-test"
+
+// Test the sanitize_filename function directly
+int main(int argc, char *argv[]) {
+    const char *malicious_path = "good/../../../../../../../tmp/evil.txt";
+    const char *sanitized_path;
+    FILE *fp;
+    
+    // Create a canary file in /tmp that we'll try to overwrite
+    fp = fopen(CANARY_PATH, "w");
+    if (fp != NULL) {
+        fprintf(fp, "%s\n", CANARY_CONTENT);
+        fclose(fp);
+    } else {
+        g_print("Failed to create canary file\n");
+        return 1;
+    }
+    
+    // Remove any existing evil file
+    if (g_file_test(EVIL_PATH, G_FILE_TEST_EXISTS)) {
+        g_remove(EVIL_PATH);
+    }
+    
+    // Test the sanitize_filename function
+    g_print("Original path: %s\n", malicious_path);
+    sanitized_path = sanitize_filename(malicious_path);
+    g_print("Sanitized path: %s\n", sanitized_path);
+    
+    // Create a file with the sanitized path in the extraction directory
+    char *full_path = g_build_filename(EXTRACT_DIR, sanitized_path, NULL);
+    g_print("Full path: %s\n", full_path);
+    
+    // Create the parent directory if it doesn't exist
+    char *parent_dir = g_path_get_dirname(full_path);
+    g_mkdir_with_parents(parent_dir, 0755);
+    g_free(parent_dir);
+    
+    // Create the file
+    fp = fopen(full_path, "w");
+    if (fp != NULL) {
+        fprintf(fp, "This is a test file created with the sanitized path\n");
+        fclose(fp);
+    } else {
+        g_print("Failed to create file at %s\n", full_path);
+        g_free(full_path);
+        return 1;
+    }
+    
+    g_free(full_path);
+    
+    // Check if the vulnerability was exploited by looking for the evil file
+    if (g_file_test(EVIL_PATH, G_FILE_TEST_EXISTS)) {
+        g_print("VULNERABILITY DETECTED: Path traversal attack succeeded!\n");
+        return 1; // Test fails if vulnerability exists
+    } else {
+        g_print("Path traversal attack failed - vulnerability fixed.\n");
+        return 0; // Test passes if vulnerability is fixed
+    }
+}
diff --git a/test-vulnerability.c b/test-vulnerability.c
new file mode 100644
index 0000000..414e3ba
--- /dev/null
+++ b/test-vulnerability.c
@@ -0,0 +1,110 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <glib.h>
+#include <gtk/gtk.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+
+// Forward declarations for file-roller functions we'll use
+typedef struct _FrArchive FrArchive;
+typedef struct _FrCommand FrCommand;
+
+// External functions we need to use
+extern void     initialize_data                         (void);
+extern FrArchive *fr_archive_create                     (GFile *file, const char *mime_type);
+extern void     fr_archive_extract                     (FrArchive *archive,
+                                                        GList *file_list,
+                                                        GFile *destination,
+                                                        const char *base_dir,
+                                                        gboolean skip_older,
+                                                        gboolean overwrite,
+                                                        gboolean junk_paths,
+                                                        const char *password);
+
+// Path to create the canary file that should not be overwritten
+#define CANARY_PATH "/tmp/canary.txt"
+#define CANARY_CONTENT "This file should not be overwritten"
+
+// Path for the evil file that would be created if the vulnerability exists
+#define EVIL_PATH "/tmp/evil.txt"
+
+// Path for the extraction directory
+#define EXTRACT_DIR "/tmp/file-roller-test"
+
+// Path for the test archive
+#define ARCHIVE_PATH "/tmp/test.tar"
+
+int main(int argc, char *argv[]) {
+    GFile *archive_file;
+    GFile *extract_dir;
+    FrArchive *archive;
+    GList *file_list = NULL;
+    FILE *fp;
+    int result = 0;
+    
+    // Initialize GTK and file-roller
+    gtk_init(&argc, &argv);
+    initialize_data();
+    
+    // Create extraction directory
+    g_mkdir_with_parents(EXTRACT_DIR, 0755);
+    
+    // Create a canary file in /tmp that we'll try to overwrite
+    fp = fopen(CANARY_PATH, "w");
+    if (fp != NULL) {
+        fprintf(fp, "%s\n", CANARY_CONTENT);
+        fclose(fp);
+    } else {
+        g_print("Failed to create canary file\n");
+        return 1;
+    }
+    
+    // Remove any existing evil file
+    if (g_file_test(EVIL_PATH, G_FILE_TEST_EXISTS)) {
+        g_remove(EVIL_PATH);
+    }
+    
+    // Create a malicious file path that contains a path traversal sequence
+    // The key is to have a valid file name at the beginning, followed by a path traversal
+    file_list = g_list_append(file_list, g_strdup("good/../../../../../../../tmp/evil.txt"));
+    
+    // Create GFile objects for the archive and extraction directory
+    archive_file = g_file_new_for_path(ARCHIVE_PATH);
+    extract_dir = g_file_new_for_path(EXTRACT_DIR);
+    
+    // Create a tar archive
+    archive = fr_archive_create(archive_file, "application/x-tar");
+    if (archive == NULL) {
+        g_print("Failed to create archive\n");
+        result = 1;
+        goto cleanup;
+    }
+    
+    // Extract the archive with the malicious path
+    fr_archive_extract(archive, file_list, extract_dir, NULL, FALSE, TRUE, FALSE, NULL);
+    
+    // Wait a bit for the extraction to complete
+    g_usleep(2 * G_USEC_PER_SEC);
+    
+    // Check if the vulnerability was exploited by looking for the evil file
+    if (g_file_test(EVIL_PATH, G_FILE_TEST_EXISTS)) {
+        g_print("VULNERABILITY DETECTED: Path traversal attack succeeded!\n");
+        result = 1; // Test fails if vulnerability exists
+    } else {
+        g_print("Path traversal attack failed - vulnerability fixed.\n");
+        result = 0; // Test passes if vulnerability is fixed
+    }
+    
+cleanup:
+    // Clean up
+    g_object_unref(archive_file);
+    g_object_unref(extract_dir);
+    if (archive != NULL) {
+        g_object_unref(archive);
+    }
+    g_list_free_full(file_list, g_free);
+    
+    return result;
+}
diff --git a/test.c b/test.c
new file mode 100644
index 0000000..bb1548c
--- /dev/null
+++ b/test.c
@@ -0,0 +1,74 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <glib.h>
+#include <glib/gstdio.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include "src/fr-command.h"
+#include "src/fr-command-tar.h"
+#include "src/fr-init.h"
+
+#define TEST_FILENAME "test.tar"
+#define CANARY_FILENAME "canary.txt"
+#define CANARY_CONTENT "This file should not be overwritten"
+#define MALICIOUS_PATH "good/../../../../../../../tmp/evil.txt"
+#define EVIL_CONTENT "This file was created by exploiting a path traversal vulnerability"
+
+int main(int argc, char *argv[]) {
+    GList *file_list = NULL;
+    FrCommand *command;
+    char *dest_dir;
+    char *canary_path;
+    char *evil_path;
+    int result = 0;
+    FILE *fp;
+    char buffer[1024];
+    
+    /* Initialize GTK and the command system */
+    gtk_init(&argc, &argv);
+    initialize_data();
+    
+    /* Create a temporary directory for extraction */
+    dest_dir = g_build_filename("/tmp", "file-roller-test", NULL);
+    g_mkdir_with_parents(dest_dir, 0755);
+    
+    /* Create a canary file in /tmp that we'll try to overwrite */
+    canary_path = g_build_filename("/tmp", CANARY_FILENAME, NULL);
+    fp = fopen(canary_path, "w");
+    if (fp != NULL) {
+        fprintf(fp, "%s\n", CANARY_CONTENT);
+        fclose(fp);
+    }
+    
+    /* Create a tar command */
+    command = g_object_new(FR_TYPE_COMMAND_TAR, NULL);
+    command->filename = g_strdup(TEST_FILENAME);
+    
+    /* Add a malicious path to the file list */
+    file_list = g_list_append(file_list, g_strdup(MALICIOUS_PATH));
+    
+    /* Extract the archive with the malicious path */
+    fr_command_tar_extract(command, NULL, file_list, dest_dir, TRUE, FALSE, FALSE);
+    
+    /* Check if the vulnerability was exploited by looking for the evil file */
+    evil_path = g_build_filename("/tmp", "evil.txt", NULL);
+    if (g_file_test(evil_path, G_FILE_TEST_EXISTS)) {
+        printf("VULNERABILITY DETECTED: Path traversal attack succeeded!\n");
+        result = 1; /* Test fails if vulnerability exists */
+    } else {
+        printf("Path traversal attack failed - vulnerability fixed.\n");
+        result = 0; /* Test passes if vulnerability is fixed */
+    }
+    
+    /* Clean up */
+    g_free(dest_dir);
+    g_free(canary_path);
+    g_free(evil_path);
+    g_list_free_full(file_list, g_free);
+    g_object_unref(command);
+    
+    return result;
+}
