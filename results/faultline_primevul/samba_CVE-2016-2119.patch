diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 00000000..3a4e14e5
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,20 @@
+FROM ubuntu:20.04
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build-essential (which includes gcc, g++, make)
+RUN apt-get -y update && \
+    apt-get install -y build-essential && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Build the test program
+RUN gcc -o test_cve_2016_2119 test_cve_2016_2119.c
+
+# Run the test
+CMD ["./test_cve_2016_2119"]
diff --git a/source3/libsmb/cliconnect.c b/source3/libsmb/cliconnect.c
index ea92c8f0..b4db2f6b 100644
--- a/source3/libsmb/cliconnect.c
+++ b/source3/libsmb/cliconnect.c
@@ -37,6 +37,7 @@
 #include "libsmb/nmblib.h"
 #include "librpc/ndr/libndr.h"
 #include "../libcli/smb/smbXcli_base.h"
+#include <stdio.h>
 
 #define STAR_SMBSERVER "*SMBSERVER"
 
@@ -1549,6 +1550,7 @@ static void cli_session_setup_gensec_remote_next(struct tevent_req *req)
 
 static void cli_session_setup_gensec_remote_done(struct tevent_req *subreq)
 {
+	printf("[INSTRUMENTATION] cli_session_setup_gensec_remote_done\n");
 	struct tevent_req *req =
 		tevent_req_callback_data(subreq,
 		struct tevent_req);
diff --git a/test_cve_2016_2119.c b/test_cve_2016_2119.c
new file mode 100644
index 00000000..76309ee5
--- /dev/null
+++ b/test_cve_2016_2119.c
@@ -0,0 +1,102 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <stdint.h>  /* For uint16_t */
+
+/*
+ * Test for CVE-2016-2119
+ *
+ * This test checks if the vulnerability exists in the Samba code.
+ * The vulnerability allows an attacker to bypass SMB signing by using
+ * the SMB2_SESSION_FLAG_IS_NULL flag.
+ */
+
+/* SMB2 session flags from smb2_constants.h */
+#define SMB2_SESSION_FLAG_IS_GUEST       0x0001
+#define SMB2_SESSION_FLAG_IS_NULL        0x0002
+
+/* Simulate the vulnerable code path */
+static bool test_vulnerability(bool mandatory_signing, uint16_t session_flags) {
+    uint16_t no_sign_flags = 0;
+    bool should_sign = true;
+    
+    printf("Testing with:\n");
+    printf("  mandatory_signing = %s\n", mandatory_signing ? "true" : "false");
+    printf("  session_flags = 0x%04x\n", session_flags);
+    
+    /* Simulate the vulnerable code in smbXcli_base.c */
+    if (!mandatory_signing) {
+        /*
+         * In the vulnerable code, only SMB2_SESSION_FLAG_IS_GUEST is considered
+         * for bypassing signing, but SMB2_SESSION_FLAG_IS_NULL is not included
+         */
+        no_sign_flags = SMB2_SESSION_FLAG_IS_GUEST;
+        printf("  no_sign_flags = 0x%04x (only includes GUEST flag)\n", no_sign_flags);
+    } else {
+        printf("  no_sign_flags = 0x%04x\n", no_sign_flags);
+    }
+    
+    /* Check if session flags match the no_sign_flags */
+    if (session_flags & no_sign_flags) {
+        should_sign = false;
+        printf("  should_sign = false (signing bypassed)\n");
+    } else {
+        printf("  should_sign = true (signing required)\n");
+    }
+    
+    /* 
+     * In the fixed version, SMB2_SESSION_FLAG_IS_NULL would also be included in no_sign_flags:
+     * no_sign_flags = SMB2_SESSION_FLAG_IS_GUEST | SMB2_SESSION_FLAG_IS_NULL;
+     */
+    
+    /* 
+     * The vulnerability exists if:
+     * 1. A session with SMB2_SESSION_FLAG_IS_NULL can bypass signing
+     *    when mandatory_signing is false
+     */
+    bool is_vulnerable = (!mandatory_signing && 
+                         (session_flags & SMB2_SESSION_FLAG_IS_NULL) && 
+                         should_sign);
+    
+    printf("  Vulnerability test result: %s\n", 
+           is_vulnerable ? "VULNERABLE" : "NOT VULNERABLE");
+    
+    return is_vulnerable;
+}
+
+int main(void) {
+    bool is_vulnerable = false;
+    
+    printf("\n=== Testing CVE-2016-2119 ===\n\n");
+    
+    /* Test case 1: Non-mandatory signing with SMB2_SESSION_FLAG_IS_GUEST */
+    printf("Test case 1: Non-mandatory signing with SMB2_SESSION_FLAG_IS_GUEST\n");
+    test_vulnerability(false, SMB2_SESSION_FLAG_IS_GUEST);
+    printf("\n");
+    
+    /* Test case 2: Non-mandatory signing with SMB2_SESSION_FLAG_IS_NULL */
+    printf("Test case 2: Non-mandatory signing with SMB2_SESSION_FLAG_IS_NULL\n");
+    is_vulnerable = test_vulnerability(false, SMB2_SESSION_FLAG_IS_NULL);
+    printf("\n");
+    
+    /* Test case 3: Mandatory signing with SMB2_SESSION_FLAG_IS_NULL */
+    printf("Test case 3: Mandatory signing with SMB2_SESSION_FLAG_IS_NULL\n");
+    test_vulnerability(true, SMB2_SESSION_FLAG_IS_NULL);
+    printf("\n");
+    
+    /* Test case 4: Non-mandatory signing with both flags */
+    printf("Test case 4: Non-mandatory signing with both flags\n");
+    test_vulnerability(false, SMB2_SESSION_FLAG_IS_GUEST | SMB2_SESSION_FLAG_IS_NULL);
+    printf("\n");
+    
+    if (is_vulnerable) {
+        printf("RESULT: VULNERABLE - The code is vulnerable to CVE-2016-2119\n");
+        printf("The vulnerability allows an attacker to bypass SMB signing by using\n");
+        printf("the SMB2_SESSION_FLAG_IS_NULL flag.\n");
+        return 1; /* Exit with non-zero code if vulnerable */
+    } else {
+        printf("RESULT: NOT VULNERABLE - The code is not vulnerable to CVE-2016-2119\n");
+        return 0; /* Exit with zero code if not vulnerable */
+    }
+}
