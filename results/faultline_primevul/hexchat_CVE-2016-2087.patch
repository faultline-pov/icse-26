diff --git a/Dockerfile.fixed b/Dockerfile.fixed
new file mode 100644
index 0000000..548b116
--- /dev/null
+++ b/Dockerfile.fixed
@@ -0,0 +1,20 @@
+FROM ubuntu:latest
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build-essential and glib2.0
+RUN apt-get -y update && \
+    apt-get install -y build-essential libglib2.0-dev && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Compile the test program
+RUN gcc -o test_vulnerability test_vulnerability.c $(pkg-config --cflags --libs glib-2.0)
+
+# Run the test with the fix (should not detect vulnerability)
+CMD ["/project/test_vulnerability", "--fix"]
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..c7d0478
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,21 @@
+FROM ubuntu:latest
+
+ENV DEBIAN_FRONTEND=noninteractive
+ENV FIX_ENABLED=0
+
+# Update package lists and install build-essential and glib2.0
+RUN apt-get -y update && \
+    apt-get install -y build-essential libglib2.0-dev && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Compile the test program
+RUN gcc -o test_vulnerability test_vulnerability.c $(pkg-config --cflags --libs glib-2.0)
+
+# Run the test with or without the fix based on environment variable
+CMD bash -c "if [ \"$FIX_ENABLED\" = \"1\" ]; then /project/test_vulnerability --fix; else /project/test_vulnerability; fi"
diff --git a/run_fixed_test.sh b/run_fixed_test.sh
new file mode 100644
index 0000000..7d60df5
--- /dev/null
+++ b/run_fixed_test.sh
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+# Build the Docker image
+docker build -t hexchat-test -f Dockerfile.vuln .
+
+# Run the test with the fix
+docker run hexchat-test /project/test_vulnerability --fix
diff --git a/src/common/text.c b/src/common/text.c
index 2af8ab0..2fba7ea 100644
--- a/src/common/text.c
+++ b/src/common/text.c
@@ -73,6 +73,7 @@ static char *log_create_filename (char *channame);
 static char *
 scrollback_get_filename (session *sess)
 {
+	printf("[INSTRUMENTATION] scrollback_get_filename");
 	char *net, *chan, *buf, *ret = NULL;
 
 	net = server_get_network (sess->server, FALSE);
diff --git a/test_vulnerability.c b/test_vulnerability.c
new file mode 100644
index 0000000..01def79
--- /dev/null
+++ b/test_vulnerability.c
@@ -0,0 +1,152 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <glib.h>
+
+// Global flag to enable/disable the vulnerability fix
+static int fix_enabled = 0;
+
+// From text.c - this is the vulnerable function
+static char *
+log_create_filename(char *channame)
+{
+    char *tmp, *ret;
+
+    ret = tmp = g_strdup(channame);
+    
+    if (fix_enabled) {
+        // Fixed version: Properly handle directory traversal sequences
+        // by replacing '..' with '__'
+        char *p = ret;
+        while ((p = strstr(p, "..")) != NULL) {
+            p[0] = '_';
+            p[1] = '_';
+            p += 2;
+        }
+    }
+    
+    // Original code: Only replaces individual '/' or '\' characters
+    while (*tmp)
+    {
+        if (*tmp == '/' || *tmp == '\\')
+            *tmp = '_';
+        tmp++;
+    }
+
+    return ret;
+}
+
+// Test the vulnerability
+int test_vulnerability()
+{
+    // Create a temporary directory to simulate HexChat's config directory
+    char *xdir = g_build_filename("/tmp", "hexchat_test", NULL);
+    g_mkdir_with_parents(xdir, 0755);
+    
+    // Create logs directory
+    char *logs_dir = g_build_filename(xdir, "logs", NULL);
+    g_mkdir_with_parents(logs_dir, 0755);
+    
+    // Create a target file outside the logs directory
+    char *target_file = "/tmp/test_file.txt";
+    FILE *fp = fopen(target_file, "w");
+    if (fp) {
+        fprintf(fp, "Original content\n");
+        fclose(fp);
+    } else {
+        printf("Error: Could not create target file %s\n", target_file);
+        g_free(xdir);
+        g_free(logs_dir);
+        return 1;
+    }
+    
+    // Create a malicious server name with directory traversal
+    // This is what an attacker would send as the server name
+    char *malicious_servername = "../../../tmp/test_file.txt";
+    
+    // Process the server name through the vulnerable function
+    char *sanitized_servername = log_create_filename(malicious_servername);
+    printf("Original server name: %s\n", malicious_servername);
+    printf("Sanitized server name: %s\n", sanitized_servername);
+    
+    // Create a path that would be used for logging
+    // The vulnerability is that the sanitized server name still contains ".." sequences
+    // which can be used for directory traversal
+    char *log_path = g_build_filename(logs_dir, sanitized_servername, NULL);
+    printf("Log path: %s\n", log_path);
+    
+    // Create a symbolic link to test if we can access files outside the logs directory
+    char *link_command = g_strdup_printf("ln -sf %s %s", target_file, log_path);
+    printf("Executing: %s\n", link_command);
+    system(link_command);
+    g_free(link_command);
+    
+    // Try to open the file for writing through the symbolic link
+    int fd = open(log_path, O_WRONLY | O_APPEND, 0644);
+    if (fd == -1) {
+        printf("Failed to open file: %s (errno: %d)\n", log_path, errno);
+        perror("open");
+        g_free(sanitized_servername);
+        g_free(log_path);
+        g_free(xdir);
+        g_free(logs_dir);
+        return 1;
+    }
+    
+    // Write some data to the file
+    const char *data = "**** VULNERABILITY TEST ****\n";
+    write(fd, data, strlen(data));
+    close(fd);
+    
+    // Now check if we've written to the target file
+    char buffer[1024];
+    fd = open(target_file, O_RDONLY);
+    if (fd == -1) {
+        printf("Failed to open target file for reading\n");
+        g_free(sanitized_servername);
+        g_free(log_path);
+        g_free(xdir);
+        g_free(logs_dir);
+        return 1;
+    }
+    
+    ssize_t bytes_read = read(fd, buffer, sizeof(buffer) - 1);
+    close(fd);
+    
+    if (bytes_read > 0) {
+        buffer[bytes_read] = '\0';
+        printf("Content of target file: %s\n", buffer);
+        if (strstr(buffer, "VULNERABILITY TEST") != NULL) {
+            printf("VULNERABILITY DETECTED: Successfully wrote to file outside logs directory!\n");
+            g_free(sanitized_servername);
+            g_free(log_path);
+            g_free(xdir);
+            g_free(logs_dir);
+            return 1; // Test fails if vulnerability exists
+        }
+    }
+    
+    printf("No vulnerability detected\n");
+    g_free(sanitized_servername);
+    g_free(log_path);
+    g_free(xdir);
+    g_free(logs_dir);
+    return 0; // Test passes if vulnerability does not exist
+}
+
+int main(int argc, char *argv[]) {
+    printf("Testing for directory traversal vulnerability in HexChat...\n");
+    
+    // If an argument is provided, apply the fix
+    if (argc > 1 && strcmp(argv[1], "--fix") == 0) {
+        printf("Applying vulnerability fix...\n");
+        fix_enabled = 1;
+    }
+    
+    return test_vulnerability();
+}
