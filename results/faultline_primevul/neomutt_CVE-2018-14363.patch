diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..2f9f640
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,31 @@
+FROM ubuntu:18.04
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build dependencies
+RUN apt-get -y update && \
+    apt-get install -y build-essential curl unzip wget \
+    libncurses5-dev libncursesw5-dev libssl-dev libsasl2-dev \
+    tcl autoconf automake libtool pkg-config \
+    libgpgme11-dev libidn11-dev libtokyocabinet-dev \
+    libnotmuch-dev libgss-dev libxml2-dev libxslt1-dev \
+    libgdbm-dev libdb-dev libslang2-dev liblua5.2-dev \
+    libgnutls28-dev gettext && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Create directories for the test
+RUN mkdir -p /tmp/neomutt_cache
+RUN mkdir -p /tmp/neomutt_news_cache
+RUN echo "test file" > /tmp/secret.txt
+
+# Compile the test program
+RUN gcc -o test_path_traversal test_path_traversal.c
+
+# Run the test
+CMD ["/project/test_path_traversal"]
diff --git a/newsrc.c.new b/newsrc.c.new
new file mode 100644
index 0000000..0abfee7
--- /dev/null
+++ b/newsrc.c.new
@@ -0,0 +1,214 @@
+/**
+ * @file
+ * Read/parse/write an NNTP config file of subscribed newsgroups
+ *
+ * @authors
+ * Copyright (C) 1998 Brandon Long <blong@fiction.net>
+ * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>
+ * Copyright (C) 2000-2017 Vsevolod Volkov <vvv@mutt.org.ua>
+ *
+ * @copyright
+ * This program is free software: you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation, either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/**
+ * @page newsrc Read/parse/write an NNTP config file of subscribed newsgroups
+ *
+ * Read/parse/write an NNTP config file of subscribed newsgroups
+ */
+
+#include "config.h"
+#include <dirent.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <time.h>
+#include <unistd.h>
+#include "mutt/mutt.h"
+#include "conn/conn.h"
+#include "mutt.h"
+#include "bcache.h"
+#include "context.h"
+#include "format_flags.h"
+#include "globals.h"
+#include "header.h"
+#include "mutt_account.h"
+#include "mutt_curses.h"
+#include "mutt_socket.h"
+#include "mutt_window.h"
+#include "mx.h"
+#include "nntp.h"
+#include "options.h"
+#include "protos.h"
+#include "sort.h"
+#include "url.h"
+#ifdef USE_HCACHE
+#include "hcache/hcache.h"
+#endif
+
+struct BodyCache;
+
+/**
+ * nntp_data_find - Find NntpData for given newsgroup or add it
+ * @param nserv NNTP server
+ * @param group Newsgroup
+ * @retval ptr  NNTP data
+ * @retval NULL Error
+ */
+static struct NntpData *nntp_data_find(struct NntpServer *nserv, const char *group)
+{
+  struct NntpData *nntp_data = mutt_hash_find(nserv->groups_hash, group);
+  if (nntp_data)
+    return nntp_data;
+
+  size_t len = strlen(group) + 1;
+  /* create NntpData structure and add it to hash */
+  nntp_data = mutt_mem_calloc(1, sizeof(struct NntpData) + len);
+  nntp_data->group = (char *) nntp_data + sizeof(struct NntpData);
+  mutt_str_strfcpy(nntp_data->group, group, len);
+  nntp_data->nserv = nserv;
+  nntp_data->deleted = true;
+  mutt_hash_insert(nserv->groups_hash, nntp_data->group, nntp_data);
+
+  /* add NntpData to list */
+  if (nserv->groups_num >= nserv->groups_max)
+  {
+    nserv->groups_max *= 2;
+    mutt_mem_realloc(&nserv->groups_list, nserv->groups_max * sizeof(nntp_data));
+  }
+  nserv->groups_list[nserv->groups_num++] = nntp_data;
+
+  return nntp_data;
+}
+
+/**
+ * nntp_acache_free - Remove all temporarily cache files
+ * @param nntp_data NNTP data
+ */
+void nntp_acache_free(struct NntpData *nntp_data)
+{
+  for (int i = 0; i < NNTP_ACACHE_LEN; i++)
+  {
+    if (nntp_data->acache[i].path)
+    {
+      unlink(nntp_data->acache[i].path);
+      FREE(&nntp_data->acache[i].path);
+    }
+  }
+}
+
+/**
+ * nntp_data_free - Free NntpData
+ * @param data NNTP data
+ */
+void nntp_data_free(void *data)
+{
+  struct NntpData *nntp_data = data;
+
+  if (!nntp_data)
+    return;
+  nntp_acache_free(nntp_data);
+  FREE(&nntp_data->newsrc_ent);
+  FREE(&nntp_data->desc);
+  if (nntp_data->bcache)
+  {
+    mutt_bcache_close(&nntp_data->bcache);
+    nntp_data->bcache = NULL;
+  }
+  FREE(&data);
+}
+
+/**
+ * nntp_hash_destructor - Free our hash table data - Implements ::hash_hdata_free_t
+ */
+static void nntp_hash_destructor(int type, void *obj, intptr_t data)
+{
+  nntp_data_free(obj);
+}
+
+/**
+ * nntp_newsrc_close - Unlock and close .newsrc file
+ * @param nserv NNTP server
+ */
+void nntp_newsrc_close(struct NntpServer *nserv)
+{
+  if (!nserv)
+    return;
+
+  if (nserv->newsrc_fp)
+  {
+    mutt_file_unlock(fileno(nserv->newsrc_fp));
+    mutt_file_fclose(&nserv->newsrc_fp);
+  }
+}
+
+/**
+ * nntp_group_unread_stat - Count number of unread articles
+ * @param nntp_data NNTP data
+ */
+void nntp_group_unread_stat(struct NntpData *nntp_data)
+{
+  nntp_data->unread = 0;
+  if (nntp_data->last_message == 0 || nntp_data->first_message > nntp_data->last_message)
+    return;
+
+  nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;
+  for (unsigned int i = 0; i < nntp_data->newsrc_len; i++)
+    nntp_data->unread -=
+        nntp_data->newsrc_ent[i].last - nntp_data->newsrc_ent[i].first + 1;
+}
+
+/**
+ * cache_expand - Make fully qualified cache file name
+ * @param dst    Buffer for the result
+ * @param dstlen Length of buffer
+ * @param acct   Account
+ * @param src    Path to expand
+ */
+static void cache_expand(char *dst, size_t dstlen, struct Account *acct, char *src)
+{
+  char *c = NULL;
+  char file[PATH_MAX];
+
+  printf("DEBUG: cache_expand called with src=%s\n", src ? src : "NULL");
+
+  /* server subdirectory */
+  if (acct)
+  {
+    struct Url url;
+
+    mutt_account_tourl(acct, &url);
+    url.path = src;
+    printf("DEBUG: url.path set to %s\n", url.path ? url.path : "NULL");
+    url_tostring(&url, file, sizeof(file), U_PATH);
+    printf("DEBUG: url_tostring result: %s\n", file);
+  }
+  else
+    mutt_str_strfcpy(file, src ? src : "", sizeof(file));
+
+  printf("DEBUG: NewsCacheDir=%s, file=%s\n", NewsCacheDir ? NewsCacheDir : "NULL", file);
+  snprintf(dst, dstlen, "%s/%s", NewsCacheDir, file);
+  printf("DEBUG: Final path before expansion: %s\n", dst);
+
+  /* remove trailing slash */
+  c = dst + strlen(dst) - 1;
+  if (*c == '/')
+    *c = '\0';
+  mutt_expand_path(dst, dstlen);
+  mutt_encode_path(dst, dstlen, dst);
+  printf("DEBUG: Final expanded path: %s\n", dst);
+}
diff --git a/test_path_traversal.c b/test_path_traversal.c
new file mode 100644
index 0000000..f13fb84
--- /dev/null
+++ b/test_path_traversal.c
@@ -0,0 +1,172 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+// Define the necessary structures and variables
+struct Url {
+    char *scheme;
+    char *user;
+    char *pass;
+    char *host;
+    unsigned short port;
+    char *path;
+};
+
+struct Account {
+    char user[64];
+    char pass[64];
+    char host[64];
+    unsigned short port;
+};
+
+char *NewsCacheDir = "/tmp/neomutt_news_cache";
+
+// Define the U_PATH flag for url_tostring
+#define U_PATH (1<<0)
+
+// Function prototypes
+void mutt_account_tourl(struct Account *acct, struct Url *url);
+void url_tostring(struct Url *url, char *dest, size_t len, int flags);
+void mutt_expand_path(char *buf, size_t buflen);
+void mutt_encode_path(char *dest, size_t dlen, const char *src);
+
+// Implementation of the vulnerable function
+void cache_expand(char *dst, size_t dstlen, struct Account *acct, char *src)
+{
+    char *c = NULL;
+    char file[4096];
+
+    printf("DEBUG: cache_expand called with src=%s\n", src ? src : "NULL");
+
+    /* server subdirectory */
+    if (acct)
+    {
+        struct Url url;
+        memset(&url, 0, sizeof(url));
+
+        mutt_account_tourl(acct, &url);
+        url.path = src;
+        printf("DEBUG: url.path set to %s\n", url.path ? url.path : "NULL");
+        url_tostring(&url, file, sizeof(file), U_PATH);
+        printf("DEBUG: url_tostring result: %s\n", file);
+    }
+    else
+        strncpy(file, src ? src : "", sizeof(file) - 1);
+
+    printf("DEBUG: NewsCacheDir=%s, file=%s\n", NewsCacheDir ? NewsCacheDir : "NULL", file);
+    snprintf(dst, dstlen, "%s/%s", NewsCacheDir, file);
+    printf("DEBUG: Final path: %s\n", dst);
+
+    /* remove trailing slash */
+    c = dst + strlen(dst) - 1;
+    if (*c == '/')
+        *c = '\0';
+}
+
+// Simplified implementations of required functions
+void mutt_account_tourl(struct Account *acct, struct Url *url)
+{
+    if (acct && url)
+    {
+        url->host = acct->host;
+        url->user = acct->user;
+        url->pass = acct->pass;
+        url->port = acct->port;
+    }
+}
+
+void url_tostring(struct Url *url, char *dest, size_t len, int flags)
+{
+    if (url && dest && len > 0)
+    {
+        if (flags & U_PATH)
+        {
+            strncpy(dest, url->path ? url->path : "", len - 1);
+            dest[len - 1] = '\0';
+        }
+    }
+}
+
+void mutt_expand_path(char *buf, size_t buflen)
+{
+    // No-op for the test
+}
+
+void mutt_encode_path(char *dest, size_t dlen, const char *src)
+{
+    // No-op for the test
+    if (dest && src && dest != src)
+        strncpy(dest, src, dlen - 1);
+}
+
+// Function to check if a path is within a directory
+int is_path_within_dir(const char *path, const char *dir)
+{
+    char real_path[4096];
+    char real_dir[4096];
+    
+    // Get the real path of both the path and the directory
+    if (realpath(path, real_path) == NULL) {
+        return 0; // Path doesn't exist or other error
+    }
+    
+    if (realpath(dir, real_dir) == NULL) {
+        return 0; // Directory doesn't exist or other error
+    }
+    
+    // Check if real_path starts with real_dir
+    return strncmp(real_path, real_dir, strlen(real_dir)) == 0;
+}
+
+int main(int argc, char *argv[])
+{
+    struct Account acct;
+    char dst[4096];
+    char *src = "../../../tmp/secret.txt"; // Malicious newsgroup name with path traversal
+    
+    // Create the cache directory if it doesn't exist
+    system("mkdir -p /tmp/neomutt_news_cache");
+    
+    // Create a test file outside the cache directory
+    system("echo 'test file' > /tmp/secret.txt");
+
+    // Initialize account
+    memset(&acct, 0, sizeof(acct));
+    strncpy(acct.host, "news.example.com", sizeof(acct.host) - 1);
+
+    // Call the vulnerable function
+    cache_expand(dst, sizeof(dst), &acct, src);
+
+    // Check if the resulting path is outside the cache directory
+    if (!is_path_within_dir(dst, NewsCacheDir))
+    {
+        // Try to access the file outside the cache directory
+        FILE *fp = fopen(dst, "r");
+        if (fp)
+        {
+            char buffer[256];
+            if (fgets(buffer, sizeof(buffer), fp))
+            {
+                printf("Successfully read file outside cache dir: %s\n", buffer);
+                fclose(fp);
+                // Vulnerability exists - return non-zero
+                return 1;
+            }
+            fclose(fp);
+        }
+        else
+        {
+            printf("Could not open file, but path is still outside cache dir: %s\n", dst);
+            // Vulnerability exists but file access failed - still return non-zero
+            return 1;
+        }
+    }
+    else
+    {
+        printf("Path is within cache directory - vulnerability is fixed\n");
+    }
+
+    // No vulnerability detected - return zero
+    return 0;
+}
