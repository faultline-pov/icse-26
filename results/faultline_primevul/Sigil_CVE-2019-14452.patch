diff --git a/CMakeLists.txt b/CMakeLists.txt
index 114c1b7..588655f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,107 +1,22 @@
-########################################################
-#  
-#  This is a CMake configuration file.
-#  To use it you need CMake which can be 
-#  downloaded from here: 
-#    http://www.cmake.org/cmake/resources/software.html
-#
-#########################################################
+cmake_minimum_required(VERSION 3.0)
+project(PathTraversalTest)
 
-cmake_minimum_required( VERSION 3.0 ) 
+# Find Qt5
+find_package(Qt5 COMPONENTS Core REQUIRED)
 
-project( Sigil ) 
+# Find minizip
+find_package(PkgConfig REQUIRED)
+pkg_check_modules(MINIZIP minizip REQUIRED)
 
-set( CMAKE_DEBUG_POSTFIX "d" )
-# Avoid the whole Release/Debug folder creation with Visual Studio
-if (MSVC_IDE)
-   set( CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG "${PROJECT_BINARY_DIR}/bin")
-   set( CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE "${PROJECT_BINARY_DIR}/bin")
-   set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG "${PROJECT_BINARY_DIR}/lib")
-   set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE "${PROJECT_BINARY_DIR}/lib")
-   set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG "${PROJECT_BINARY_DIR}/lib")
-   set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE "${PROJECT_BINARY_DIR}/lib")
-endif()
-set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/bin )
-set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib )
-set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib )
-set( PACKAGE_DIRECTORY ${PROJECT_BINARY_DIR}/package )
-set( CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_CURRENT_SOURCE_DIR}/cmake_extras" )
+# Set C++ standard
+set(CMAKE_CXX_STANDARD 11)
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
 
-set( SIGIL_MAJOR_VERSION 0 )
-set( SIGIL_MINOR_VERSION 9 )
-set( SIGIL_REVISION_VERSION 15 )
-set( SIGIL_FULL_VERSION ${SIGIL_MAJOR_VERSION}.${SIGIL_MINOR_VERSION}.${SIGIL_REVISION_VERSION} )
+# Add the executable
+add_executable(test_unzip test_unzip.cpp)
 
-if( UNIX AND NOT APPLE )
-   include(GNUInstallDirs)
+# Include directories
+target_include_directories(test_unzip PRIVATE ${MINIZIP_INCLUDE_DIRS})
 
-   # Make sure the correct rpath is set for the sigil executable
-   # on Linux -- for both the build and the installed versions.
-   # Needed to make sure the installed shared hunspell and gumbo
-   # libraries are found/used at runtime.
-
-   # use, i.e. don't skip the full RPATH for the build tree
-   SET(CMAKE_SKIP_BUILD_RPATH  FALSE)
-
-   # when building, don't use the install RPATH already
-   # (but later on when installing)
-   SET(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
-
-   SET(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_FULL_LIBDIR}/sigil")
-
-   # add the automatically determined parts of the RPATH
-   # which point to directories outside the build tree to the install RPATH.
-   # This will ensure the Qt5 lib directory is always included after install.
-   SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
-endif()
-
-# Check if platform is 64 bit
-if( NOT APPLE )
-   if( CMAKE_SIZEOF_VOID_P EQUAL 4 )
-     set( 64_BIT_PLATFORM 0 )
-   else()
-     set( 64_BIT_PLATFORM 1 )
-   endif()
-endif()
-
-# Profiler configuration for GCC
-if( CMAKE_COMPILER_IS_GNUCXX  )
-    set( CMAKE_BUILD_TYPE profiling )
-    set( CMAKE_CXX_FLAGS_PROFILING "-O2 -DNDEBUG -pg -g -fno-omit-frame-pointer -fno-inline-functions -fno-inline-functions-called-once -fno-optimize-sibling-calls" )
-
-    # After creating the new build type,
-    # we clear the default back to empty
-    set( CMAKE_BUILD_TYPE  )
-endif()
-
-if (USE_SYSTEM_LIBS)
-    MESSAGE(STATUS "Trying to use System Libraries...")
-    find_package( ZLIB )
-    find_package( PkgConfig )
-    find_package( MiniZip )
-    pkg_check_modules( HUNSPELL hunspell )
-    if ( NOT APPLE )
-        pkg_check_modules( PCRE libpcre16 )
-    endif()
-endif()
-
-if ( APPLE )
-    find_package(PythonInterp 3.7)
-    find_package (PythonLibs 3.7)
-endif()
-if ( WIN32 )
-    find_package(PythonInterp 3.5)
-    find_package (PythonLibs 3.5)
-endif()
-if( UNIX AND NOT APPLE )
-    find_package(PythonInterp 3.4)
-    find_package (PythonLibs 3.4)
-endif()
-
-# gumbo-parser it is our main xhtml/html5 parser.
-# We have an internal version because it diverges from Google's and GitHub's
-# versions and neither want's our epub specific changes.
-add_subdirectory( internal/gumbo )
-
-add_subdirectory( 3rdparty/ )
-add_subdirectory( src/ )
+# Link libraries
+target_link_libraries(test_unzip Qt5::Core ${MINIZIP_LIBRARIES} z)
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..2486331
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,27 @@
+FROM ubuntu:18.04
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build dependencies
+RUN apt-get -y update && \
+    apt-get install -y build-essential g++ cmake libqt5core5a qtbase5-dev libminizip-dev \
+    zlib1g-dev python3 python3-pip zip unzip pkg-config && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Create test directories
+RUN mkdir -p /tmp/extract_dir
+RUN mkdir -p /tmp/outside_dir
+
+# Build the test program
+RUN mkdir -p /project/build
+WORKDIR /project/build
+RUN cmake .. && make
+
+# Run the test
+CMD ["python3", "/project/test_path_traversal.py"]
diff --git a/src/Misc/Utility.cpp b/src/Misc/Utility.cpp
index 81100a7..3bc6c17 100644
--- a/src/Misc/Utility.cpp
+++ b/src/Misc/Utility.cpp
@@ -679,6 +679,7 @@ QString Utility::stdWStringToQString(const std::wstring &str)
 
 bool Utility::UnZip(const QString &zippath, const QString &destpath)
 {
+    printf("[INSTRUMENTATION] UnZip");
     int res = 0;
     QDir dir(destpath);
     if (!cp437) {
diff --git a/test_path_traversal.py b/test_path_traversal.py
new file mode 100644
index 0000000..852ee8b
--- /dev/null
+++ b/test_path_traversal.py
@@ -0,0 +1,91 @@
+#!/usr/bin/env python3
+
+import os
+import sys
+import zipfile
+import subprocess
+import shutil
+
+# Test directories
+EXTRACT_DIR = '/tmp/extract_dir'
+OUTSIDE_DIR = '/tmp/outside_dir'
+MALICIOUS_CONTENT = 'This file was created through path traversal vulnerability'
+
+def create_malicious_zip():
+    """Create a ZIP file with a path traversal payload"""
+    zip_path = '/tmp/malicious.zip'
+    
+    # Create a ZIP file with a path traversal sequence
+    with zipfile.ZipFile(zip_path, 'w') as zip_file:
+        # Add a normal file for reference
+        zip_file.writestr('normal.txt', 'This is a normal file')
+        
+        # Add a file with path traversal
+        # The path will attempt to write outside the extraction directory
+        zip_file.writestr('../../../tmp/outside_dir/traversal.txt', MALICIOUS_CONTENT)
+    
+    return zip_path
+
+def setup():
+    """Set up the test environment"""
+    # Make sure the extraction directory exists and is empty
+    if os.path.exists(EXTRACT_DIR):
+        shutil.rmtree(EXTRACT_DIR)
+    os.makedirs(EXTRACT_DIR, exist_ok=True)
+    
+    # Make sure the outside directory exists and is empty
+    if os.path.exists(OUTSIDE_DIR):
+        shutil.rmtree(OUTSIDE_DIR)
+    os.makedirs(OUTSIDE_DIR, exist_ok=True)
+
+def test_for_vulnerability():
+    """Test if the path traversal vulnerability exists"""
+    print("\n=== Testing for Path Traversal Vulnerability ===\n")
+    
+    # Create the malicious ZIP file
+    zip_path = create_malicious_zip()
+    
+    # Run the test program with the vulnerable version (mode 0)
+    cmd = ["/project/build/test_unzip", zip_path, EXTRACT_DIR, "0"]
+    process = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+    
+    print(f"STDOUT: {process.stdout.decode('utf-8')}")
+    print(f"STDERR: {process.stderr.decode('utf-8')}")
+    
+    # Check if the file was created outside the extraction directory
+    traversal_path = os.path.join(OUTSIDE_DIR, 'traversal.txt')
+    if os.path.exists(traversal_path):
+        with open(traversal_path, 'r') as f:
+            content = f.read()
+        if content == MALICIOUS_CONTENT:
+            print("VULNERABILITY DETECTED: Path traversal successful!")
+            print(f"File created at: {traversal_path}")
+            print(f"Content: {content}")
+            return True
+    
+    print("No path traversal vulnerability detected")
+    return False
+
+def main():
+    # Set up the test environment
+    setup()
+    
+    # Test for the vulnerability
+    vulnerability_exists = test_for_vulnerability()
+    
+    # According to the requirements:
+    # - FAIL (exit with non-zero code) if the vulnerability EXISTS
+    # - PASS (exit with code 0) if the vulnerability DOES NOT EXIST
+    if vulnerability_exists:
+        print("\n=== TEST FAILED ===\n")
+        print("The path traversal vulnerability exists in the code.")
+        print("This is a security issue that needs to be fixed.")
+        sys.exit(1)  # Exit with 1 (FAIL) if vulnerability exists
+    else:
+        print("\n=== TEST PASSED ===\n")
+        print("No path traversal vulnerability detected.")
+        print("The code appears to be secure against this attack.")
+        sys.exit(0)  # Exit with 0 (PASS) if vulnerability does not exist
+
+if __name__ == "__main__":
+    main()
diff --git a/test_unzip.cpp b/test_unzip.cpp
new file mode 100644
index 0000000..3a54e59
--- /dev/null
+++ b/test_unzip.cpp
@@ -0,0 +1,272 @@
+#include <iostream>
+#include <string>
+#include <QCoreApplication>
+#include <QString>
+#include <QDir>
+#include <QFile>
+#include <QFileInfo>
+#include <minizip/unzip.h>
+
+#ifndef MAX_PATH
+#define MAX_PATH 256
+#endif
+
+#define BUFF_SIZE 8192
+
+// Check if a path contains path traversal sequences
+bool containsPathTraversal(const QString &path) {
+    // Check for path traversal sequences
+    if (path.contains("../") || path.contains("..\\") || 
+        path.contains("/..") || path.contains("\\..") ||
+        path == "..") {
+        return true;
+    }
+    
+    // Check for absolute paths
+    if (path.startsWith("/") || path.startsWith("\\") ||
+        (path.length() >= 2 && path.at(1) == ':')) {
+        return true;
+    }
+    
+    return false;
+}
+
+// Fixed version of UnZip that prevents path traversal
+bool UnZipFixed(const QString &zippath, const QString &destpath)
+{
+    int res = 0;
+    QDir dir(destpath);
+    
+    // Open the zip file
+    unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData());
+
+    if ((zfile == NULL) || (!dir.exists())) {
+        std::cerr << "Failed to open zip file or destination directory doesn't exist" << std::endl;
+        return false;
+    }
+
+    res = unzGoToFirstFile(zfile);
+
+    if (res == UNZ_OK) {
+        do {
+            // Get the name of the file in the archive
+            char file_name[MAX_PATH] = {0};
+            unz_file_info64 file_info;
+            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);
+            
+            // Convert to QString
+            QString qfile_name = QString::fromUtf8(file_name);
+            
+            // If there is no file name then we can't do anything with it
+            if (!qfile_name.isEmpty()) {
+                // FIXED: Check for path traversal sequences
+                if (containsPathTraversal(qfile_name)) {
+                    std::cerr << "Security warning: Path traversal attempt detected in: " << qfile_name.toStdString() << std::endl;
+                    unzClose(zfile);
+                    return false;
+                }
+                
+                // Full file path in the destination directory
+                QString file_path = destpath + "/" + qfile_name;
+                QFileInfo qfile_info(file_path);
+                
+                std::cout << "Extracting file: " << qfile_name.toStdString() << std::endl;
+                std::cout << "To path: " << file_path.toStdString() << std::endl;
+
+                // Is this entry a directory?
+                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {
+                    dir.mkpath(qfile_name);
+                    continue;
+                } else {
+                    // Create the directory path for the file
+                    dir.mkpath(qfile_info.path());
+                }
+
+                // Open the file entry in the archive for reading
+                if (unzOpenCurrentFile(zfile) != UNZ_OK) {
+                    std::cerr << "Failed to open file in zip" << std::endl;
+                    unzClose(zfile);
+                    return false;
+                }
+
+                // Open the file on disk to write the entry in the archive to
+                QFile entry(file_path);
+
+                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
+                    std::cerr << "Failed to open output file for writing: " << file_path.toStdString() << std::endl;
+                    unzCloseCurrentFile(zfile);
+                    unzClose(zfile);
+                    return false;
+                }
+
+                // Buffered reading and writing
+                char buff[BUFF_SIZE] = {0};
+                int read = 0;
+
+                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {
+                    entry.write(buff, read);
+                }
+
+                entry.close();
+
+                // Read errors are marked by a negative read amount
+                if (read < 0) {
+                    std::cerr << "Error reading from zip file" << std::endl;
+                    unzCloseCurrentFile(zfile);
+                    unzClose(zfile);
+                    return false;
+                }
+
+                // The file was read but the CRC did not match
+                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {
+                    std::cerr << "CRC error" << std::endl;
+                    unzClose(zfile);
+                    return false;
+                }
+            }
+        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);
+    }
+
+    if (res != UNZ_END_OF_LIST_OF_FILE) {
+        std::cerr << "Error navigating zip file" << std::endl;
+        unzClose(zfile);
+        return false;
+    }
+
+    unzClose(zfile);
+    return true;
+}
+
+// Vulnerable version of UnZip that allows path traversal
+bool UnZipVulnerable(const QString &zippath, const QString &destpath)
+{
+    int res = 0;
+    QDir dir(destpath);
+    
+    // Open the zip file
+    unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData());
+
+    if ((zfile == NULL) || (!dir.exists())) {
+        std::cerr << "Failed to open zip file or destination directory doesn't exist" << std::endl;
+        return false;
+    }
+
+    res = unzGoToFirstFile(zfile);
+
+    if (res == UNZ_OK) {
+        do {
+            // Get the name of the file in the archive
+            char file_name[MAX_PATH] = {0};
+            unz_file_info64 file_info;
+            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);
+            
+            // Convert to QString
+            QString qfile_name = QString::fromUtf8(file_name);
+            
+            // If there is no file name then we can't do anything with it
+            if (!qfile_name.isEmpty()) {
+                // Full file path in the destination directory
+                // VULNERABLE: No path traversal check here
+                QString file_path = destpath + "/" + qfile_name;
+                QFileInfo qfile_info(file_path);
+                
+                std::cout << "Extracting file: " << qfile_name.toStdString() << std::endl;
+                std::cout << "To path: " << file_path.toStdString() << std::endl;
+
+                // Is this entry a directory?
+                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {
+                    dir.mkpath(qfile_name);
+                    continue;
+                } else {
+                    // Create the directory path for the file
+                    dir.mkpath(qfile_info.path());
+                }
+
+                // Open the file entry in the archive for reading
+                if (unzOpenCurrentFile(zfile) != UNZ_OK) {
+                    std::cerr << "Failed to open file in zip" << std::endl;
+                    unzClose(zfile);
+                    return false;
+                }
+
+                // Open the file on disk to write the entry in the archive to
+                QFile entry(file_path);
+
+                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
+                    std::cerr << "Failed to open output file for writing: " << file_path.toStdString() << std::endl;
+                    unzCloseCurrentFile(zfile);
+                    unzClose(zfile);
+                    return false;
+                }
+
+                // Buffered reading and writing
+                char buff[BUFF_SIZE] = {0};
+                int read = 0;
+
+                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {
+                    entry.write(buff, read);
+                }
+
+                entry.close();
+
+                // Read errors are marked by a negative read amount
+                if (read < 0) {
+                    std::cerr << "Error reading from zip file" << std::endl;
+                    unzCloseCurrentFile(zfile);
+                    unzClose(zfile);
+                    return false;
+                }
+
+                // The file was read but the CRC did not match
+                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {
+                    std::cerr << "CRC error" << std::endl;
+                    unzClose(zfile);
+                    return false;
+                }
+            }
+        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);
+    }
+
+    if (res != UNZ_END_OF_LIST_OF_FILE) {
+        std::cerr << "Error navigating zip file" << std::endl;
+        unzClose(zfile);
+        return false;
+    }
+
+    unzClose(zfile);
+    return true;
+}
+
+int main(int argc, char *argv[])
+{
+    QCoreApplication app(argc, argv);
+    
+    if (argc != 4) {
+        std::cerr << "Usage: " << argv[0] << " <zipfile> <extract_dir> <mode>" << std::endl;
+        std::cerr << "  mode: 0 = vulnerable, 1 = fixed" << std::endl;
+        return 1;
+    }
+    
+    QString zippath = QString::fromUtf8(argv[1]);
+    QString destpath = QString::fromUtf8(argv[2]);
+    int mode = atoi(argv[3]);
+    
+    std::cout << "Extracting " << zippath.toStdString() << " to " << destpath.toStdString() << std::endl;
+    
+    bool success = false;
+    if (mode == 0) {
+        // Use vulnerable version
+        success = UnZipVulnerable(zippath, destpath);
+    } else {
+        // Use fixed version
+        success = UnZipFixed(zippath, destpath);
+    }
+    
+    if (success) {
+        std::cout << "Extraction successful" << std::endl;
+        return 0;
+    } else {
+        std::cerr << "Extraction failed" << std::endl;
+        return 1;
+    }
+}
