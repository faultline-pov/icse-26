diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 000000000..93f9dccdb
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,20 @@
+FROM ubuntu:16.04
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build dependencies
+RUN apt-get -y update && \
+    apt-get install -y build-essential && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Compile the test program
+RUN gcc -o test_vulnerability test_vulnerability.c
+
+# Run the vulnerability test
+CMD ["./test_vulnerability"]
diff --git a/main/SAPI.c b/main/SAPI.c
index 714903a86..aa366fb7f 100644
--- a/main/SAPI.c
+++ b/main/SAPI.c
@@ -22,6 +22,7 @@
 
 #include <ctype.h>
 #include <sys/stat.h>
+#include <stdio.h>
 
 #include "php.h"
 #include "SAPI.h"
@@ -666,6 +667,7 @@ static void sapi_header_add_op(sapi_header_op_enum op, sapi_header_struct *sapi_
 
 SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)
 {
+	printf("[INSTRUMENTATION] sapi_header_op");
 	sapi_header_struct sapi_header;
 	char *colon_offset;
 	char *header_line;
diff --git a/run_test.sh b/run_test.sh
new file mode 100644
index 000000000..76234bfe0
--- /dev/null
+++ b/run_test.sh
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+# Run the PHP script that tests for the vulnerability
+php -f test_vulnerability.php
+
+# Exit with the same code as the PHP script
+exit $?
diff --git a/test_vulnerability.c b/test_vulnerability.c
new file mode 100644
index 000000000..936fcbf36
--- /dev/null
+++ b/test_vulnerability.c
@@ -0,0 +1,154 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+/* 
+ * This test demonstrates the CVE-2015-8935 vulnerability in PHP
+ * The vulnerability is in the sapi_header_op function in main/SAPI.c
+ * which allows line folding (newlines followed by spaces) in HTTP headers
+ * This can lead to XSS attacks in Internet Explorer
+ */
+
+/* 
+ * Extracted from main/SAPI.c - This is the vulnerable code path
+ * that allows line folding in headers
+ */
+int test_vulnerable_version(const char *header_line) {
+    int i;
+    int len = strlen(header_line);
+    
+    printf("Testing with vulnerable version:\n");
+    printf("Header: '%s'\n", header_line);
+    
+    /* Simulate the checks in sapi_header_op */
+    
+    /* Check 1: Header must not be empty */
+    if (!header_line || len == 0) {
+        printf("Header rejected: Empty header\n");
+        return 0;
+    }
+    
+    /* Check 2: Header must contain a colon */
+    int colon_offset = 0;
+    for (i = 0; i < len; i++) {
+        if (header_line[i] == ':') {
+            colon_offset = i;
+            break;
+        }
+    }
+    if (!colon_offset) {
+        printf("Header rejected: No colon in header\n");
+        return 0;
+    }
+    
+    /* Check 3: Header must not start with HTTP/ (to avoid HTTP status line) */
+    if (len >= 5 && !strncasecmp(header_line, "HTTP/", 5)) {
+        printf("Header rejected: Starts with HTTP/\n");
+        return 0;
+    }
+    
+    /* Check for line folding vulnerability */
+    for (i = 0; i < len - 1; i++) {
+        /* Check 6: No NUL bytes */
+        if (header_line[i] == '\0') {
+            printf("Header rejected: Contains NUL byte at position %d\n", i);
+            return 0;
+        }
+        
+        /* Check 5: No illegal breaks - THIS IS THE VULNERABLE CHECK */
+        /* RFC 2616 allows new lines if followed by SP or HT */
+        int illegal_break = (header_line[i+1] != ' ' && header_line[i+1] != '\t') && 
+                           (header_line[i] == '\n' || (header_line[i] == '\r' && header_line[i+1] != '\n'));
+        
+        if (illegal_break) {
+            printf("Header rejected: Contains illegal line break at position %d\n", i);
+            return 0;
+        }
+        
+        /* Check for line folding (newline followed by space/tab) */
+        /* This is the vulnerability - it allows headers with newlines followed by spaces */
+        if ((header_line[i] == '\n' || header_line[i] == '\r') && 
+            (header_line[i+1] == ' ' || header_line[i+1] == '\t')) {
+            printf("VULNERABLE: Accepted header with line folding at position %d\n", i);
+            printf("This allows XSS attacks in Internet Explorer!\n");
+            return 1; /* Vulnerable! */
+        }
+    }
+    
+    printf("Header accepted: No line folding detected\n");
+    return 0;
+}
+
+/* 
+ * Patched version - rejects all headers with newlines 
+ * This is how PHP 5.4.38, 5.5.22, and 5.6.6 and later handle headers
+ */
+int test_patched_version(const char *header_line) {
+    int i;
+    int len = strlen(header_line);
+    
+    printf("\nTesting with patched version:\n");
+    printf("Header: '%s'\n", header_line);
+    
+    /* Perform the same initial checks as the vulnerable version */
+    if (!header_line || len == 0) {
+        printf("Header rejected: Empty header\n");
+        return 0;
+    }
+    
+    int colon_offset = 0;
+    for (i = 0; i < len; i++) {
+        if (header_line[i] == ':') {
+            colon_offset = i;
+            break;
+        }
+    }
+    if (!colon_offset) {
+        printf("Header rejected: No colon in header\n");
+        return 0;
+    }
+    
+    if (len >= 5 && !strncasecmp(header_line, "HTTP/", 5)) {
+        printf("Header rejected: Starts with HTTP/\n");
+        return 0;
+    }
+    
+    /* Patched version: Check for ANY newlines in the header and reject them */
+    for (i = 0; i < len; i++) {
+        if (header_line[i] == '\0') {
+            printf("Header rejected: Contains NUL byte at position %d\n", i);
+            return 0;
+        }
+        
+        if (header_line[i] == '\n' || header_line[i] == '\r') {
+            printf("Header rejected: Contains newline at position %d\n", i);
+            return 0;
+        }
+    }
+    
+    printf("Header accepted: No newlines detected\n");
+    return 0;
+}
+
+int main() {
+    /* Test with a header containing line folding (newline + space) */
+    /* This satisfies all the conditions needed to trigger the vulnerability */
+    const char *xss_payload = "X-Test: Value\n <script>alert('XSS')</script>";
+    
+    /* Test the vulnerability with the vulnerable version */
+    int is_vulnerable = test_vulnerable_version(xss_payload);
+    
+    /* Test the vulnerability with the patched version */
+    int is_patched = test_patched_version(xss_payload);
+    
+    /* Exit with status code based on vulnerability status */
+    if (is_vulnerable) {
+        printf("\nRESULT: VULNERABLE - The system accepts headers with line folding!\n");
+        printf("This is the behavior of PHP before 5.4.38, 5.5.x before 5.5.22, and 5.6.x before 5.6.6\n");
+        return 1; /* Exit with error code if vulnerable */
+    } else {
+        printf("\nRESULT: NOT VULNERABLE - The system rejects headers with line folding.\n");
+        printf("This is the behavior of PHP 5.4.38+, 5.5.22+, and 5.6.6+ which have been patched\n");
+        return 0; /* Exit with success code if not vulnerable */
+    }
+}
diff --git a/test_vulnerability.php b/test_vulnerability.php
new file mode 100644
index 000000000..bb3cb1086
--- /dev/null
+++ b/test_vulnerability.php
@@ -0,0 +1,31 @@
+<?php
+// Test for CVE-2015-8935 (Header Line Folding XSS Vulnerability)
+
+// Set a header with line folding (newline + space) which can lead to XSS in IE
+header("X-Test: Value\n <script>alert('XSS')</script>");
+
+// Get all headers that have been set
+$headers = headers_list();
+
+echo "Headers set:\n";
+foreach ($headers as $header) {
+    echo "$header\n";
+}
+
+// Check if our XSS payload made it through (indicating vulnerability)
+$vulnerable = false;
+foreach ($headers as $header) {
+    if (strpos($header, "<script>") !== false) {
+        $vulnerable = true;
+        break;
+    }
+}
+
+// Exit with appropriate status code
+if ($vulnerable) {
+    echo "VULNERABLE: The header with XSS payload was accepted!\n";
+    exit(1); // Exit with error code if vulnerable
+} else {
+    echo "NOT VULNERABLE: The header with XSS payload was rejected.\n";
+    exit(0); // Exit with success code if not vulnerable
+}
