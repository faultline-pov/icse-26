diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 00000000..14f93149
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,22 @@
+FROM ubuntu:16.04
+
+# Install dependencies
+RUN apt-get update && apt-get install -y \
+    build-essential \
+    gcc \
+    git \
+    libglib2.0-dev \
+    libfdt-dev \
+    libpixman-1-dev \
+    zlib1g-dev \
+    patch \
+    python \
+    pkg-config \
+    && rm -rf /var/lib/apt/lists/*
+
+# Copy the QEMU source code
+COPY . /qemu
+WORKDIR /qemu
+
+# Run the vulnerability test
+CMD ["/bin/bash", "test_vulnerability.sh"]
diff --git a/detect_vulnerability.patch b/detect_vulnerability.patch
new file mode 100644
index 00000000..28dc94c4
--- /dev/null
+++ b/detect_vulnerability.patch
@@ -0,0 +1,22 @@
+--- a/target/i386/translate.c
++++ b/target/i386/translate.c
+@@ -4397,6 +4397,7 @@ static target_ulong disas_insn(CPUX86State *env, DisasContext *s,
+     int modrm, reg, rm, mod, op, opreg, val;
+     target_ulong next_eip, tval;
+     int rex_w, rex_r;
++    int prefix_count = 0;
+ 
+     s->pc_start = s->pc = pc_start;
+     prefixes = 0;
+@@ -4413,6 +4414,11 @@ static target_ulong disas_insn(CPUX86State *env, DisasContext *s,
+  next_byte:
+     b = cpu_ldub_code(env, s->pc);
+     s->pc++;
++    prefix_count++;
++    if (prefix_count > 15) {
++        fprintf(stderr, "VULNERABILITY DETECTED: Instruction exceeds maximum x86 instruction size of 15 bytes\n");
++        exit(1); // Exit with error code to indicate vulnerability exists
++    }
+     /* Collect prefixes.  */
+     switch (b) {
+     case 0xf3:
diff --git a/target/i386/translate.c b/target/i386/translate.c
index 72c1b03a..e01ddb7c 100644
--- a/target/i386/translate.c
+++ b/target/i386/translate.c
@@ -31,6 +31,8 @@
 #include "trace-tcg.h"
 #include "exec/log.h"
 
+#include <stdio.h>
+
 
 #define PREFIX_REPZ   0x01
 #define PREFIX_REPNZ  0x02
@@ -4397,6 +4399,7 @@ static void gen_sse(CPUX86State *env, DisasContext *s, int b,
 static target_ulong disas_insn(CPUX86State *env, DisasContext *s,
                                target_ulong pc_start)
 {
+    printf("[INSTRUMENTATION] disas_insn\n");
     int b, prefixes;
     int shift;
     TCGMemOp ot, aflag, dflag;
diff --git a/test_prefix_overflow.c b/test_prefix_overflow.c
new file mode 100644
index 00000000..9310dc25
--- /dev/null
+++ b/test_prefix_overflow.c
@@ -0,0 +1,50 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+// Create a binary with excessive prefix bytes to trigger the vulnerability
+int main() {
+    // Create a simple binary file with excessive prefix bytes
+    int fd = open("test_binary", O_WRONLY | O_CREAT | O_TRUNC, 0755);
+    if (fd < 0) {
+        perror("Failed to open file");
+        return 1;
+    }
+    
+    // Start with a simple machine code that will be executed
+    unsigned char header[] = {
+        0xB8, 0x01, 0x00, 0x00, 0x00,  // mov eax, 1 (syscall number for exit)
+        0xBB, 0x00, 0x00, 0x00, 0x00,  // mov ebx, 0 (exit code 0)
+        0xE9, 0x10, 0x00, 0x00, 0x00   // jmp forward to skip prefix test area
+    };
+    write(fd, header, sizeof(header));
+    
+    // Add padding
+    unsigned char padding[11];
+    memset(padding, 0x90, sizeof(padding)); // NOP padding
+    write(fd, padding, sizeof(padding));
+    
+    // This is our test area with excessive prefix bytes
+    // We'll use 100 REP (0xF3) prefixes to trigger the vulnerability
+    unsigned char prefix_bytes[100];
+    memset(prefix_bytes, 0xF3, sizeof(prefix_bytes)); // REP prefix
+    write(fd, prefix_bytes, sizeof(prefix_bytes));
+    
+    // Add the actual instruction after all the prefixes
+    unsigned char instruction = 0x90; // NOP
+    write(fd, &instruction, 1);
+    
+    // Add code to exit cleanly
+    unsigned char exit_code[] = {
+        0xB8, 0x01, 0x00, 0x00, 0x00,  // mov eax, 1 (syscall number for exit)
+        0xBB, 0x00, 0x00, 0x00, 0x00,  // mov ebx, 0 (exit code 0)
+        0xCD, 0x80                      // int 0x80 (syscall)
+    };
+    write(fd, exit_code, sizeof(exit_code));
+    
+    close(fd);
+    printf("Created test binary with %d prefix bytes\n", (int)sizeof(prefix_bytes));
+    return 0;
+}
diff --git a/test_vulnerability.sh b/test_vulnerability.sh
new file mode 100644
index 00000000..3c32a7bc
--- /dev/null
+++ b/test_vulnerability.sh
@@ -0,0 +1,59 @@
+#!/bin/bash
+set -e
+
+# Compile the test program
+gcc -o test_prefix_overflow test_prefix_overflow.c
+
+# Create the test binary with excessive prefix bytes
+./test_prefix_overflow
+
+# Make the test binary executable
+chmod +x test_binary
+
+# Create a patch to detect the vulnerability
+cat > detect_vulnerability.patch << 'EOF'
+--- a/target/i386/translate.c
++++ b/target/i386/translate.c
+@@ -4397,6 +4397,7 @@ static target_ulong disas_insn(CPUX86State *env, DisasContext *s,
+     int modrm, reg, rm, mod, op, opreg, val;
+     target_ulong next_eip, tval;
+     int rex_w, rex_r;
++    int prefix_count = 0;
+ 
+     s->pc_start = s->pc = pc_start;
+     prefixes = 0;
+@@ -4413,6 +4414,12 @@ static target_ulong disas_insn(CPUX86State *env, DisasContext *s,
+  next_byte:
+     b = cpu_ldub_code(env, s->pc);
+     s->pc++;
++    prefix_count++;
++    
++    if (prefix_count > 15) {
++        fprintf(stderr, "VULNERABILITY DETECTED: Instruction with %d prefix bytes exceeds maximum x86 instruction size of 15 bytes\n", prefix_count);
++        exit(1); // Exit with error code to indicate vulnerability exists
++    }
++    
+     /* Collect prefixes.  */
+     switch (b) {
+     case 0xf3:
+EOF
+
+# Apply the patch to detect the vulnerability
+patch -p1 < detect_vulnerability.patch
+
+# Configure and build QEMU with minimal options
+./configure --target-list=i386-linux-user --disable-werror
+make -j$(nproc)
+
+# Run the test binary with QEMU in TCG mode
+echo "Running test binary with QEMU..."
+./i386-linux-user/qemu-i386 ./test_binary
+RESULT=$?
+
+if [ $RESULT -eq 0 ]; then
+    echo "Test PASSED: No vulnerability detected. QEMU properly limits instruction size."
+    exit 0
+else
+    echo "Test FAILED: Vulnerability detected! QEMU does not limit instruction size."
+    exit 1
+fi
