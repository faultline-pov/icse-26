diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..4d17a6c
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,20 @@
+FROM ubuntu:latest
+
+ENV DEBIAN_FRONTEND=noninteractive
+
+# Update package lists and install build-essential
+RUN apt-get -y update && \
+    apt-get install -y build-essential && \
+    rm -rf /var/lib/apt/lists/*
+
+# Copy the project files into the container
+COPY . /project
+
+# Set the working directory inside the container
+WORKDIR /project
+
+# Make the extraction and test script executable
+RUN chmod +x extract_and_test.sh
+
+# Run the extraction and test script
+CMD ["/project/extract_and_test.sh"]
diff --git a/extract_and_test.sh b/extract_and_test.sh
new file mode 100644
index 0000000..7f540ac
--- /dev/null
+++ b/extract_and_test.sh
@@ -0,0 +1,224 @@
+#!/bin/bash
+
+# This script extracts the vulnerable code from the project and tests it
+
+# Create a directory for the extracted code
+mkdir -p extracted_code
+
+# Extract the vulnerable pattern from svr_mail.c
+echo "Extracting vulnerable code pattern from svr_mail.c"
+grep -A 10 "sprintf(cmdbuf, \"%s -f %s %s\"" src/server/svr_mail.c > extracted_code/vulnerable_pattern.txt
+
+# Create a test file that will be used to verify the vulnerability
+cat > test_vulnerability.c << 'EOF'
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+
+// Define constants and structures needed from the original code
+#define SENDMAIL_CMD "/bin/echo"
+#define TEST_OUTPUT_FILE "/tmp/vulnerability_test_output.txt"
+
+// This function replicates the vulnerable pattern from svr_mail.c
+void test_vulnerable_code(const char *mailto) {
+    char *cmdbuf;
+    char *mailfrom = "root@localhost";
+    
+    // This is the vulnerable code pattern from svr_mail.c
+    int i = strlen(SENDMAIL_CMD) + strlen(mailfrom) + strlen(mailto) + 6;
+    
+    if ((cmdbuf = malloc(i)) == NULL) {
+        fprintf(stderr, "Unable to allocate memory for command buffer\n");
+        exit(1);
+    }
+    
+    // This is the vulnerable line from svr_mail.c
+    sprintf(cmdbuf, "%s -f %s %s", SENDMAIL_CMD, mailfrom, mailto);
+    
+    printf("Executing command: %s\n", cmdbuf);
+    
+    // Execute the command
+    FILE *outmail = popen(cmdbuf, "w");
+    
+    if (outmail == NULL) {
+        fprintf(stderr, "Failed to execute command\n");
+        free(cmdbuf);
+        exit(1);
+    }
+    
+    // Close the pipe
+    pclose(outmail);
+    free(cmdbuf);
+}
+
+// This is a patched version that fixes the vulnerability
+void test_patched_code(const char *mailto) {
+    char *cmdbuf;
+    char *mailfrom = "root@localhost";
+    char *escaped_mailto = NULL;
+    size_t escaped_len = 0;
+    size_t i, j;
+    
+    // Escape shell metacharacters in mailto
+    escaped_len = strlen(mailto) * 2 + 1; // Worst case: every char needs escaping
+    escaped_mailto = malloc(escaped_len);
+    if (escaped_mailto == NULL) {
+        fprintf(stderr, "Failed to allocate memory\n");
+        exit(1);
+    }
+    
+    for (i = 0, j = 0; mailto[i] != '\0'; i++) {
+        if (strchr(";&|`$(){}[]<>*?~#\\'\"", mailto[i]) != NULL) {
+            escaped_mailto[j++] = '\\';
+        }
+        escaped_mailto[j++] = mailto[i];
+    }
+    escaped_mailto[j] = '\0';
+    
+    // Allocate buffer for command
+    int bufsize = strlen(SENDMAIL_CMD) + strlen(mailfrom) + strlen(escaped_mailto) + 6;
+    cmdbuf = malloc(bufsize);
+    
+    if (cmdbuf == NULL) {
+        fprintf(stderr, "Failed to allocate memory\n");
+        free(escaped_mailto);
+        exit(1);
+    }
+    
+    // Construct the command with escaped mailto
+    sprintf(cmdbuf, "%s -f %s %s", SENDMAIL_CMD, mailfrom, escaped_mailto);
+    
+    printf("Executing patched command: %s\n", cmdbuf);
+    
+    // Execute the command
+    FILE *outmail = popen(cmdbuf, "w");
+    
+    if (outmail == NULL) {
+        fprintf(stderr, "Failed to execute command\n");
+        free(cmdbuf);
+        free(escaped_mailto);
+        exit(1);
+    }
+    
+    // Close the pipe
+    pclose(outmail);
+    free(cmdbuf);
+    free(escaped_mailto);
+}
+
+// Function to check if the test file contains evidence of command injection
+int check_for_injection() {
+    FILE *test_file = fopen(TEST_OUTPUT_FILE, "r");
+    if (test_file == NULL) {
+        fprintf(stderr, "Failed to open test file\n");
+        return 0;
+    }
+    
+    char buffer[1024];
+    int vulnerable = 0;
+    
+    while (fgets(buffer, sizeof(buffer), test_file) != NULL) {
+        if (strstr(buffer, "uid=") != NULL) {
+            vulnerable = 1;
+            break;
+        }
+    }
+    
+    fclose(test_file);
+    return vulnerable;
+}
+
+// Function to display the contents of the test file
+void display_test_file() {
+    FILE *test_file = fopen(TEST_OUTPUT_FILE, "r");
+    if (test_file == NULL) {
+        fprintf(stderr, "Failed to open test file\n");
+        return;
+    }
+    
+    char buffer[1024];
+    printf("Test file contents:\n");
+    
+    while (fgets(buffer, sizeof(buffer), test_file) != NULL) {
+        printf("%s", buffer);
+    }
+    
+    fclose(test_file);
+}
+
+int main(int argc, char *argv[]) {
+    // Create a test file to verify command execution
+    FILE *test_file = fopen(TEST_OUTPUT_FILE, "w");
+    if (test_file == NULL) {
+        fprintf(stderr, "Failed to create test file\n");
+        return 1;
+    }
+    fprintf(test_file, "Testing for vulnerability...\n");
+    fclose(test_file);
+    
+    printf("Testing for command injection vulnerability in TORQUE Resource Manager\n");
+    printf("CVE-2013-4495: Command injection via email address in svr_mail.c\n\n");
+    
+    // Display the extracted vulnerable pattern
+    printf("Extracted vulnerable pattern from svr_mail.c:\n");
+    FILE *pattern_file = fopen("extracted_code/vulnerable_pattern.txt", "r");
+    if (pattern_file != NULL) {
+        char buffer[1024];
+        while (fgets(buffer, sizeof(buffer), pattern_file) != NULL) {
+            printf("%s", buffer);
+        }
+        fclose(pattern_file);
+    }
+    printf("\n");
+    
+    // Test with a malicious email address containing command injection
+    printf("Test with vulnerable code:\n");
+    test_vulnerable_code("user@example.com; id >> " TEST_OUTPUT_FILE " #");
+    
+    // Check if the vulnerability was exploited
+    int vulnerable = check_for_injection();
+    
+    if (vulnerable) {
+        printf("\nVULNERABILITY DETECTED: Command injection was successful\n");
+        display_test_file();
+        
+        // Now test with the patched code
+        printf("\nTest with patched code:\n");
+        
+        // Reset the test file
+        test_file = fopen(TEST_OUTPUT_FILE, "w");
+        fprintf(test_file, "Testing for vulnerability with patched code...\n");
+        fclose(test_file);
+        
+        // Run the patched version with the same malicious input
+        test_patched_code("user@example.com; id >> " TEST_OUTPUT_FILE " #");
+        
+        // Check if the vulnerability was exploited in the patched version
+        int patched_vulnerable = check_for_injection();
+        
+        if (patched_vulnerable) {
+            printf("\nPatch failed: Command injection still possible\n");
+            display_test_file();
+        } else {
+            printf("\nPatch successful: Command injection prevented\n");
+        }
+        
+        return 1;  // Test fails if vulnerability exists
+    } else {
+        printf("\nNo vulnerability detected\n");
+        return 0;  // Test passes if vulnerability does not exist
+    }
+}
+EOF
+
+# Compile the test program
+gcc -o test_vulnerability test_vulnerability.c
+
+# Run the test
+./test_vulnerability
+
+# Return the exit code from the test
+exit $?
diff --git a/extract_vulnerable_code.sh b/extract_vulnerable_code.sh
new file mode 100644
index 0000000..6b231fe
--- /dev/null
+++ b/extract_vulnerable_code.sh
@@ -0,0 +1,217 @@
+#!/bin/bash
+
+# Extract the vulnerable code from svr_mail.c
+echo "Extracting vulnerable code from svr_mail.c"
+
+# Create a directory for the extracted code
+mkdir -p extracted_code
+
+# Extract the relevant parts of the code
+cat > extracted_code/vulnerable_code.c << 'EOF'
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+// Define constants needed from the original code
+#define SENDMAIL_CMD "/bin/echo"
+#define TEST_OUTPUT_FILE "/tmp/vulnerability_test_output.txt"
+
+// This function simulates the vulnerable part of svr_mail.c
+void test_vulnerable_code(const char *mailto) {
+    char *cmdbuf;
+    char *mailfrom = "root@localhost";
+    
+    // This is the vulnerable code from svr_mail.c
+    int i = strlen(SENDMAIL_CMD) + strlen(mailfrom) + strlen(mailto) + 6;
+    
+    if ((cmdbuf = malloc(i)) == NULL) {
+        fprintf(stderr, "Unable to allocate memory for command buffer\n");
+        exit(1);
+    }
+    
+    // This is the vulnerable line from svr_mail.c
+    sprintf(cmdbuf, "%s -f %s %s", SENDMAIL_CMD, mailfrom, mailto);
+    
+    printf("Executing command: %s\n", cmdbuf);
+    
+    // Execute the command
+    FILE *outmail = popen(cmdbuf, "w");
+    
+    if (outmail == NULL) {
+        fprintf(stderr, "Failed to execute command\n");
+        free(cmdbuf);
+        exit(1);
+    }
+    
+    // Close the pipe
+    pclose(outmail);
+    free(cmdbuf);
+}
+
+// This is a patched version that fixes the vulnerability
+void test_patched_code(const char *mailto) {
+    char *cmdbuf;
+    char *mailfrom = "root@localhost";
+    char *escaped_mailto = NULL;
+    size_t escaped_len = 0;
+    size_t i, j;
+    
+    // Escape shell metacharacters in mailto
+    escaped_len = strlen(mailto) * 2 + 1; // Worst case: every char needs escaping
+    escaped_mailto = malloc(escaped_len);
+    if (escaped_mailto == NULL) {
+        fprintf(stderr, "Failed to allocate memory\n");
+        exit(1);
+    }
+    
+    for (i = 0, j = 0; mailto[i] != '\0'; i++) {
+        if (strchr(";&|`$(){}[]<>*?~#\\'\"", mailto[i]) != NULL) {
+            escaped_mailto[j++] = '\\';
+        }
+        escaped_mailto[j++] = mailto[i];
+    }
+    escaped_mailto[j] = '\0';
+    
+    // Allocate buffer for command
+    int bufsize = strlen(SENDMAIL_CMD) + strlen(mailfrom) + strlen(escaped_mailto) + 6;
+    cmdbuf = malloc(bufsize);
+    
+    if (cmdbuf == NULL) {
+        fprintf(stderr, "Failed to allocate memory\n");
+        free(escaped_mailto);
+        exit(1);
+    }
+    
+    // Construct the command with escaped mailto
+    sprintf(cmdbuf, "%s -f %s %s", SENDMAIL_CMD, mailfrom, escaped_mailto);
+    
+    printf("Executing patched command: %s\n", cmdbuf);
+    
+    // Execute the command
+    FILE *outmail = popen(cmdbuf, "w");
+    
+    if (outmail == NULL) {
+        fprintf(stderr, "Failed to execute command\n");
+        free(cmdbuf);
+        free(escaped_mailto);
+        exit(1);
+    }
+    
+    // Close the pipe
+    pclose(outmail);
+    free(cmdbuf);
+    free(escaped_mailto);
+}
+
+// Function to check if the test file contains evidence of command injection
+int check_for_injection() {
+    FILE *test_file = fopen(TEST_OUTPUT_FILE, "r");
+    if (test_file == NULL) {
+        fprintf(stderr, "Failed to open test file\n");
+        return 0;
+    }
+    
+    char buffer[1024];
+    int vulnerable = 0;
+    
+    while (fgets(buffer, sizeof(buffer), test_file) != NULL) {
+        if (strstr(buffer, "uid=") != NULL) {
+            vulnerable = 1;
+            break;
+        }
+    }
+    
+    fclose(test_file);
+    return vulnerable;
+}
+
+// Function to display the contents of the test file
+void display_test_file() {
+    FILE *test_file = fopen(TEST_OUTPUT_FILE, "r");
+    if (test_file == NULL) {
+        fprintf(stderr, "Failed to open test file\n");
+        return;
+    }
+    
+    char buffer[1024];
+    printf("Test file contents:\n");
+    
+    while (fgets(buffer, sizeof(buffer), test_file) != NULL) {
+        printf("%s", buffer);
+    }
+    
+    fclose(test_file);
+}
+
+int main(int argc, char *argv[]) {
+    // Create a test file to verify command execution
+    FILE *test_file = fopen(TEST_OUTPUT_FILE, "w");
+    if (test_file == NULL) {
+        fprintf(stderr, "Failed to create test file\n");
+        return 1;
+    }
+    fprintf(test_file, "Testing for vulnerability...\n");
+    fclose(test_file);
+    
+    printf("Testing for command injection vulnerability in TORQUE Resource Manager\n");
+    printf("CVE-2013-4495: Command injection via email address in svr_mail.c\n\n");
+    
+    // Test with a malicious email address containing command injection
+    printf("Test with vulnerable code:\n");
+    test_vulnerable_code("user@example.com; id >> " TEST_OUTPUT_FILE " #");
+    
+    // Check if the vulnerability was exploited
+    int vulnerable = check_for_injection();
+    
+    if (vulnerable) {
+        printf("\nVULNERABILITY DETECTED: Command injection was successful\n");
+        display_test_file();
+        
+        // Now test with the patched code
+        printf("\nTest with patched code:\n");
+        
+        // Reset the test file
+        test_file = fopen(TEST_OUTPUT_FILE, "w");
+        fprintf(test_file, "Testing for vulnerability with patched code...\n");
+        fclose(test_file);
+        
+        // Run the patched version with the same malicious input
+        test_patched_code("user@example.com; id >> " TEST_OUTPUT_FILE " #");
+        
+        // Check if the vulnerability was exploited in the patched version
+        int patched_vulnerable = check_for_injection();
+        
+        if (patched_vulnerable) {
+            printf("\nPatch failed: Command injection still possible\n");
+            display_test_file();
+        } else {
+            printf("\nPatch successful: Command injection prevented\n");
+        }
+        
+        return 1;  // Test fails if vulnerability exists
+    } else {
+        printf("\nNo vulnerability detected\n");
+        return 0;  // Test passes if vulnerability does not exist
+    }
+}
+EOF
+
+# Create a test script that will be used to verify the vulnerability
+cat > extracted_code/test_vulnerability.sh << 'EOF'
+#!/bin/bash
+
+# Compile the extracted code
+gcc -o test_vulnerability extracted_code/vulnerable_code.c
+
+# Run the test
+./test_vulnerability
+
+# Return the exit code from the test
+exit $?
+EOF
+
+# Make the test script executable
+chmod +x extracted_code/test_vulnerability.sh
+
+echo "Extraction complete. Run extracted_code/test_vulnerability.sh to test the vulnerability."
diff --git a/test_vulnerability.c b/test_vulnerability.c
new file mode 100644
index 0000000..c9582da
--- /dev/null
+++ b/test_vulnerability.c
@@ -0,0 +1,189 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+
+// Define constants and structures needed from the original code
+#define SENDMAIL_CMD "/bin/echo"
+#define TEST_OUTPUT_FILE "/tmp/vulnerability_test_output.txt"
+
+// This function replicates the vulnerable pattern from svr_mail.c
+void test_vulnerable_code(const char *mailto) {
+    char *cmdbuf;
+    char *mailfrom = "root@localhost";
+    
+    // This is the vulnerable code pattern from svr_mail.c
+    int i = strlen(SENDMAIL_CMD) + strlen(mailfrom) + strlen(mailto) + 6;
+    
+    if ((cmdbuf = malloc(i)) == NULL) {
+        fprintf(stderr, "Unable to allocate memory for command buffer\n");
+        exit(1);
+    }
+    
+    // This is the vulnerable line from svr_mail.c
+    sprintf(cmdbuf, "%s -f %s %s", SENDMAIL_CMD, mailfrom, mailto);
+    
+    printf("Executing command: %s\n", cmdbuf);
+    
+    // Execute the command
+    FILE *outmail = popen(cmdbuf, "w");
+    
+    if (outmail == NULL) {
+        fprintf(stderr, "Failed to execute command\n");
+        free(cmdbuf);
+        exit(1);
+    }
+    
+    // Close the pipe
+    pclose(outmail);
+    free(cmdbuf);
+}
+
+// This is a patched version that fixes the vulnerability
+void test_patched_code(const char *mailto) {
+    char *cmdbuf;
+    char *mailfrom = "root@localhost";
+    char *escaped_mailto = NULL;
+    size_t escaped_len = 0;
+    size_t i, j;
+    
+    // Escape shell metacharacters in mailto
+    escaped_len = strlen(mailto) * 2 + 1; // Worst case: every char needs escaping
+    escaped_mailto = malloc(escaped_len);
+    if (escaped_mailto == NULL) {
+        fprintf(stderr, "Failed to allocate memory\n");
+        exit(1);
+    }
+    
+    for (i = 0, j = 0; mailto[i] != '\0'; i++) {
+        if (strchr(";&|`$(){}[]<>*?~#\\'\"", mailto[i]) != NULL) {
+            escaped_mailto[j++] = '\\';
+        }
+        escaped_mailto[j++] = mailto[i];
+    }
+    escaped_mailto[j] = '\0';
+    
+    // Allocate buffer for command
+    int bufsize = strlen(SENDMAIL_CMD) + strlen(mailfrom) + strlen(escaped_mailto) + 6;
+    cmdbuf = malloc(bufsize);
+    
+    if (cmdbuf == NULL) {
+        fprintf(stderr, "Failed to allocate memory\n");
+        free(escaped_mailto);
+        exit(1);
+    }
+    
+    // Construct the command with escaped mailto
+    sprintf(cmdbuf, "%s -f %s %s", SENDMAIL_CMD, mailfrom, escaped_mailto);
+    
+    printf("Executing patched command: %s\n", cmdbuf);
+    
+    // Execute the command
+    FILE *outmail = popen(cmdbuf, "w");
+    
+    if (outmail == NULL) {
+        fprintf(stderr, "Failed to execute command\n");
+        free(cmdbuf);
+        free(escaped_mailto);
+        exit(1);
+    }
+    
+    // Close the pipe
+    pclose(outmail);
+    free(cmdbuf);
+    free(escaped_mailto);
+}
+
+// Function to check if the test file contains evidence of command injection
+int check_for_injection() {
+    FILE *test_file = fopen(TEST_OUTPUT_FILE, "r");
+    if (test_file == NULL) {
+        fprintf(stderr, "Failed to open test file\n");
+        return 0;
+    }
+    
+    char buffer[1024];
+    int vulnerable = 0;
+    
+    while (fgets(buffer, sizeof(buffer), test_file) != NULL) {
+        if (strstr(buffer, "uid=") != NULL) {
+            vulnerable = 1;
+            break;
+        }
+    }
+    
+    fclose(test_file);
+    return vulnerable;
+}
+
+// Function to display the contents of the test file
+void display_test_file() {
+    FILE *test_file = fopen(TEST_OUTPUT_FILE, "r");
+    if (test_file == NULL) {
+        fprintf(stderr, "Failed to open test file\n");
+        return;
+    }
+    
+    char buffer[1024];
+    printf("Test file contents:\n");
+    
+    while (fgets(buffer, sizeof(buffer), test_file) != NULL) {
+        printf("%s", buffer);
+    }
+    
+    fclose(test_file);
+}
+
+int main(int argc, char *argv[]) {
+    // Create a test file to verify command execution
+    FILE *test_file = fopen(TEST_OUTPUT_FILE, "w");
+    if (test_file == NULL) {
+        fprintf(stderr, "Failed to create test file\n");
+        return 1;
+    }
+    fprintf(test_file, "Testing for vulnerability...\n");
+    fclose(test_file);
+    
+    printf("Testing for command injection vulnerability in TORQUE Resource Manager\n");
+    printf("CVE-2013-4495: Command injection via email address in svr_mail.c\n\n");
+    
+    // Test with a malicious email address containing command injection
+    printf("Test with vulnerable code:\n");
+    test_vulnerable_code("user@example.com; id >> " TEST_OUTPUT_FILE " #");
+    
+    // Check if the vulnerability was exploited
+    int vulnerable = check_for_injection();
+    
+    if (vulnerable) {
+        printf("\nVULNERABILITY DETECTED: Command injection was successful\n");
+        display_test_file();
+        
+        // Now test with the patched code
+        printf("\nTest with patched code:\n");
+        
+        // Reset the test file
+        test_file = fopen(TEST_OUTPUT_FILE, "w");
+        fprintf(test_file, "Testing for vulnerability with patched code...\n");
+        fclose(test_file);
+        
+        // Run the patched version with the same malicious input
+        test_patched_code("user@example.com; id >> " TEST_OUTPUT_FILE " #");
+        
+        // Check if the vulnerability was exploited in the patched version
+        int patched_vulnerable = check_for_injection();
+        
+        if (patched_vulnerable) {
+            printf("\nPatch failed: Command injection still possible\n");
+            display_test_file();
+        } else {
+            printf("\nPatch successful: Command injection prevented\n");
+        }
+        
+        return 1;  // Test fails if vulnerability exists
+    } else {
+        printf("\nNo vulnerability detected\n");
+        return 0;  // Test passes if vulnerability does not exist
+    }
+}
diff --git a/test_vulnerability.sh b/test_vulnerability.sh
new file mode 100644
index 0000000..4042d70
--- /dev/null
+++ b/test_vulnerability.sh
@@ -0,0 +1,31 @@
+#!/bin/bash
+
+# Test for CVE-2013-4495 in TORQUE Resource Manager
+# This test checks for command injection vulnerability in the -M option
+
+# Create a temporary file to capture command execution evidence
+TEST_FILE="/tmp/vulnerability_test_output.txt"
+echo "Testing for vulnerability..." > $TEST_FILE
+
+# Submit a job with a malicious email address containing shell metacharacters
+# The payload will attempt to append text to our test file if the vulnerability exists
+echo "#!/bin/bash\necho 'This is a test job'\nsleep 5" > /tmp/test_job.sh
+chmod +x /tmp/test_job.sh
+
+# The malicious email contains shell metacharacters that will execute 'id' command
+# and append the output to our test file if the vulnerability exists
+qsub -M "user@example.com; id >> $TEST_FILE; echo 'Command injection successful!' >> $TEST_FILE #" /tmp/test_job.sh
+
+# Wait for the job to be processed and email to be sent
+sleep 10
+
+# Check if the vulnerability was exploited
+if grep -q "Command injection successful" $TEST_FILE || grep -q "uid=" $TEST_FILE; then
+    echo "VULNERABILITY DETECTED: Command injection was successful"
+    cat $TEST_FILE
+    exit 1  # Test fails if vulnerability exists
+else
+    echo "No vulnerability detected"
+    cat $TEST_FILE
+    exit 0  # Test passes if vulnerability does not exist
+fi
