diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 00000000..a4023f2d
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/square__retrofit_CVE-2018-1000850_2.4.0 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 00000000..8b137891
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 00000000..b74bb223
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,11 @@
+FROM openjdk:8-jdk
+
+WORKDIR /project
+
+# Copy the project files
+COPY . /project/
+
+# Do not modify anything above this line
+
+# Compile and run the vulnerability test
+CMD ["sh", "-c", "javac PathTraversalTest.java && java PathTraversalTest"]
diff --git a/PathTraversalTest.java b/PathTraversalTest.java
new file mode 100644
index 00000000..d735243d
--- /dev/null
+++ b/PathTraversalTest.java
@@ -0,0 +1,119 @@
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+
+public class PathTraversalTest {
+    public static void main(String[] args) {
+        try {
+            // Create a test file in the project directory
+            File projectFile = new File("test-file.txt");
+            writeToFile(projectFile, "This is a test file in the project directory");
+            
+            // Create a test file outside the project directory
+            File outsideFile = new File("/tmp/outside-file.txt");
+            writeToFile(outsideFile, "This is a test file outside the project directory");
+            
+            // Test the vulnerability by creating a RequestBuilder and adding a path parameter
+            // with a directory traversal sequence
+            boolean vulnerabilityExists = testPathTraversal();
+            
+            if (vulnerabilityExists) {
+                System.out.println("VULNERABILITY DETECTED: Path traversal sequence was not properly sanitized");
+                System.exit(1); // Exit with error if vulnerability exists
+            } else {
+                System.out.println("NO VULNERABILITY: Path traversal sequence was properly sanitized");
+                System.exit(0); // Exit with success if no vulnerability
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+    
+    private static void writeToFile(File file, String content) throws IOException {
+        FileWriter writer = new FileWriter(file);
+        writer.write(content);
+        writer.close();
+        System.out.println("Created file: " + file.getAbsolutePath());
+    }
+    
+    private static boolean testPathTraversal() {
+        try {
+            // Extract the vulnerable code from RequestBuilder.java and test it directly
+            String relativeUrl = "/files/{filename}";
+            String name = "filename";
+            String value = "..%2F..%2F..%2Ftmp%2Foutside-file.txt";
+            boolean encoded = true;
+            
+            // This is the vulnerable code from RequestBuilder.addPathParam
+            String replacedValue = canonicalizeForPath(value, encoded);
+            String newRelativeUrl = relativeUrl.replace("{" + name + "}", replacedValue);
+            
+            System.out.println("Original relative URL: " + relativeUrl);
+            System.out.println("Path parameter value: " + value);
+            System.out.println("Canonicalized value: " + replacedValue);
+            System.out.println("New relative URL: " + newRelativeUrl);
+            
+            // Check if the path traversal sequence was preserved
+            // If the vulnerability exists, the path will contain the traversal sequence
+            return newRelativeUrl.contains("..%2F") || newRelativeUrl.contains("../");
+        } catch (Exception e) {
+            e.printStackTrace();
+            return false;
+        }
+    }
+    
+    // This is the vulnerable code from RequestBuilder.java
+    private static String canonicalizeForPath(String input, boolean alreadyEncoded) {
+        // Define the characters that always need encoding
+        String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
+        
+        int codePoint;
+        for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (codePoint < 0x20 || codePoint >= 0x7f
+                || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+                || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+                // Slow path: the character at i requires encoding!
+                StringBuilder out = new StringBuilder();
+                out.append(input, 0, i);
+                canonicalizeForPath(out, input, i, limit, alreadyEncoded);
+                return out.toString();
+            }
+        }
+
+        // Fast path: no characters required encoding.
+        return input;
+    }
+
+    private static void canonicalizeForPath(StringBuilder out, String input, int pos, int limit,
+        boolean alreadyEncoded) {
+        // Define the characters that always need encoding
+        String PATH_SEGMENT_ALWAYS_ENCODE_SET = " \"<>^`{}|\\?#";
+        
+        int codePoint;
+        for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
+            codePoint = input.codePointAt(i);
+            if (alreadyEncoded
+                && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
+                // Skip this character.
+            } else if (codePoint < 0x20 || codePoint >= 0x7f
+                || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1
+                || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {
+                // Percent encode this character.
+                byte[] bytes = Character.toString((char)codePoint).getBytes();
+                for (byte b : bytes) {
+                    out.append('%');
+                    out.append(HEX_DIGITS[(b >> 4) & 0xf]);
+                    out.append(HEX_DIGITS[b & 0xf]);
+                }
+            } else {
+                // This character doesn't need encoding. Just copy it over.
+                out.append(Character.toChars(codePoint));
+            }
+        }
+    }
+    
+    private static final char[] HEX_DIGITS =
+        { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+}
