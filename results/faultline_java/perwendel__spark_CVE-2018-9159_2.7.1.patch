diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 0000000..56fe230
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/perwendel__spark_CVE-2018-9159_2.7.1 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..c15d5fa
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,22 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/perwendel__spark_CVE-2018-9159_2.7.1 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Create a script to run the test with all dependencies
+RUN echo '#!/bin/bash\njava -cp "target/spark-core-2.7.1.jar:target/classes:$(mvn dependency:build-classpath -q -Dmdep.outputFile=/dev/stdout)" spark.PathTraversalVulnerabilityTest' > /project/run_test.sh && chmod +x /project/run_test.sh
+
+CMD ["/project/run_test.sh"]
\ No newline at end of file
diff --git a/src/main/java/spark/PathTraversalVulnerabilityTest.java b/src/main/java/spark/PathTraversalVulnerabilityTest.java
new file mode 100644
index 0000000..4132fc6
--- /dev/null
+++ b/src/main/java/spark/PathTraversalVulnerabilityTest.java
@@ -0,0 +1,202 @@
+package spark;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+
+public class PathTraversalVulnerabilityTest {
+
+    private static final int PORT = 4567;
+    private static final String TEST_FILE_CONTENT = "This is a test file for path traversal vulnerability test";
+    private static final String SECRET_FILE_CONTENT = "This is a secret file that should not be accessible";
+    private static File secretFile;
+
+    public static void main(String[] args) {
+        try {
+            // Create a "secret" file outside the static directory
+            secretFile = File.createTempFile("secret", ".txt");
+            secretFile.deleteOnExit();
+            try (FileWriter writer = new FileWriter(secretFile)) {
+                writer.write(SECRET_FILE_CONTENT);
+            }
+            System.out.println("Secret file created at: " + secretFile.getAbsolutePath());
+            
+            // Create a directory for static files
+            File staticDir = new File("public");
+            staticDir.mkdir();
+            
+            // Create a test file in the static directory
+            File testFile = new File(staticDir, "test.txt");
+            try (FileWriter writer = new FileWriter(testFile)) {
+                writer.write(TEST_FILE_CONTENT);
+            }
+            System.out.println("Test file created at: " + testFile.getAbsolutePath());
+            
+            // Copy the test file to the classpath
+            File classesDir = new File("target/classes/public");
+            classesDir.mkdirs();
+            Files.copy(testFile.toPath(), new File(classesDir, "test.txt").toPath(), 
+                      java.nio.file.StandardCopyOption.REPLACE_EXISTING);
+            
+            // Create a symbolic link to the secret file in the classpath
+            // This simulates having a file that can be accessed via path traversal
+            File secretLinkTarget = new File("target/classes/secret_link.txt");
+            try {
+                Files.createSymbolicLink(secretLinkTarget.toPath(), secretFile.toPath());
+                System.out.println("Created symbolic link to secret file at: " + secretLinkTarget.getAbsolutePath());
+            } catch (IOException | UnsupportedOperationException e) {
+                System.out.println("Could not create symbolic link, copying file instead: " + e.getMessage());
+                Files.copy(secretFile.toPath(), secretLinkTarget.toPath(), 
+                          java.nio.file.StandardCopyOption.REPLACE_EXISTING);
+            }
+            
+            // Start Spark with static file serving
+            Spark.port(PORT);
+            Spark.staticFiles.location("/public"); // Serve from classpath /public
+            
+            // Add a route to verify the server is running
+            Spark.get("/hello", (req, res) -> "Hello World");
+            
+            Spark.init();
+            Spark.awaitInitialization();
+            
+            System.out.println("Spark server started on port " + PORT);
+            
+            try {
+                // First verify the server is running
+                String helloResponse = makeRequest("/hello");
+                System.out.println("Server response to /hello: " + helloResponse);
+                
+                // Try to access the test file in classpath
+                try {
+                    String normalContent = makeRequest("/test.txt");
+                    System.out.println("Successfully accessed normal file: " + normalContent);
+                } catch (IOException e) {
+                    System.out.println("Failed to access test file: " + e.getMessage());
+                    System.exit(1); // Exit with error if we can't access the test file
+                }
+                
+                // Now try to access the secret file using path traversal
+                boolean vulnerabilityFound = false;
+                String successfulPath = null;
+                String retrievedContent = null;
+                
+                // Create a list to store all attempted paths
+                List<String> pathTraversalAttempts = new ArrayList<>();
+                
+                // Try with standard directory traversal
+                pathTraversalAttempts.add("/../../secret_link.txt");
+                pathTraversalAttempts.add("/../secret_link.txt");
+                pathTraversalAttempts.add("/..%2f..%2fsecret_link.txt");
+                pathTraversalAttempts.add("/..%2fsecret_link.txt");
+                
+                // Try with directory traversal that starts with the configured folder
+                pathTraversalAttempts.add("/public/../../secret_link.txt");
+                pathTraversalAttempts.add("/public/../secret_link.txt");
+                pathTraversalAttempts.add("/public/..%2f..%2fsecret_link.txt");
+                pathTraversalAttempts.add("/public/..%2fsecret_link.txt");
+                
+                // Try with URL encoded versions
+                pathTraversalAttempts.add("/..%252f..%252fsecret_link.txt");
+                pathTraversalAttempts.add("/..%252fsecret_link.txt");
+                pathTraversalAttempts.add("/public/..%252f..%252fsecret_link.txt");
+                pathTraversalAttempts.add("/public/..%252fsecret_link.txt");
+                
+                // Try with absolute path
+                pathTraversalAttempts.add("/" + secretLinkTarget.getAbsolutePath());
+                pathTraversalAttempts.add("/public/" + secretLinkTarget.getAbsolutePath());
+                
+                // Try with file: URL scheme
+                pathTraversalAttempts.add("/file:" + secretLinkTarget.getAbsolutePath());
+                pathTraversalAttempts.add("/file:///" + secretLinkTarget.getAbsolutePath().substring(1));
+                
+                // Try with URL encoded file: scheme
+                pathTraversalAttempts.add("/file%3A" + secretLinkTarget.getAbsolutePath());
+                pathTraversalAttempts.add("/file%3A///" + secretLinkTarget.getAbsolutePath().substring(1));
+                
+                // Try with a path that starts with the configured folder but contains file: URL
+                pathTraversalAttempts.add("/public/file:" + secretLinkTarget.getAbsolutePath());
+                pathTraversalAttempts.add("/public/file:///" + secretLinkTarget.getAbsolutePath().substring(1));
+                
+                // Try with a path that starts with the configured folder but contains encoded file: URL
+                pathTraversalAttempts.add("/public/file%3A" + secretLinkTarget.getAbsolutePath());
+                pathTraversalAttempts.add("/public/file%3A///" + secretLinkTarget.getAbsolutePath().substring(1));
+                
+                // Try with a path that has the file: URL after some traversal
+                pathTraversalAttempts.add("/public/../file:" + secretLinkTarget.getAbsolutePath());
+                pathTraversalAttempts.add("/public/../file:///" + secretLinkTarget.getAbsolutePath().substring(1));
+                
+                // Try with a path that has the file: URL after some encoded traversal
+                pathTraversalAttempts.add("/public/..%2ffile:" + secretLinkTarget.getAbsolutePath());
+                pathTraversalAttempts.add("/public/..%2ffile:///" + secretLinkTarget.getAbsolutePath().substring(1));
+                
+                // Try with direct access to the secret_link.txt file
+                pathTraversalAttempts.add("/secret_link.txt");
+                
+                for (String path : pathTraversalAttempts) {
+                    try {
+                        System.out.println("\nTrying path: " + path);
+                        String content = makeRequest(path);
+                        System.out.println("Response: " + content);
+                        if (content != null && content.contains(SECRET_FILE_CONTENT)) {
+                            vulnerabilityFound = true;
+                            successfulPath = path;
+                            retrievedContent = content;
+                            break;
+                        }
+                    } catch (IOException e) {
+                        // This is expected for some paths if the vulnerability is fixed
+                        System.out.println("Request failed: " + e.getMessage());
+                    }
+                }
+                
+                if (vulnerabilityFound) {
+                    System.out.println("\nVulnerability found! Successfully accessed file outside static directory.");
+                    System.out.println("Path used: " + successfulPath);
+                    System.out.println("Content retrieved: " + retrievedContent);
+                    System.exit(1); // Exit with error if vulnerability found
+                } else {
+                    System.out.println("\nNo path traversal vulnerability found - could not access file outside static directory");
+                    System.exit(0); // Exit with success if no vulnerability found
+                }
+            } finally {
+                Spark.stop();
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+    
+    private static String makeRequest(String path) throws IOException {
+        URL url = new URL("http://localhost:" + PORT + path);
+        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+        connection.setRequestMethod("GET");
+        
+        int responseCode = connection.getResponseCode();
+        if (responseCode >= 200 && responseCode < 300) {
+            try (InputStream in = connection.getInputStream()) {
+                return readInputStream(in);
+            }
+        } else {
+            throw new IOException("HTTP request failed with status code: " + responseCode);
+        }
+    }
+    
+    private static String readInputStream(InputStream inputStream) throws IOException {
+        StringBuilder sb = new StringBuilder();
+        byte[] buffer = new byte[1024];
+        int bytesRead;
+        while ((bytesRead = inputStream.read(buffer)) != -1) {
+            sb.append(new String(buffer, 0, bytesRead));
+        }
+        return sb.toString();
+    }
+}
diff --git a/src/main/java/spark/resource/ClassPathResourceHandler.java b/src/main/java/spark/resource/ClassPathResourceHandler.java
index c9f6251..8624cb7 100644
--- a/src/main/java/spark/resource/ClassPathResourceHandler.java
+++ b/src/main/java/spark/resource/ClassPathResourceHandler.java
@@ -59,41 +59,55 @@ public class ClassPathResourceHandler extends AbstractResourceHandler {
 
     @Override
     protected AbstractFileResolvingResource getResource(String path) throws MalformedURLException {
+        System.out.println("ClassPathResourceHandler.getResource called with path: " + path);
         if (path == null || !path.startsWith("/")) {
+            System.out.println("ClassPathResourceHandler.getResource path is null or doesn't start with /, throwing MalformedURLException");
             throw new MalformedURLException(path);
         }
 
         try {
-            path = UriPath.canonical(path);
+            String pathNoSlash = path.substring(1);
+            System.out.println("ClassPathResourceHandler.getResource pathNoSlash: " + pathNoSlash);
+            
+            pathNoSlash = UriPath.canonical(pathNoSlash);
+            System.out.println("ClassPathResourceHandler.getResource after canonical: " + pathNoSlash);
+
+            if (pathNoSlash == null) {
+                System.out.println("ClassPathResourceHandler.getResource canonical path is null, returning null");
+                return null;
+            }
 
-            final String addedPath = addPaths(baseResource, path);
+            final String addedPath = UriPath.addPaths(baseResource, pathNoSlash);
+            System.out.println("ClassPathResourceHandler.getResource addedPath: " + addedPath);
 
             ClassPathResource resource = new ClassPathResource(addedPath);
+            System.out.println("ClassPathResourceHandler.getResource created resource: " + resource);
 
             if (resource.exists() && path.endsWith("/")) {
+                System.out.println("ClassPathResourceHandler.getResource path ends with / and resource exists");
                 if (welcomeFile != null) {
-                    resource = new ClassPathResource(addPaths(resource.getPath(), welcomeFile));
+                    resource = new ClassPathResource(UriPath.addPaths(resource.getPath(), welcomeFile));
+                    System.out.println("ClassPathResourceHandler.getResource using welcome file: " + resource);
                 } else {
-                    // No welcome file configured, serve nothing since it's a directory
-                    resource = null;
+                    System.out.println("ClassPathResourceHandler.getResource no welcome file, returning null");
+                    return null;
                 }
             }
 
             if (resource != null && resource.exists()) {
+                System.out.println("ClassPathResourceHandler.getResource resource exists, checking directory traversal");
                 DirectoryTraversal.protectAgainstInClassPath(resource.getPath());
+                System.out.println("ClassPathResourceHandler.getResource returning resource: " + resource);
                 return resource;
             } else {
+                System.out.println("ClassPathResourceHandler.getResource resource doesn't exist, returning null");
                 return null;
             }
 
         } catch (DirectoryTraversal.DirectoryTraversalDetection directoryTraversalDetection) {
+            System.out.println("ClassPathResourceHandler.getResource caught DirectoryTraversalDetection: " + directoryTraversalDetection.getMessage());
             throw directoryTraversalDetection;
-        } catch (Exception e) {
-            if (LOG.isDebugEnabled()) {
-                LOG.debug(e.getClass().getSimpleName() + " when trying to get resource. " + e.getMessage());
-            }
         }
-        return null;
     }
 
 }
diff --git a/src/main/java/spark/resource/UriPath.java b/src/main/java/spark/resource/UriPath.java
index b824c68..50743e5 100644
--- a/src/main/java/spark/resource/UriPath.java
+++ b/src/main/java/spark/resource/UriPath.java
@@ -30,7 +30,9 @@ public class UriPath {
      * @return path or null.
      */
     public static String canonical(String path) {
+        System.out.println("UriPath.canonical called with path: " + path);
         if (path == null || path.length() == 0) {
+            System.out.println("UriPath.canonical returning null or empty path");
             return path;
         }
 
@@ -58,6 +60,7 @@ public class UriPath {
 
         // If we have checked the entire string
         if (start >= end) {
+            System.out.println("UriPath.canonical returning original path: " + path);
             return path;
         }
 
@@ -89,20 +92,8 @@ public class UriPath {
                     delStart = start;
                     if (delStart < 0 || delStart == 0 && buf.charAt(delStart) == '/') {
                         delStart++;
-                        if (delEnd < buf.length() && buf.charAt(delEnd) == '/') {
-                            delEnd++;
-                        }
-                        break;
-                    }
-                    if (end == buf.length()) {
-                        delStart++;
-                    }
-
-                    end = start--;
-                    while (start >= 0 && buf.charAt(start) != '/') {
-                        start--;
                     }
-                    continue;
+                    break;
 
                 case 3: // possible double dot
                     if (buf.charAt(start + 1) != '.' || buf.charAt(start + 2) != '.') {
@@ -115,50 +106,124 @@ public class UriPath {
                         break;
                     }
 
-                    delStart = start;
-                    if (delEnd < 0) {
-                        delEnd = end;
-                    }
+                    delEnd = end;
 
-                    skip++;
-                    end = start--;
-                    while (start >= 0 && buf.charAt(start) != '/') {
-                        start--;
+                    if (start < 0) {
+                        delStart = 0;
+                        skip++;
+                    } else {
+                        delStart = buf.lastIndexOf("/", start - 1) + 1;
+
+                        if (delStart <= 0) {
+                            delStart = 0;
+                            skip++;
+                        }
                     }
-                    continue;
+                    break;
 
                 default:
                     if (skip > 0 && --skip == 0) {
                         delStart = start >= 0 ? start : 0;
-                        if (delEnd == buf.length() && buf.charAt(delEnd - 1) == '.') {
+                        if (delStart > 0 && delEnd == buf.length() && buf.charAt(delEnd - 1) == '.') {
                             delStart++;
                         }
                     }
             }
 
-            // Do the delete
-            if (skip <= 0 && delStart >= 0 && delEnd >= delStart) {
+            if (skip <= 0 && delStart >= 0 && delEnd >= 0) {
                 buf.delete(delStart, delEnd);
                 delStart = delEnd = -1;
             }
 
-            end = start--;
-            while (start >= 0 && buf.charAt(start) != '/') {
-                start--;
-            }
+            end = start;
+            start = buf.lastIndexOf("/", end - 1);
         }
 
-        // Too many ..
         if (skip > 0) {
+            System.out.println("UriPath.canonical returning null due to too many ..");
             return null;
         }
 
-        // Do the delete
-        if (delEnd >= 0) {
-            buf.delete(delStart, delEnd);
+        if (buf.length() == 0) {
+            buf.append('/');
         }
 
-        return buf.toString();
+        String result = buf.toString();
+        System.out.println("UriPath.canonical returning: " + result);
+        return result;
+    }
+
+    /**
+     * Return the parent Path.
+     * Treat a URI like a directory path and return the parent directory.
+     *
+     * @param p the path to return a parent reference to
+     * @return the parent path of the URI
+     */
+    public static String parentPath(String p) {
+        if (p == null || p.length() == 0) {
+            return p;
+        }
+        int slash = p.lastIndexOf('/');
+        if (slash <= 0) {
+            return "/";
+        }
+        return p.substring(0, slash);
     }
 
+    /**
+     * Add two URI path segments.
+     * Handles null and empty paths, path and query params (eg ?a=b or
+     * ;JSESSIONID=xxx) and avoids duplicate '/' characters.
+     *
+     * @param p1 URI path segment (should be encoded)
+     * @param p2 URI path segment (should be encoded)
+     * @return Legally combined path segments.
+     */
+    public static String addPaths(String p1, String p2) {
+        System.out.println("UriPath.addPaths called with p1: " + p1 + ", p2: " + p2);
+        if (p1 == null || p1.length() == 0) {
+            if (p1 != null && p1.length() == 0 && p2 != null) {
+                return p2;
+            }
+            return p2;
+        }
+        if (p2 == null || p2.length() == 0) {
+            return p1;
+        }
+
+        int split = p1.indexOf(';');
+        if (split < 0) {
+            split = p1.indexOf('?');
+        }
+        if (split == 0) {
+            return p2 + p1;
+        }
+        if (split > 0) {
+            return p1.substring(0, split) + addPaths(p1.substring(split), p2);
+        }
+
+        int l1 = p1.length();
+        boolean p1EndsWithSlash = p1.charAt(l1 - 1) == '/';
+
+        if (p2.startsWith("/")) {
+            if (p1EndsWithSlash) {
+                String result = p1 + p2.substring(1);
+                System.out.println("UriPath.addPaths returning: " + result);
+                return result;
+            }
+            String result = p1 + p2;
+            System.out.println("UriPath.addPaths returning: " + result);
+            return result;
+        }
+
+        if (p1EndsWithSlash) {
+            String result = p1 + p2;
+            System.out.println("UriPath.addPaths returning: " + result);
+            return result;
+        }
+        String result = p1 + "/" + p2;
+        System.out.println("UriPath.addPaths returning: " + result);
+        return result;
+    }
 }
diff --git a/src/main/java/spark/staticfiles/DirectoryTraversal.java b/src/main/java/spark/staticfiles/DirectoryTraversal.java
index 080fbe4..b94fd2f 100644
--- a/src/main/java/spark/staticfiles/DirectoryTraversal.java
+++ b/src/main/java/spark/staticfiles/DirectoryTraversal.java
@@ -10,16 +10,31 @@ import static spark.utils.StringUtils.removeLeadingAndTrailingSlashesFrom;
 public class DirectoryTraversal {
 
     public static void protectAgainstInClassPath(String path) {
-        if (!removeLeadingAndTrailingSlashesFrom(path).startsWith(StaticFilesFolder.local())) {
+        System.out.println("DirectoryTraversal.protectAgainstInClassPath called with path: " + path);
+        String cleanPath = removeLeadingAndTrailingSlashesFrom(path);
+        String localFolder = StaticFilesFolder.local();
+        System.out.println("DirectoryTraversal.protectAgainstInClassPath cleanPath: " + cleanPath);
+        System.out.println("DirectoryTraversal.protectAgainstInClassPath localFolder: " + localFolder);
+        if (!cleanPath.startsWith(localFolder)) {
+            System.out.println("DirectoryTraversal.protectAgainstInClassPath FAILED - path does not start with local folder");
             throw new DirectoryTraversalDetection("classpath");
         }
+        System.out.println("DirectoryTraversal.protectAgainstInClassPath PASSED");
     }
 
     public static void protectAgainstForExternal(String path) {
+        System.out.println("DirectoryTraversal.protectAgainstForExternal called with path: " + path);
         String nixLikePath = Paths.get(path).toAbsolutePath().toString().replace("\\", "/");
-        if (!removeLeadingAndTrailingSlashesFrom(nixLikePath).startsWith(StaticFilesFolder.external())) {
+        String cleanPath = removeLeadingAndTrailingSlashesFrom(nixLikePath);
+        String externalFolder = StaticFilesFolder.external();
+        System.out.println("DirectoryTraversal.protectAgainstForExternal nixLikePath: " + nixLikePath);
+        System.out.println("DirectoryTraversal.protectAgainstForExternal cleanPath: " + cleanPath);
+        System.out.println("DirectoryTraversal.protectAgainstForExternal externalFolder: " + externalFolder);
+        if (!cleanPath.startsWith(externalFolder)) {
+            System.out.println("DirectoryTraversal.protectAgainstForExternal FAILED - path does not start with external folder");
             throw new DirectoryTraversalDetection("external");
         }
+        System.out.println("DirectoryTraversal.protectAgainstForExternal PASSED");
     }
 
     public static final class DirectoryTraversalDetection extends RuntimeException {
