diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 000000000..de05c7304
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/apache__dubbo_CVE-2021-30180_2.7.9 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 000000000..716c2507a
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,23 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/apache__dubbo_CVE-2021-30180_2.7.9 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Copy dependencies to a directory
+RUN mvn dependency:copy-dependencies -DoutputDirectory=/project/dependencies -DincludeScope=runtime -pl dubbo-cluster
+
+# Run the vulnerability test
+CMD ["java", "-cp", "dubbo-cluster/target/classes:dubbo-cluster/target/test-classes:dubbo-common/target/classes:dubbo-rpc/dubbo-rpc-api/target/classes:/project/dependencies/*", "org.apache.dubbo.rpc.cluster.router.tag.vulnerability.TagRouterVulnerabilityTest"]
diff --git a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRuleParser.java b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRuleParser.java
index 4f6669f1b..b4cb16922 100644
--- a/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRuleParser.java
+++ b/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/tag/model/TagRuleParser.java
@@ -27,19 +27,33 @@ import org.yaml.snakeyaml.constructor.Constructor;
 public class TagRuleParser {
 
     public static TagRouterRule parse(String rawRule) {
-        Constructor constructor = new Constructor(TagRouterRule.class);
-        TypeDescription tagDescription = new TypeDescription(TagRouterRule.class);
-        tagDescription.addPropertyParameters("tags", Tag.class);
-        constructor.addTypeDescription(tagDescription);
+        System.out.println("DEBUG: TagRuleParser.parse() called with rawRule: " + rawRule);
+        try {
+            Constructor constructor = new Constructor(TagRouterRule.class);
+            System.out.println("DEBUG: Created Constructor for TagRouterRule.class");
+            TypeDescription tagDescription = new TypeDescription(TagRouterRule.class);
+            tagDescription.addPropertyParameters("tags", Tag.class);
+            constructor.addTypeDescription(tagDescription);
+            System.out.println("DEBUG: Added TypeDescription for Tag.class");
 
-        Yaml yaml = new Yaml(constructor);
-        TagRouterRule rule = yaml.load(rawRule);
-        rule.setRawRule(rawRule);
-        if (CollectionUtils.isEmpty(rule.getTags())) {
-            rule.setValid(false);
-        }
+            Yaml yaml = new Yaml(constructor);
+            System.out.println("DEBUG: Created Yaml instance");
+            TagRouterRule rule = yaml.load(rawRule);
+            System.out.println("DEBUG: Loaded YAML: " + (rule != null ? "success" : "null"));
+            rule.setRawRule(rawRule);
+            if (CollectionUtils.isEmpty(rule.getTags())) {
+                rule.setValid(false);
+                System.out.println("DEBUG: Rule is invalid - empty tags");
+            } else {
+                System.out.println("DEBUG: Rule has tags: " + rule.getTags().size());
+            }
 
-        rule.init();
-        return rule;
+            rule.init();
+            return rule;
+        } catch (Exception e) {
+            System.out.println("DEBUG: Exception in TagRuleParser.parse(): " + e.getMessage());
+            e.printStackTrace();
+            throw e;
+        }
     }
 }
diff --git a/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/tag/vulnerability/TagRouterVulnerabilityTest.java b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/tag/vulnerability/TagRouterVulnerabilityTest.java
new file mode 100644
index 000000000..5bb0ea816
--- /dev/null
+++ b/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/router/tag/vulnerability/TagRouterVulnerabilityTest.java
@@ -0,0 +1,224 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.dubbo.rpc.cluster.router.tag.vulnerability;
+
+import org.apache.dubbo.common.URL;
+import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;
+import org.apache.dubbo.common.config.configcenter.ConfigurationListener;
+import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;
+import org.apache.dubbo.common.constants.CommonConstants;
+import org.apache.dubbo.rpc.Invocation;
+import org.apache.dubbo.rpc.Invoker;
+import org.apache.dubbo.rpc.Result;
+import org.apache.dubbo.rpc.RpcException;
+import org.apache.dubbo.rpc.cluster.governance.GovernanceRuleRepository;
+import org.apache.dubbo.rpc.cluster.router.tag.TagRouter;
+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRouterRule;
+import org.apache.dubbo.rpc.cluster.router.tag.model.TagRuleParser;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Test case for CVE-2021-30180 vulnerability in Apache Dubbo
+ * This test demonstrates the code injection vulnerability in the TagRouter
+ * when parsing YAML rules using SnakeYAML without proper restrictions.
+ */
+public class TagRouterVulnerabilityTest {
+
+    // Flag to track if code injection occurred
+    private static boolean codeInjectionDetected = false;
+    private static final String TEST_FILE_PATH = "/tmp/dubbo-code-injection-test";
+
+    /**
+     * Mock implementation of GovernanceRuleRepository for testing
+     */
+    public static class MockGovernanceRuleRepository implements GovernanceRuleRepository {
+        private final Map<String, String> store = new HashMap<>();
+        private final Map<String, List<ConfigurationListener>> listeners = new HashMap<>();
+
+        @Override
+        public void addListener(String key, String group, ConfigurationListener listener) {
+            System.out.println("DEBUG: Adding listener for key=" + key + ", group=" + group);
+            String fullKey = group + ":" + key;
+            List<ConfigurationListener> listenerList = listeners.computeIfAbsent(fullKey, k -> new ArrayList<>());
+            listenerList.add(listener);
+        }
+
+        @Override
+        public void removeListener(String key, String group, ConfigurationListener listener) {
+            System.out.println("DEBUG: Removing listener for key=" + key + ", group=" + group);
+            String fullKey = group + ":" + key;
+            List<ConfigurationListener> listenerList = listeners.get(fullKey);
+            if (listenerList != null) {
+                listenerList.remove(listener);
+            }
+        }
+
+        @Override
+        public String getRule(String key, String group, long timeout) {
+            System.out.println("DEBUG: Getting rule for key=" + key + ", group=" + group);
+            return store.get(group + ":" + key);
+        }
+
+        public void setRule(String key, String group, String content) {
+            System.out.println("DEBUG: Setting rule for key=" + key + ", group=" + group + ", content=" + content);
+            store.put(group + ":" + key, content);
+            String fullKey = group + ":" + key;
+            List<ConfigurationListener> listenerList = listeners.get(fullKey);
+            if (listenerList != null) {
+                System.out.println("DEBUG: Notifying " + listenerList.size() + " listeners");
+                for (ConfigurationListener listener : listenerList) {
+                    listener.process(new ConfigChangedEvent(key, group, content));
+                }
+            } else {
+                System.out.println("DEBUG: No listeners found for key=" + key);
+            }
+        }
+    }
+
+    /**
+     * Mock implementation of Invoker for testing
+     */
+    public static class MockInvoker<T> implements Invoker<T> {
+        private final URL url;
+        private final Class<T> type;
+
+        public MockInvoker(URL url, Class<T> type) {
+            this.url = url;
+            this.type = type;
+        }
+
+        @Override
+        public Class<T> getInterface() {
+            return type;
+        }
+
+        @Override
+        public URL getUrl() {
+            return url;
+        }
+
+        @Override
+        public boolean isAvailable() {
+            return true;
+        }
+
+        @Override
+        public Result invoke(Invocation invocation) throws RpcException {
+            return null;
+        }
+
+        @Override
+        public void destroy() {
+        }
+    }
+
+    /**
+     * Helper class to create a more realistic exploit payload
+     */
+    public static class CommandExecution {
+        public CommandExecution(String command) {
+            try {
+                System.out.println("DEBUG: Executing command: " + command);
+                // Create a file as evidence of code execution
+                File file = new File(TEST_FILE_PATH);
+                file.createNewFile();
+                // Mark that code injection was successful
+                codeInjectionDetected = true;
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    /**
+     * Main method to run the test directly
+     */
+    public static void main(String[] args) {
+        try {
+            System.out.println("DEBUG: Starting vulnerability test");
+            
+            // Delete the test file if it exists
+            File testFile = new File(TEST_FILE_PATH);
+            if (testFile.exists()) {
+                System.out.println("DEBUG: Deleting existing test file");
+                testFile.delete();
+            }
+            
+            // Reset the flag
+            codeInjectionDetected = false;
+
+            // Create a mock repository
+            MockGovernanceRuleRepository repository = new MockGovernanceRuleRepository();
+            
+            // Create a TagRouter instance
+            URL url = URL.valueOf("dubbo://localhost:20880/DemoService");
+            System.out.println("DEBUG: Created URL: " + url);
+            TagRouter router = new TagRouter(url);
+            System.out.println("DEBUG: Created TagRouter");
+            
+            // Set the rule repository field using reflection
+            java.lang.reflect.Field field = TagRouter.class.getSuperclass().getDeclaredField("ruleRepository");
+            field.setAccessible(true);
+            field.set(router, repository);
+            System.out.println("DEBUG: Set ruleRepository field");
+            
+            // Create a list of invokers
+            List<Invoker<Object>> invokers = new ArrayList<>();
+            URL providerUrl = URL.valueOf("dubbo://localhost:20880/DemoService")
+                    .addParameter(CommonConstants.REMOTE_APPLICATION_KEY, "provider-app");
+            invokers.add(new MockInvoker<>(providerUrl, Object.class));
+            System.out.println("DEBUG: Created invokers list with provider-app");
+            
+            // Notify the router with the invokers to trigger the configuration loading
+            System.out.println("DEBUG: Calling router.notify()");
+            router.notify(invokers);
+            
+            // Create a malicious YAML payload that will execute code when parsed by SnakeYAML
+            String maliciousYaml = "!!org.apache.dubbo.rpc.cluster.router.tag.vulnerability.TagRouterVulnerabilityTest$CommandExecution [\"touch /tmp/dubbo-code-injection-test\"]";
+            System.out.println("DEBUG: Created malicious YAML payload");
+            
+            // Set the malicious rule to trigger the vulnerability
+            System.out.println("DEBUG: Setting malicious rule");
+            repository.setRule("provider-app.tag-router", GovernanceRuleRepository.DEFAULT_GROUP, maliciousYaml);
+            
+            // Check if code injection was detected
+            System.out.println("DEBUG: Checking if code injection was detected");
+            System.out.println("DEBUG: codeInjectionDetected = " + codeInjectionDetected);
+            System.out.println("DEBUG: testFile.exists() = " + testFile.exists());
+            
+            if (codeInjectionDetected || testFile.exists()) {
+                System.out.println("Vulnerability DETECTED: Code injection in TagRouter YAML parsing");
+                // If vulnerability exists, the test should fail
+                System.exit(1);
+            } else {
+                System.out.println("Vulnerability NOT DETECTED: TagRouter YAML parsing is secure");
+                // If vulnerability is fixed, the test should pass
+                System.exit(0);
+            }
+        } catch (Exception e) {
+            System.out.println("DEBUG: Exception occurred: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+}
