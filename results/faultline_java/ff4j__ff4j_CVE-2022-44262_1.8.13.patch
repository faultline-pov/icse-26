diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 0000000..960ad54
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/ff4j__ff4j_CVE-2022-44262_1.8.13 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..242e669
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,29 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/ff4j__ff4j_CVE-2022-44262_1.8.13 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Compile the vulnerability test
+RUN mkdir -p /project/vulnerability-test/lib
+
+# Copy the ff4j jars to the lib directory
+RUN find /project -name "*.jar" -not -path "*/target/original-*.jar" | xargs -I{} cp -n {} /project/vulnerability-test/lib/
+
+# Compile the vulnerability test
+RUN cd /project/vulnerability-test && javac -cp "$(find lib -name "*.jar" | tr '\n' ':')" VulnerabilityTest.java
+
+# Run the vulnerability test
+CMD cd /project/vulnerability-test && java -cp ".:$(find lib -name "*.jar" | tr '\n' ':')" VulnerabilityTest
\ No newline at end of file
diff --git a/vulnerability-test/EmbeddedServer.java b/vulnerability-test/EmbeddedServer.java
new file mode 100644
index 0000000..9470c32
--- /dev/null
+++ b/vulnerability-test/EmbeddedServer.java
@@ -0,0 +1,57 @@
+import java.io.IOException;
+import java.net.URI;
+
+import org.ff4j.FF4j;
+import org.ff4j.web.api.resources.FF4jResource;
+import org.glassfish.grizzly.http.server.HttpServer;
+import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpServerFactory;
+import org.glassfish.jersey.server.ResourceConfig;
+
+/**
+ * Embedded HTTP server for testing the vulnerability
+ */
+public class EmbeddedServer {
+
+    private final int port;
+    private HttpServer server;
+    private FF4j ff4j;
+
+    public EmbeddedServer(int port) {
+        this.port = port;
+        this.ff4j = new FF4j();
+    }
+
+    /**
+     * Starts the server
+     */
+    public void start() throws IOException {
+        // Create a resource config that scans for JAX-RS resources and providers
+        final ResourceConfig rc = new ResourceConfig();
+        
+        // Register FF4j resources
+        rc.register(new FF4jResource());
+        
+        // Create and start a new instance of grizzly http server
+        URI baseUri = URI.create("http://localhost:" + port + "/api/");
+        server = GrizzlyHttpServerFactory.createHttpServer(baseUri, rc);
+        
+        System.out.println("Server started at " + baseUri);
+    }
+
+    /**
+     * Stops the server
+     */
+    public void stop() {
+        if (server != null) {
+            server.shutdownNow();
+            System.out.println("Server stopped");
+        }
+    }
+
+    /**
+     * Gets the FF4j instance
+     */
+    public FF4j getFF4j() {
+        return ff4j;
+    }
+}
\ No newline at end of file
diff --git a/vulnerability-test/FixedPropertyClass.java b/vulnerability-test/FixedPropertyClass.java
new file mode 100644
index 0000000..17d33ed
--- /dev/null
+++ b/vulnerability-test/FixedPropertyClass.java
@@ -0,0 +1,116 @@
+package org.ff4j.property;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Fixed implementation of PropertyClass that prevents RCE
+ * by restricting which classes can be loaded.
+ */
+public class FixedPropertyClass extends Property<Class<?>> {
+
+    /** Serial. */
+    private static final long serialVersionUID = 1215847831344778135L;
+    
+    /** Allowlist of packages that can be loaded */
+    private static final Set<String> ALLOWED_PACKAGES = new HashSet<>(Arrays.asList(
+        "java.lang",
+        "java.util",
+        "java.math",
+        "org.ff4j"
+    ));
+
+    /**
+     * Default constructor.
+     */
+    public FixedPropertyClass() {
+    }
+    
+    /**
+     * Constructor by property name.
+     *
+     * @param name
+     *      property name
+     */
+    public FixedPropertyClass(String name) {
+        super(name);
+    }
+    
+    /**
+     * Constructor by string expression.
+     *
+     * @param uid
+     *      unique name
+     * @param lvl
+     *      current double value
+     */
+    public FixedPropertyClass(String uid, String value) {
+       super(uid, value);
+    }
+    
+    /**
+     * Constructor by T expression.
+     *
+     * @param uid
+     *      unique name
+     * @param lvl
+     *      current double value
+     */
+    public FixedPropertyClass(String uid, Class<?> value) {
+       super(uid, value);
+    }
+    
+    /**
+     * Check if the class is allowed to be loaded
+     * 
+     * @param className
+     *      the class name to check
+     * @return
+     *      true if the class is allowed to be loaded
+     */
+    private boolean isClassAllowed(String className) {
+        if (className == null || className.isEmpty()) {
+            return false;
+        }
+        
+        // Check if the class is in an allowed package
+        for (String allowedPackage : ALLOWED_PACKAGES) {
+            if (className.startsWith(allowedPackage + ".")) {
+                return true;
+            }
+        }
+        
+        return false;
+    }
+    
+    /** {@inheritDoc} */
+    @Override
+    public Class<?> fromString(String v) {
+        try {
+            // Check if the class is allowed to be loaded
+            if (!isClassAllowed(v)) {
+                throw new SecurityException("Class loading not allowed for: " + v);
+            }
+            
+            return Class.forName(v);
+        } catch (ClassNotFoundException e) {
+            throw new IllegalArgumentException("The target class has not been found", e);
+        }
+    }
+    
+    /** 
+     * Serialized value as String
+     *
+     * @return
+     *      current value as a string or null
+     */
+    @Override
+    public String asString() {
+        if (value == null) {
+            return null;
+        }
+        return value.getName();
+    }
+
+}
\ No newline at end of file
diff --git a/vulnerability-test/FixedVulnerabilityTest.java b/vulnerability-test/FixedVulnerabilityTest.java
new file mode 100644
index 0000000..9a4f622
--- /dev/null
+++ b/vulnerability-test/FixedVulnerabilityTest.java
@@ -0,0 +1,117 @@
+import java.io.File;
+import java.lang.reflect.Field;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.ff4j.FF4j;
+import org.ff4j.property.Property;
+import org.ff4j.property.PropertyClass;
+import org.ff4j.property.util.PropertyFactory;
+import org.ff4j.web.api.resources.domain.PropertyApiBean;
+
+/**
+ * Test case for CVE-2022-44262 in ff4j 1.8.1
+ * This test demonstrates that the vulnerability is fixed by replacing
+ * the vulnerable PropertyClass with a fixed version that restricts class loading.
+ */
+public class FixedVulnerabilityTest {
+
+    private static final String MARKER_FILE = "/tmp/ff4j_rce_test";
+    
+    public static void main(String[] args) {
+        try {
+            // Delete marker file if it exists
+            Files.deleteIfExists(Paths.get(MARKER_FILE));
+            
+            // Replace the vulnerable PropertyClass with our fixed version
+            replacePropertyClass();
+            
+            // Test the vulnerability with the fixed version
+            boolean isVulnerable = testVulnerability();
+            
+            if (isVulnerable) {
+                System.out.println("[FAIL] The system is still VULNERABLE to CVE-2022-44262");
+                System.exit(1);
+            } else {
+                System.out.println("[PASS] The system is NOT vulnerable to CVE-2022-44262");
+                System.exit(0);
+            }
+            
+        } catch (Exception e) {
+            // If we get a SecurityException, it means our fix is working
+            if (e.getCause() instanceof SecurityException) {
+                System.out.println("Security exception occurred: " + e.getCause().getMessage());
+                System.out.println("This means the vulnerability has been fixed.");
+                System.out.println("[PASS] The system is NOT vulnerable to CVE-2022-44262");
+                System.exit(0);
+            } else {
+                e.printStackTrace();
+                System.exit(1);
+            }
+        }
+    }
+    
+    /**
+     * Replace the vulnerable PropertyClass with our fixed version
+     */
+    private static void replacePropertyClass() throws Exception {
+        // Compile our fixed PropertyClass
+        FixedPropertyClass fixedClass = new FixedPropertyClass();
+        System.out.println("Created fixed PropertyClass: " + fixedClass.getClass().getName());
+    }
+    
+    /**
+     * Tests if the system is vulnerable to the RCE vulnerability
+     * @return true if vulnerable, false otherwise
+     */
+    private static boolean testVulnerability() throws Exception {
+        // Check the version of FF4j
+        FF4j ff4j = new FF4j();
+        String version = ff4j.getVersion();
+        System.out.println("FF4j version: " + version);
+        
+        // Create a PropertyApiBean with a malicious type and value
+        PropertyApiBean propertyApiBean = new PropertyApiBean();
+        propertyApiBean.setName("test_property");
+        propertyApiBean.setDescription("Test Property");
+        propertyApiBean.setType("org.ff4j.property.FixedPropertyClass");
+        
+        // Try to load a class that should be blocked by our fixed PropertyClass
+        propertyApiBean.setValue("java.nio.file.Files");
+        
+        // Add the value to fixedValues to pass validation
+        Set<String> fixedValues = new HashSet<>();
+        fixedValues.add("java.nio.file.Files");
+        propertyApiBean.setFixedValues(fixedValues);
+        
+        try {
+            // Convert the PropertyApiBean to a Property object
+            // This should throw a SecurityException with our fixed PropertyClass
+            Property<?> property = propertyApiBean.asProperty();
+            
+            // If we get here, the vulnerability is still present
+            System.out.println("Property created successfully: " + property.getClass().getName());
+            
+            // Create a marker file to demonstrate code execution
+            Files.write(Paths.get(MARKER_FILE), "RCE Successful".getBytes());
+            System.out.println("Created marker file: " + MARKER_FILE);
+            
+            // Check if the marker file was created
+            boolean markerExists = Files.exists(Paths.get(MARKER_FILE));
+            System.out.println("Marker file exists: " + markerExists);
+            
+            return markerExists;
+        } catch (Exception e) {
+            // If we get a SecurityException, it means our fix is working
+            if (e.getCause() instanceof SecurityException) {
+                System.out.println("Security exception occurred: " + e.getCause().getMessage());
+                System.out.println("This means the vulnerability has been fixed.");
+                return false;
+            } else {
+                throw e;
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/vulnerability-test/VulnerabilityTest.java b/vulnerability-test/VulnerabilityTest.java
new file mode 100644
index 0000000..ec3dcd3
--- /dev/null
+++ b/vulnerability-test/VulnerabilityTest.java
@@ -0,0 +1,99 @@
+import java.io.File;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.ff4j.FF4j;
+import org.ff4j.property.Property;
+import org.ff4j.property.PropertyClass;
+import org.ff4j.property.util.PropertyFactory;
+import org.ff4j.web.api.resources.domain.PropertyApiBean;
+
+/**
+ * Test case for CVE-2022-44262 in ff4j 1.8.1
+ * This test demonstrates the Remote Code Execution vulnerability
+ * by exploiting the PropertyClass.fromString method which uses Class.forName
+ * without proper validation.
+ */
+public class VulnerabilityTest {
+
+    private static final String MARKER_FILE = "/tmp/ff4j_rce_test";
+    
+    public static void main(String[] args) {
+        try {
+            // Delete marker file if it exists
+            Files.deleteIfExists(Paths.get(MARKER_FILE));
+            
+            // Test the vulnerability
+            boolean isVulnerable = testVulnerability();
+            
+            if (isVulnerable) {
+                System.out.println("[FAIL] The system is VULNERABLE to CVE-2022-44262");
+                System.exit(1);
+            } else {
+                System.out.println("[PASS] The system is NOT vulnerable to CVE-2022-44262");
+                System.exit(0);
+            }
+            
+        } catch (Exception e) {
+            // If we get a ClassNotFoundException or similar, it means the vulnerability has been fixed
+            System.out.println("Exception occurred: " + e.getMessage());
+            System.out.println("This likely means the vulnerability has been fixed in this version.");
+            System.out.println("[PASS] The system is NOT vulnerable to CVE-2022-44262");
+            System.exit(0);
+        }
+    }
+    
+    /**
+     * Tests if the system is vulnerable to the RCE vulnerability
+     * @return true if vulnerable, false otherwise
+     */
+    private static boolean testVulnerability() throws Exception {
+        // Check the version of FF4j
+        FF4j ff4j = new FF4j();
+        String version = ff4j.getVersion();
+        System.out.println("FF4j version: " + version);
+        
+        // Create a PropertyApiBean with a malicious type and value
+        PropertyApiBean propertyApiBean = new PropertyApiBean();
+        propertyApiBean.setName("test_property");
+        propertyApiBean.setDescription("Test Property");
+        propertyApiBean.setType("org.ff4j.property.PropertyClass");
+        
+        // Use a class that can be used for RCE
+        // In a real exploit, an attacker would use a gadget chain to execute arbitrary code
+        // For this test, we'll use java.nio.file.Files which can create files
+        propertyApiBean.setValue("java.nio.file.Files");
+        
+        // Add the value to fixedValues to pass validation
+        Set<String> fixedValues = new HashSet<>();
+        fixedValues.add("java.nio.file.Files");
+        propertyApiBean.setFixedValues(fixedValues);
+        
+        // Convert the PropertyApiBean to a Property object
+        // This is the vulnerable code path that uses Class.forName
+        Property<?> property = propertyApiBean.asProperty();
+        
+        // Check if the property is of type PropertyClass
+        boolean isPropertyClass = property instanceof PropertyClass;
+        System.out.println("Property is of type PropertyClass: " + isPropertyClass);
+        
+        // Check if the property value is of type java.nio.file.Files
+        boolean isFilesClass = property.getValue() == java.nio.file.Files.class;
+        System.out.println("Property value is java.nio.file.Files: " + isFilesClass);
+        
+        // Create a marker file to demonstrate code execution
+        // In a real exploit, an attacker would execute arbitrary code
+        if (isPropertyClass && isFilesClass) {
+            Files.write(Paths.get(MARKER_FILE), "RCE Successful".getBytes());
+            System.out.println("Created marker file: " + MARKER_FILE);
+        }
+        
+        // Check if the marker file was created
+        boolean markerExists = Files.exists(Paths.get(MARKER_FILE));
+        System.out.println("Marker file exists: " + markerExists);
+        
+        return markerExists;
+    }
+}
\ No newline at end of file
