diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 0000000..82748aa
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/perwendel__spark_CVE-2016-9177_2.5.1 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..858d256
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,23 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/perwendel__spark_CVE-2016-9177_2.5.1 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Copy all dependencies to the target/dependency directory
+RUN mvn dependency:copy-dependencies -DoutputDirectory=target/dependency
+
+# Run the path traversal test
+CMD ["java", "-cp", "target/classes:target/test-classes:target/spark-core-2.5.1.jar:target/dependency/*", "spark.PathTraversalTest"]
\ No newline at end of file
diff --git a/src/main/java/spark/resource/ClassPathResourceHandler.java b/src/main/java/spark/resource/ClassPathResourceHandler.java
index 40789b7..0cefaa3 100644
--- a/src/main/java/spark/resource/ClassPathResourceHandler.java
+++ b/src/main/java/spark/resource/ClassPathResourceHandler.java
@@ -58,28 +58,41 @@ public class ClassPathResourceHandler extends AbstractResourceHandler {
 
     @Override
     protected AbstractFileResolvingResource getResource(String path) throws MalformedURLException {
+        System.out.println("ClassPathResourceHandler.getResource called with path: " + path);
         if (path == null || !path.startsWith("/")) {
             throw new MalformedURLException(path);
         }
 
         try {
             path = UriPath.canonical(path);
+            System.out.println("After UriPath.canonical, path is: " + path);
 
             final String addedPath = addPaths(baseResource, path);
+            System.out.println("After addPaths, addedPath is: " + addedPath);
 
             ClassPathResource resource = new ClassPathResource(addedPath);
+            System.out.println("Created ClassPathResource with path: " + addedPath + ", exists: " + resource.exists());
 
             if (resource.exists() && resource.getFile().isDirectory()) {
                 if (welcomeFile != null) {
                     resource = new ClassPathResource(addPaths(resource.getPath(), welcomeFile));
+                    System.out.println("Using welcome file, new path: " + resource.getPath());
                 } else {
                     //  No welcome file configured, serve nothing since it's a directory
                     resource = null;
+                    System.out.println("Resource is a directory and no welcome file is configured");
                 }
             }
 
-            return (resource != null && resource.exists()) ? resource : null;
+            if (resource != null && resource.exists()) {
+                System.out.println("Returning resource: " + resource.getPath());
+                return resource;
+            } else {
+                System.out.println("Resource does not exist or is null");
+                return null;
+            }
         } catch (Exception e) {
+            System.out.println("Exception in getResource: " + e.getClass().getName() + ": " + e.getMessage());
             if (LOG.isDebugEnabled()) {
                 LOG.debug(e.getClass().getSimpleName() + " when trying to get resource. " + e.getMessage());
             }
diff --git a/src/main/java/spark/resource/UriPath.java b/src/main/java/spark/resource/UriPath.java
index bdb53c9..5937202 100644
--- a/src/main/java/spark/resource/UriPath.java
+++ b/src/main/java/spark/resource/UriPath.java
@@ -30,6 +30,7 @@ public class UriPath {
      * @return path or null.
      */
     public static String canonical(String path) {
+        System.out.println("UriPath.canonical called with path: " + path);
         if (path == null || path.length() == 0) {
             return path;
         }
@@ -58,6 +59,7 @@ public class UriPath {
 
         // If we have checked the entire string
         if (start >= end) {
+            System.out.println("UriPath.canonical returning original path: " + path);
             return path;
         }
 
@@ -97,12 +99,7 @@ public class UriPath {
                     if (end == buf.length()) {
                         delStart++;
                     }
-
-                    end = start--;
-                    while (start >= 0 && buf.charAt(start) != '/') {
-                        start--;
-                    }
-                    continue;
+                    break;
 
                 case 3: // possible double dot
                     if (buf.charAt(start + 1) != '.' || buf.charAt(start + 2) != '.') {
@@ -121,16 +118,22 @@ public class UriPath {
                     }
 
                     skip++;
-                    end = start--;
-                    while (start >= 0 && buf.charAt(start) != '/') {
-                        start--;
+                    if (delStart <= 0) {
+                        System.out.println("UriPath.canonical returning null for path: " + path);
+                        return null;
+                    }
+                    if (delStart > 0 && buf.charAt(delStart - 1) == '/') {
+                        delStart--;
+                    }
+                    if (delEnd < buf.length() && buf.charAt(delEnd) == '/') {
+                        delEnd++;
                     }
-                    continue;
+                    break;
 
                 default:
                     if (skip > 0 && --skip == 0) {
                         delStart = start >= 0 ? start : 0;
-                        if (delEnd == buf.length() && buf.charAt(delEnd - 1) == '.') {
+                        if (delEnd == buf.length() && delStart > 0 && buf.charAt(delEnd - 1) == '.') {
                             delStart++;
                         }
                     }
@@ -140,19 +143,15 @@ public class UriPath {
             if (skip <= 0 && delStart >= 0 && delEnd >= delStart) {
                 buf.delete(delStart, delEnd);
                 delStart = delEnd = -1;
-                if (skip > 0) {
-                    delEnd = end;
-                }
             }
 
-            end = start--;
-            while (start >= 0 && buf.charAt(start) != '/') {
-                start--;
-            }
+            end = start;
+            start = start > 0 ? buf.lastIndexOf("/", start - 1) : -1;
         }
 
         // Too many ..
         if (skip > 0) {
+            System.out.println("UriPath.canonical returning null for path (too many ..): " + path);
             return null;
         }
 
@@ -161,7 +160,8 @@ public class UriPath {
             buf.delete(delStart, delEnd);
         }
 
-        return buf.toString();
+        String result = buf.toString();
+        System.out.println("UriPath.canonical returning: " + result);
+        return result;
     }
-
 }
diff --git a/src/test/java/spark/PathTraversalTest.java b/src/test/java/spark/PathTraversalTest.java
new file mode 100644
index 0000000..517fa9f
--- /dev/null
+++ b/src/test/java/spark/PathTraversalTest.java
@@ -0,0 +1,242 @@
+package spark;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.net.URLEncoder;
+
+import spark.resource.UriPath;
+
+public class PathTraversalTest {
+
+    private static final int PORT = 4567;
+    private static final String TEST_FILE_CONTENT = "This is a test file for path traversal vulnerability";
+    private static final String TEST_FILE_NAME = "test-file.txt";
+    private static final String STATIC_DIR = "public";
+
+    public static void main(String[] args) throws Exception {
+        // Create directory structure and test files
+        setupFiles();
+        
+        // Start Spark with static file serving
+        setupSpark();
+        
+        // Wait for server to start
+        Thread.sleep(1000);
+        
+        // Test for vulnerability
+        boolean isVulnerable = testPathTraversal();
+        
+        // Stop Spark
+        Spark.stop();
+        
+        // Clean up
+        cleanupFiles();
+        
+        // Exit with appropriate code
+        if (isVulnerable) {
+            System.out.println("VULNERABILITY DETECTED: Path traversal vulnerability exists!");
+            System.exit(1); // Fail if vulnerable
+        } else {
+            System.out.println("NO VULNERABILITY DETECTED: Path traversal is not possible.");
+            System.exit(0); // Pass if not vulnerable
+        }
+    }
+    
+    private static void setupFiles() throws IOException {
+        // Create a directory for static files
+        File staticDir = new File(STATIC_DIR);
+        if (!staticDir.exists()) {
+            staticDir.mkdir();
+        }
+        
+        // Create a file in the static directory
+        File staticFile = new File(staticDir, "static-file.txt");
+        try (FileWriter writer = new FileWriter(staticFile)) {
+            writer.write("This is a file in the static directory");
+        }
+        
+        // Create a file outside the static directory
+        File outsideFile = new File(System.getProperty("user.dir"), TEST_FILE_NAME);
+        try (FileWriter writer = new FileWriter(outsideFile)) {
+            writer.write(TEST_FILE_CONTENT);
+        }
+        
+        System.out.println("Created test file outside static directory: " + outsideFile.getAbsolutePath());
+        System.out.println("Created static directory: " + staticDir.getAbsolutePath());
+    }
+    
+    private static void cleanupFiles() {
+        // Delete the test file
+        File outsideFile = new File(System.getProperty("user.dir"), TEST_FILE_NAME);
+        if (outsideFile.exists()) {
+            outsideFile.delete();
+        }
+        
+        // Delete the static directory and its contents
+        deleteDirectory(new File(STATIC_DIR));
+    }
+    
+    private static boolean deleteDirectory(File directory) {
+        if (directory.exists()) {
+            File[] files = directory.listFiles();
+            if (files != null) {
+                for (File file : files) {
+                    if (file.isDirectory()) {
+                        deleteDirectory(file);
+                    } else {
+                        file.delete();
+                    }
+                }
+            }
+        }
+        return directory.delete();
+    }
+    
+    private static void setupSpark() {
+        // Configure Spark to serve static files from the 'public' directory
+        Spark.staticFiles.location("/" + STATIC_DIR);
+        
+        // Add a route to verify the server is running
+        Spark.get("/hello", (req, res) -> "Hello World");
+        
+        // Add a route to help debug UriPath.canonical
+        Spark.get("/debug/*", (req, res) -> {
+            String path = req.splat()[0];
+            String canonical = UriPath.canonical("/" + path);
+            return "Original: /" + path + "\nCanonical: " + canonical;
+        });
+        
+        System.out.println("Spark server started on port " + PORT);
+    }
+    
+    private static boolean testPathTraversal() {
+        // The vulnerability in Spark 2.5 is in the UriPath.canonical method
+        // which doesn't properly handle certain path traversal sequences
+        
+        // Create a list of path traversal patterns to try
+        String[] traversalPatterns = {
+            // Basic path traversal
+            "/../" + TEST_FILE_NAME,
+            "/../../" + TEST_FILE_NAME,
+            "/../../../" + TEST_FILE_NAME,
+            "/../../../../" + TEST_FILE_NAME,
+            
+            // Path traversal with encoded characters
+            "/%2e%2e/" + TEST_FILE_NAME,
+            "/%2e%2e/%2e%2e/" + TEST_FILE_NAME,
+            
+            // Path traversal with backslash
+            "/..\\../" + TEST_FILE_NAME,
+            "/..%5c../" + TEST_FILE_NAME,
+            "/..%5C../" + TEST_FILE_NAME,
+            
+            // Path traversal with URL encoding
+            "/..%252f../" + TEST_FILE_NAME,
+            "/..%c0%af../" + TEST_FILE_NAME,
+            "/..%c1%9c../" + TEST_FILE_NAME,
+            
+            // Double URL encoding
+            "/..%25%32%66../" + TEST_FILE_NAME,
+            
+            // Null byte injection
+            "/..%00/" + TEST_FILE_NAME,
+            "/..%2f%00../" + TEST_FILE_NAME,
+            
+            // Path traversal with multiple encodings
+            "/..%c0%af%c0%af../" + TEST_FILE_NAME,
+            "/..%c0%af%252f../" + TEST_FILE_NAME,
+            "/..%252f%c0%af../" + TEST_FILE_NAME,
+            
+            // Path traversal with Unicode representations
+            "/..%u2215../" + TEST_FILE_NAME,
+            "/..%u2216../" + TEST_FILE_NAME,
+            
+            // Path traversal with mixed slashes
+            "/..\\%2f../" + TEST_FILE_NAME,
+            "/..%2f\\../" + TEST_FILE_NAME,
+            
+            // Path traversal with dot variations
+            "/...././" + TEST_FILE_NAME,
+            "/.....//" + TEST_FILE_NAME,
+            "/....//" + TEST_FILE_NAME,
+            "/...//" + TEST_FILE_NAME
+        };
+        
+        for (String pattern : traversalPatterns) {
+            try {
+                System.out.println("\nTrying path: " + pattern);
+                
+                // Make a request to the server with the traversal path
+                URL url = new URL("http://localhost:" + PORT + pattern);
+                HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+                connection.setRequestMethod("GET");
+                
+                int responseCode = connection.getResponseCode();
+                System.out.println("Response Code: " + responseCode);
+                
+                // If we get a 200 OK, try to read the content
+                if (responseCode == 200) {
+                    try {
+                        String content = readResponse(connection);
+                        System.out.println("Response Content: " + content);
+                        
+                        // Check if the content matches our test file
+                        if (content.contains(TEST_FILE_CONTENT)) {
+                            System.out.println("Found matching content with path: " + pattern);
+                            return true; // Vulnerable
+                        }
+                    } catch (IOException e) {
+                        System.out.println("Error reading response: " + e.getMessage());
+                    }
+                }
+            } catch (Exception e) {
+                System.out.println("Exception: " + e.getMessage());
+            }
+        }
+        
+        // Try a more specific test based on the UriPath.canonical implementation
+        // The vulnerability is in how it handles path segments
+        try {
+            // Create a path that might bypass the canonical path check
+            String specialPath = "/public/..\\../" + TEST_FILE_NAME;
+            System.out.println("\nTrying special path: " + specialPath);
+            
+            URL url = new URL("http://localhost:" + PORT + specialPath);
+            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+            connection.setRequestMethod("GET");
+            
+            int responseCode = connection.getResponseCode();
+            System.out.println("Response Code: " + responseCode);
+            
+            if (responseCode == 200) {
+                String content = readResponse(connection);
+                System.out.println("Response Content: " + content);
+                
+                if (content.contains(TEST_FILE_CONTENT)) {
+                    System.out.println("Found matching content with special path!");
+                    return true; // Vulnerable
+                }
+            }
+        } catch (Exception e) {
+            System.out.println("Exception with special path: " + e.getMessage());
+        }
+        
+        return false; // Not vulnerable
+    }
+    
+    private static String readResponse(HttpURLConnection connection) throws IOException {
+        StringBuilder content = new StringBuilder();
+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
+            String line;
+            while ((line = reader.readLine()) != null) {
+                content.append(line);
+            }
+        }
+        return content.toString();
+    }
+}
