diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 00000000..a3b1e125
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/hapifhir__org.hl7.fhir.core_CVE-2023-28465_5.6.105 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 00000000..8b137891
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 00000000..1adcf45d
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,19 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/hapifhir__org.hl7.fhir.core_CVE-2023-28465_5.6.105 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+RUN chmod +x run_test.sh
+CMD ["./run_test.sh"]
\ No newline at end of file
diff --git a/MinimalTest.java b/MinimalTest.java
new file mode 100644
index 00000000..c06980a8
--- /dev/null
+++ b/MinimalTest.java
@@ -0,0 +1,69 @@
+import org.hl7.fhir.r4b.terminologies.TerminologyCacheManager;
+
+import java.io.*;
+import java.nio.file.*;
+import java.util.zip.*;
+
+public class MinimalTest {
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting minimal test...");
+            
+            // Create a temporary directory for testing
+            Path tempDir = Files.createTempDirectory("test");
+            String targetDir = tempDir.toString();
+            System.out.println("Target directory: " + targetDir);
+            
+            // Create a malicious ZIP file
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            try (ZipOutputStream zos = new ZipOutputStream(baos)) {
+                // Create a malicious entry that appears to start with the target directory
+                // but actually escapes to a parent directory
+                String maliciousPath = tempDir.getFileName() + "not/malicious.txt";
+                System.out.println("Malicious path in ZIP: " + maliciousPath);
+                
+                ZipEntry entry = new ZipEntry(maliciousPath);
+                zos.putNextEntry(entry);
+                zos.write("This is a malicious file".getBytes());
+                zos.closeEntry();
+            }
+            
+            // Test the vulnerable method
+            try {
+                System.out.println("Testing unzip method...");
+                TerminologyCacheManager.unzip(new ByteArrayInputStream(baos.toByteArray()), targetDir);
+                System.out.println("Unzip completed");
+            } catch (Exception e) {
+                System.out.println("Exception during unzip: " + e.getMessage());
+                e.printStackTrace();
+                // If we get an exception about illegal path, the vulnerability is fixed
+                if (e.getMessage() != null && e.getMessage().contains("illegal path")) {
+                    System.out.println("Vulnerability is fixed - test passed");
+                    System.exit(0);
+                }
+            }
+            
+            // Check if a file was created outside the target directory
+            Path siblingDir = tempDir.resolveSibling(tempDir.getFileName() + "not");
+            Path maliciousFile = siblingDir.resolve("malicious.txt");
+            System.out.println("Checking for file at: " + maliciousFile);
+            
+            if (Files.exists(maliciousFile)) {
+                System.out.println("VULNERABILITY DETECTED: File was written outside the target directory!");
+                System.out.println("Content: " + new String(Files.readAllBytes(maliciousFile)));
+                // Clean up
+                Files.delete(maliciousFile);
+                Files.delete(siblingDir);
+                System.exit(1); // Fail if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected or vulnerability is fixed.");
+                System.exit(0); // Pass if no vulnerability
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Test failed with exception: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+}
diff --git a/SimpleZipSlipTest.java b/SimpleZipSlipTest.java
new file mode 100644
index 00000000..7e3b5aae
--- /dev/null
+++ b/SimpleZipSlipTest.java
@@ -0,0 +1,82 @@
+import java.io.*;
+import java.nio.file.*;
+import java.util.zip.*;
+
+public class SimpleZipSlipTest {
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting simple ZIP Slip test...");
+            
+            // Create test directories
+            Path cacheDir = Files.createTempDirectory("cache");
+            Path siblingDir = Files.createTempDirectory("sibling");
+            Path canaryFile = siblingDir.resolve("canary.txt");
+            
+            System.out.println("Cache directory: " + cacheDir.toAbsolutePath());
+            System.out.println("Sibling directory: " + siblingDir.toAbsolutePath());
+            System.out.println("Canary file: " + canaryFile.toAbsolutePath());
+            
+            // Create a malicious ZIP file
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            try (ZipOutputStream zos = new ZipOutputStream(baos)) {
+                // Create a malicious entry that appears to start with the target directory
+                // but actually escapes to a sibling directory
+                String maliciousPath = cacheDir.getFileName() + "not/canary.txt";
+                System.out.println("Malicious path in ZIP: " + maliciousPath);
+                
+                ZipEntry entry = new ZipEntry(maliciousPath);
+                zos.putNextEntry(entry);
+                zos.write("This is a test file".getBytes());
+                zos.closeEntry();
+            }
+            byte[] zipData = baos.toByteArray();
+            
+            // Test the vulnerability
+            try (ZipInputStream zipIn = new ZipInputStream(new ByteArrayInputStream(zipData))) {
+                for (ZipEntry ze; (ze = zipIn.getNextEntry()) != null; ) {
+                    String path = Path.of(cacheDir.toString(), ze.getName()).normalize().toFile().getAbsolutePath();
+                    System.out.println("Normalized path: " + path);
+                    
+                    // This is the vulnerable check
+                    if (!path.startsWith(cacheDir.toString())) {
+                        System.out.println("Path check failed - would prevent vulnerability");
+                        continue;
+                    }
+                    
+                    System.out.println("Path check passed - would allow vulnerability");
+                    
+                    // Create parent directories
+                    File file = new File(path);
+                    File parent = file.getParentFile();
+                    if (parent != null) {
+                        parent.mkdirs();
+                    }
+                    
+                    // Write the file
+                    try (FileOutputStream fos = new FileOutputStream(file)) {
+                        byte[] buffer = new byte[1024];
+                        int len;
+                        while ((len = zipIn.read(buffer)) > 0) {
+                            fos.write(buffer, 0, len);
+                        }
+                    }
+                }
+            }
+            
+            // Check if the vulnerability was exploited
+            if (Files.exists(canaryFile)) {
+                System.out.println("VULNERABILITY DETECTED: File was written outside the cache directory!");
+                System.out.println("Content: " + new String(Files.readAllBytes(canaryFile)));
+                System.exit(1); // Fail if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. Test passed.");
+                System.exit(0); // Pass if no vulnerability
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Test failed with exception: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+}
diff --git a/ZipSlipTest.java b/ZipSlipTest.java
new file mode 100644
index 00000000..64e2107c
--- /dev/null
+++ b/ZipSlipTest.java
@@ -0,0 +1,65 @@
+import org.hl7.fhir.r4b.terminologies.TerminologyCacheManager;
+import java.io.*;
+import java.nio.file.*;
+import java.util.zip.*;
+
+public class ZipSlipTest {
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting ZIP Slip vulnerability test...");
+            
+            // Create test directories
+            Path cacheDir = Files.createTempDirectory("cache");
+            Path siblingDir = Files.createTempDirectory("sibling");
+            Path canaryFile = siblingDir.resolve("canary.txt");
+            
+            System.out.println("Cache directory: " + cacheDir.toAbsolutePath());
+            System.out.println("Sibling directory: " + siblingDir.toAbsolutePath());
+            System.out.println("Canary file: " + canaryFile.toAbsolutePath());
+            
+            // Create a malicious ZIP file
+            byte[] zipData = createMaliciousZip(cacheDir, canaryFile);
+            
+            // Test the vulnerable method
+            try {
+                System.out.println("Calling vulnerable unzip method...");
+                TerminologyCacheManager.unzip(new ByteArrayInputStream(zipData), cacheDir.toString());
+                System.out.println("Unzip completed");
+            } catch (Exception e) {
+                System.out.println("Exception during unzip: " + e.getMessage());
+            }
+            
+            // Check if the vulnerability was exploited
+            if (Files.exists(canaryFile)) {
+                System.out.println("VULNERABILITY DETECTED: File was written outside the cache directory!");
+                System.out.println("Content: " + new String(Files.readAllBytes(canaryFile)));
+                System.exit(1); // Fail if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. Test passed.");
+                System.exit(0); // Pass if no vulnerability
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Test failed with exception: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+    
+    private static byte[] createMaliciousZip(Path cacheDir, Path targetFile) throws IOException {
+        System.out.println("Creating malicious ZIP file...");
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        try (ZipOutputStream zos = new ZipOutputStream(baos)) {
+            // Create a malicious entry that appears to start with the target directory
+            // but actually escapes to a sibling directory
+            String maliciousPath = cacheDir.getFileName() + "not/" + targetFile.getFileName();
+            System.out.println("Malicious path in ZIP: " + maliciousPath);
+            
+            ZipEntry entry = new ZipEntry(maliciousPath);
+            zos.putNextEntry(entry);
+            zos.write("This is a test file".getBytes());
+            zos.closeEntry();
+        }
+        return baos.toByteArray();
+    }
+}
diff --git a/org.hl7.fhir.r4b/src/test/java/org/hl7/fhir/r4b/test/ZipSlipTest.java b/org.hl7.fhir.r4b/src/test/java/org/hl7/fhir/r4b/test/ZipSlipTest.java
new file mode 100644
index 00000000..41ea6f91
--- /dev/null
+++ b/org.hl7.fhir.r4b/src/test/java/org/hl7/fhir/r4b/test/ZipSlipTest.java
@@ -0,0 +1,74 @@
+package org.hl7.fhir.r4b.test;
+
+import org.hl7.fhir.r4b.terminologies.TerminologyCacheManager;
+import org.junit.jupiter.api.Test;
+
+import java.io.*;
+import java.nio.file.*;
+import java.util.zip.*;
+
+public class ZipSlipTest {
+
+    @Test
+    public void testZipSlipVulnerability() throws Exception {
+        System.out.println("Starting ZIP Slip vulnerability test...");
+        
+        // Create test directories
+        Path cacheDir = Files.createTempDirectory("cache");
+        Path siblingDir = Files.createTempDirectory("sibling");
+        Path canaryFile = siblingDir.resolve("canary.txt");
+        
+        System.out.println("Cache directory: " + cacheDir.toAbsolutePath());
+        System.out.println("Sibling directory: " + siblingDir.toAbsolutePath());
+        System.out.println("Canary file: " + canaryFile.toAbsolutePath());
+        
+        // Create a malicious ZIP file
+        byte[] zipData = createMaliciousZip(cacheDir, canaryFile);
+        
+        // Test the vulnerable method
+        try {
+            System.out.println("Calling vulnerable unzip method...");
+            TerminologyCacheManager.unzip(new ByteArrayInputStream(zipData), cacheDir.toString());
+            System.out.println("Unzip completed");
+        } catch (Exception e) {
+            System.out.println("Exception during unzip: " + e.getMessage());
+            e.printStackTrace();
+        }
+        
+        // Check if the vulnerability was exploited
+        if (Files.exists(canaryFile)) {
+            System.out.println("VULNERABILITY DETECTED: File was written outside the cache directory!");
+            System.out.println("Content: " + new String(Files.readAllBytes(canaryFile)));
+            throw new RuntimeException("Vulnerability detected: File was written outside the cache directory");
+        } else {
+            System.out.println("No vulnerability detected. Test passed.");
+        }
+    }
+    
+    private byte[] createMaliciousZip(Path cacheDir, Path targetFile) throws IOException {
+        System.out.println("Creating malicious ZIP file...");
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        try (ZipOutputStream zos = new ZipOutputStream(baos)) {
+            // Create a malicious entry that appears to start with the target directory
+            // but actually escapes to a sibling directory
+            String maliciousPath = cacheDir.getFileName() + "not/" + targetFile.getFileName();
+            System.out.println("Malicious path in ZIP: " + maliciousPath);
+            
+            ZipEntry entry = new ZipEntry(maliciousPath);
+            zos.putNextEntry(entry);
+            zos.write("This is a test file".getBytes());
+            zos.closeEntry();
+        }
+        return baos.toByteArray();
+    }
+    
+    public static void main(String[] args) {
+        try {
+            new ZipSlipTest().testZipSlipVulnerability();
+            System.exit(0); // No vulnerability detected
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.exit(1); // Vulnerability detected or test failed
+        }
+    }
+}
diff --git a/org.hl7.fhir.r4b/src/test/java/org/hl7/fhir/r4b/test/ZipSlipVulnerabilityTest.java b/org.hl7.fhir.r4b/src/test/java/org/hl7/fhir/r4b/test/ZipSlipVulnerabilityTest.java
new file mode 100644
index 00000000..40daf7ba
--- /dev/null
+++ b/org.hl7.fhir.r4b/src/test/java/org/hl7/fhir/r4b/test/ZipSlipVulnerabilityTest.java
@@ -0,0 +1,88 @@
+package org.hl7.fhir.r4b.test;
+
+import org.hl7.fhir.r4b.terminologies.TerminologyCacheManager;
+import org.hl7.fhir.utilities.Utilities;
+
+import java.io.*;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+public class ZipSlipVulnerabilityTest {
+    private static final String TEST_CONTENT = "This is a test file";
+    private static final String CANARY_FILENAME = "canary.txt";
+
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting vulnerability test...");
+            
+            // Create temporary directories
+            Path tempDir = Files.createTempDirectory("cache-dir");
+            Path siblingDir = Files.createTempDirectory("sibling-dir");
+            
+            // Create a canary file path in the sibling directory
+            Path canaryFile = siblingDir.resolve(CANARY_FILENAME);
+            
+            System.out.println("Cache directory: " + tempDir);
+            System.out.println("Sibling directory: " + siblingDir);
+            System.out.println("Canary file path: " + canaryFile);
+            
+            // Create malicious ZIP with path traversal
+            byte[] maliciousZip = createMaliciousZip(tempDir, canaryFile);
+            
+            // Directly test the unzip method
+            try {
+                System.out.println("Testing unzip method with malicious ZIP...");
+                TerminologyCacheManager.unzip(new ByteArrayInputStream(maliciousZip), tempDir.toString());
+                System.out.println("Unzip completed.");
+            } catch (Exception e) {
+                System.out.println("Exception during unzip: " + e.getMessage());
+                e.printStackTrace();
+            }
+            
+            // Check if the canary file exists in the sibling directory
+            boolean vulnerabilityExists = Files.exists(canaryFile);
+            
+            if (vulnerabilityExists) {
+                System.out.println("VULNERABILITY DETECTED: File was written outside the cache directory!");
+                System.out.println("Content of canary file: " + new String(Files.readAllBytes(canaryFile)));
+                System.exit(1); // Test fails if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. Test passed.");
+                System.exit(0); // Test passes if no vulnerability
+            }
+            
+            // Clean up
+            Utilities.clearDirectory(tempDir.toString());
+            Files.delete(tempDir);
+            if (Files.exists(canaryFile)) {
+                Files.delete(canaryFile);
+            }
+            Files.delete(siblingDir);
+            
+        } catch (Exception e) {
+            System.out.println("Test failed with exception: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+
+    private static byte[] createMaliciousZip(Path tempDir, Path targetFile) throws IOException {
+        System.out.println("Creating malicious ZIP file...");
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        try (ZipOutputStream zos = new ZipOutputStream(baos)) {
+            // Create a malicious entry that appears to start with the target directory
+            // but actually escapes to a sibling directory
+            String maliciousPath = tempDir.getFileName() + "not/" + CANARY_FILENAME;
+            System.out.println("Malicious path in ZIP: " + maliciousPath);
+            
+            ZipEntry entry = new ZipEntry(maliciousPath);
+            zos.putNextEntry(entry);
+            zos.write(TEST_CONTENT.getBytes());
+            zos.closeEntry();
+        }
+        System.out.println("Malicious ZIP created.");
+        return baos.toByteArray();
+    }
+}
diff --git a/run_test.sh b/run_test.sh
new file mode 100644
index 00000000..0d411356
--- /dev/null
+++ b/run_test.sh
@@ -0,0 +1,90 @@
+#!/bin/bash
+
+echo "Starting test script..."
+
+# Create temporary directories
+TEMP_DIR=$(mktemp -d)
+SIBLING_DIR=$(mktemp -d)
+CANARY_FILE="$SIBLING_DIR/canary.txt"
+
+echo "Temp directory: $TEMP_DIR"
+echo "Sibling directory: $SIBLING_DIR"
+echo "Canary file: $CANARY_FILE"
+
+# Create a malicious ZIP file
+ZIP_FILE="$TEMP_DIR/malicious.zip"
+echo "Creating malicious ZIP file at $ZIP_FILE"
+
+# Get the basename of the temp directory
+TEMP_DIR_NAME=$(basename "$TEMP_DIR")
+
+# Create a simple Java program to create the malicious ZIP
+cat > "$TEMP_DIR/CreateZip.java" << 'EOF'
+import java.io.*;
+import java.util.zip.*;
+
+public class CreateZip {
+    public static void main(String[] args) throws Exception {
+        String zipFile = args[0];
+        String tempDirName = args[1];
+        String maliciousContent = "This is a malicious file";
+        
+        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {
+            // Create a malicious entry that appears to start with the target directory
+            // but actually escapes to a sibling directory
+            String maliciousPath = tempDirName + "not/canary.txt";
+            System.out.println("Malicious path in ZIP: " + maliciousPath);
+            
+            ZipEntry entry = new ZipEntry(maliciousPath);
+            zos.putNextEntry(entry);
+            zos.write(maliciousContent.getBytes());
+            zos.closeEntry();
+        }
+        System.out.println("ZIP file created successfully");
+    }
+}
+EOF
+
+# Compile and run the ZIP creator
+javac "$TEMP_DIR/CreateZip.java"
+java -cp "$TEMP_DIR" CreateZip "$ZIP_FILE" "$TEMP_DIR_NAME"
+
+# Create a Java program to test the vulnerability
+cat > "$TEMP_DIR/TestVulnerability.java" << 'EOF'
+import org.hl7.fhir.r4b.terminologies.TerminologyCacheManager;
+import java.io.*;
+
+public class TestVulnerability {
+    public static void main(String[] args) throws Exception {
+        String zipFile = args[0];
+        String targetDir = args[1];
+        
+        System.out.println("Testing unzip method with ZIP file: " + zipFile);
+        System.out.println("Target directory: " + targetDir);
+        
+        try {
+            TerminologyCacheManager.unzip(new FileInputStream(zipFile), targetDir);
+            System.out.println("Unzip completed successfully");
+        } catch (Exception e) {
+            System.out.println("Exception during unzip: " + e.getMessage());
+            e.printStackTrace();
+        }
+    }
+}
+EOF
+
+# Compile the test program
+javac -cp "org.hl7.fhir.r4b/target/org.hl7.fhir.r4b-5.6.105.jar:org.hl7.fhir.utilities/target/org.hl7.fhir.utilities-5.6.105.jar" "$TEMP_DIR/TestVulnerability.java"
+
+# Run the test
+java -cp "$TEMP_DIR:org.hl7.fhir.r4b/target/org.hl7.fhir.r4b-5.6.105.jar:org.hl7.fhir.utilities/target/org.hl7.fhir.utilities-5.6.105.jar" TestVulnerability "$ZIP_FILE" "$TEMP_DIR"
+
+# Check if the vulnerability was exploited
+if [ -f "$CANARY_FILE" ]; then
+    echo "VULNERABILITY DETECTED: File was written outside the target directory!"
+    cat "$CANARY_FILE"
+    exit 1  # Fail if vulnerability exists
+else
+    echo "No vulnerability detected or vulnerability is fixed."
+    exit 0  # Pass if no vulnerability
+fi
