diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 00000000..abb93d8e
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.9.10 $WORKSPACE_BASE/java-env/apache-maven-3.9.10
+COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.9.10/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/apache__shiro_CVE-2023-46749_1.12.0 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 00000000..8b137891
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 00000000..fdb3008c
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,26 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.9.10 $WORKSPACE_BASE/java-env/apache-maven-3.9.10
+COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.9.10/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/apache__shiro_CVE-2023-46749_1.12.0 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Create directories for our test
+RUN mkdir -p target/classes/org/apache/shiro/vulnerability
+
+# Compile our test class
+RUN javac -d target/classes -cp "web/target/classes:$(find ~/.m2/repository -name '*.jar' | tr '\n' ':'):/project/web/target/shiro-web-1.12.0.jar" src/main/java/org/apache/shiro/vulnerability/PathTraversalVulnerabilityTest.java
+
+# Run the vulnerability test
+CMD ["java", "-cp", "target/classes:web/target/classes:$(find ~/.m2/repository -name '*.jar' | tr '\n' ':'):/project/web/target/shiro-web-1.12.0.jar", "org.apache.shiro.vulnerability.PathTraversalVulnerabilityTest"]
\ No newline at end of file
diff --git a/src/main/java/org/apache/shiro/vulnerability/PathTraversalVulnerabilityTest.java b/src/main/java/org/apache/shiro/vulnerability/PathTraversalVulnerabilityTest.java
new file mode 100644
index 00000000..92f4b88f
--- /dev/null
+++ b/src/main/java/org/apache/shiro/vulnerability/PathTraversalVulnerabilityTest.java
@@ -0,0 +1,333 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.vulnerability;
+
+import org.apache.shiro.web.filter.InvalidRequestFilter;
+import org.apache.shiro.web.filter.PathMatchingFilter;
+import org.apache.shiro.web.util.WebUtils;
+
+import javax.servlet.FilterChain;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Test case for CVE-2023-46749 - Path Traversal vulnerability in Apache Shiro
+ */
+public class PathTraversalVulnerabilityTest {
+
+    private static final String PROTECTED_PATH = "/protected";
+    private static final String SECRET_FILE = "secret.txt";
+    private static final String SECRET_CONTENT = "This is a secret file that should not be accessible";
+    
+    /**
+     * Main method to run the test
+     */
+    public static void main(String[] args) {
+        try {
+            new PathTraversalVulnerabilityTest().runTest();
+            System.out.println("TEST PASSED: The vulnerability does not exist or has been fixed.");
+            System.exit(0);
+        } catch (Exception e) {
+            System.out.println("TEST FAILED: The vulnerability exists!");
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+    
+    /**
+     * Run the test that demonstrates the path traversal vulnerability (CVE-2023-46749).
+     * This test will throw an exception if the vulnerability exists and pass if it does not exist.
+     */
+    public void runTest() throws Exception {
+        System.out.println("Setting up test environment...");
+        
+        // Create a temporary directory structure with a protected directory and a secret file outside of it
+        File tempDir = Files.createTempDirectory("shiro-test").toFile();
+        File protectedDir = new File(tempDir, "protected");
+        protectedDir.mkdir();
+        
+        // Create a secret file outside the protected directory
+        File secretFile = new File(tempDir, SECRET_FILE);
+        Files.write(secretFile.toPath(), SECRET_CONTENT.getBytes());
+        
+        System.out.println("Test setup complete. Temp dir: " + tempDir.getAbsolutePath());
+        System.out.println("Protected dir: " + protectedDir.getAbsolutePath());
+        System.out.println("Secret file: " + secretFile.getAbsolutePath());
+        
+        // Set up the malicious path that contains a semicolon followed by a directory traversal
+        // The semicolon is used to bypass the path normalization in WebUtils.removeSemicolon
+        String maliciousPath = PROTECTED_PATH + ";/../" + SECRET_FILE;
+        
+        // Create a mock HttpServletRequest
+        MockHttpServletRequest request = new MockHttpServletRequest();
+        request.setServletPath("");
+        request.setPathInfo(maliciousPath);
+        request.setContextPath("");
+        
+        // Create a mock HttpServletResponse
+        MockHttpServletResponse response = new MockHttpServletResponse();
+        
+        // Create a mock FilterChain
+        MockFilterChain chain = new MockFilterChain();
+        
+        // Create a vulnerable InvalidRequestFilter with blockSemicolon disabled
+        TestInvalidRequestFilter invalidRequestFilter = new TestInvalidRequestFilter();
+        invalidRequestFilter.setBlockSemicolon(false); // This is the key setting that enables the vulnerability
+        
+        // Create our test filter
+        VulnerablePathMatchingFilter filter = new VulnerablePathMatchingFilter();
+        Map<String, Object> pathConfig = new HashMap<>();
+        pathConfig.put(PROTECTED_PATH, null); // Configure the filter to protect this path
+        filter.setAppliedPaths(pathConfig);
+        
+        // Configure the filter to only process once per request
+        filter.setFilterOncePerRequest(true);
+        
+        // First, check if the InvalidRequestFilter allows the request
+        boolean accessAllowed = invalidRequestFilter.testIsAccessAllowed(request, response, null);
+        
+        if (!accessAllowed) {
+            System.out.println("InvalidRequestFilter blocked the request - vulnerability is fixed");
+            return; // Test passes - vulnerability is fixed
+        }
+        
+        // Now process the request with our vulnerable filter
+        boolean continueChain = filter.testPreHandle(request, response);
+        
+        // If the filter allows the chain to continue, it means the path traversal worked
+        // and the filter didn't properly protect the resource
+        if (continueChain) {
+            // The vulnerability exists - the test should fail
+            throw new AssertionError("Path traversal vulnerability detected! The filter allowed access to " + maliciousPath);
+        } else {
+            // The vulnerability is fixed - the test should pass
+            System.out.println("Path traversal attempt was blocked - vulnerability is fixed");
+        }
+    }
+    
+    /**
+     * A test implementation of InvalidRequestFilter that exposes protected methods for testing
+     */
+    private static class TestInvalidRequestFilter extends InvalidRequestFilter {
+        public boolean testIsAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
+            return isAccessAllowed(request, response, mappedValue);
+        }
+    }
+    
+    /**
+     * A test implementation of PathMatchingFilter that is vulnerable to the path traversal issue.
+     * It will allow access to the protected path, but should block access to paths outside of it.
+     */
+    private static class VulnerablePathMatchingFilter extends PathMatchingFilter {
+        
+        @Override
+        protected boolean isEnabled(ServletRequest request, ServletResponse response, String path, Object mappedValue) {
+            return true; // Always enabled for testing
+        }
+        
+        @Override
+        protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
+            HttpServletRequest httpRequest = WebUtils.toHttp(request);
+            String path = WebUtils.getPathWithinApplication(httpRequest);
+            
+            System.out.println("Processing path: " + path);
+            
+            // Check if the path is trying to access the secret file
+            if (path.contains(SECRET_FILE)) {
+                System.out.println("Path traversal detected! Attempted to access: " + path);
+                return false; // Block access to the secret file
+            }
+            
+            return true; // Allow access to other paths
+        }
+        
+        public void setAppliedPaths(Map<String, Object> appliedPaths) {
+            this.appliedPaths = appliedPaths;
+        }
+        
+        public boolean testPreHandle(ServletRequest request, ServletResponse response) throws Exception {
+            return preHandle(request, response);
+        }
+    }
+    
+    /**
+     * Simple mock implementation of HttpServletRequest
+     */
+    private static class MockHttpServletRequest implements HttpServletRequest {
+        private String servletPath;
+        private String pathInfo;
+        private String contextPath;
+        
+        public void setServletPath(String servletPath) {
+            this.servletPath = servletPath;
+        }
+        
+        public void setPathInfo(String pathInfo) {
+            this.pathInfo = pathInfo;
+        }
+        
+        public void setContextPath(String contextPath) {
+            this.contextPath = contextPath;
+        }
+        
+        @Override
+        public String getServletPath() {
+            return servletPath;
+        }
+        
+        @Override
+        public String getPathInfo() {
+            return pathInfo;
+        }
+        
+        @Override
+        public String getContextPath() {
+            return contextPath;
+        }
+        
+        // Implement other required methods with minimal functionality
+        @Override public String getAuthType() { return null; }
+        @Override public javax.servlet.http.Cookie[] getCookies() { return new javax.servlet.http.Cookie[0]; }
+        @Override public long getDateHeader(String name) { return 0; }
+        @Override public String getHeader(String name) { return null; }
+        @Override public java.util.Enumeration<String> getHeaders(String name) { return new java.util.Vector<String>().elements(); }
+        @Override public java.util.Enumeration<String> getHeaderNames() { return new java.util.Vector<String>().elements(); }
+        @Override public int getIntHeader(String name) { return 0; }
+        @Override public String getMethod() { return "GET"; }
+        @Override public String getPathTranslated() { return null; }
+        @Override public String getQueryString() { return null; }
+        @Override public String getRemoteUser() { return null; }
+        @Override public boolean isUserInRole(String role) { return false; }
+        @Override public java.security.Principal getUserPrincipal() { return null; }
+        @Override public String getRequestedSessionId() { return null; }
+        @Override public String getRequestURI() { return contextPath + servletPath + pathInfo; }
+        @Override public StringBuffer getRequestURL() { return new StringBuffer("http://localhost" + getRequestURI()); }
+        @Override public javax.servlet.http.HttpSession getSession(boolean create) { return null; }
+        @Override public javax.servlet.http.HttpSession getSession() { return null; }
+        @Override public String changeSessionId() { return null; }
+        @Override public boolean isRequestedSessionIdValid() { return false; }
+        @Override public boolean isRequestedSessionIdFromCookie() { return false; }
+        @Override public boolean isRequestedSessionIdFromURL() { return false; }
+        @Override public boolean isRequestedSessionIdFromUrl() { return false; }
+        @Override public boolean authenticate(HttpServletResponse response) { return false; }
+        @Override public void login(String username, String password) {}
+        @Override public void logout() {}
+        @Override public java.util.Collection<javax.servlet.http.Part> getParts() { return null; }
+        @Override public javax.servlet.http.Part getPart(String name) { return null; }
+        @Override public <T extends javax.servlet.http.HttpUpgradeHandler> T upgrade(Class<T> handlerClass) { return null; }
+        @Override public Object getAttribute(String name) { return null; }
+        @Override public java.util.Enumeration<String> getAttributeNames() { return new java.util.Vector<String>().elements(); }
+        @Override public String getCharacterEncoding() { return "UTF-8"; }
+        @Override public void setCharacterEncoding(String env) {}
+        @Override public int getContentLength() { return 0; }
+        @Override public long getContentLengthLong() { return 0; }
+        @Override public String getContentType() { return null; }
+        @Override public javax.servlet.ServletInputStream getInputStream() { return null; }
+        @Override public String getParameter(String name) { return null; }
+        @Override public java.util.Enumeration<String> getParameterNames() { return new java.util.Vector<String>().elements(); }
+        @Override public String[] getParameterValues(String name) { return new String[0]; }
+        @Override public java.util.Map<String, String[]> getParameterMap() { return new java.util.HashMap<>(); }
+        @Override public String getProtocol() { return "HTTP/1.1"; }
+        @Override public String getScheme() { return "http"; }
+        @Override public String getServerName() { return "localhost"; }
+        @Override public int getServerPort() { return 80; }
+        @Override public java.io.BufferedReader getReader() { return null; }
+        @Override public String getRemoteAddr() { return "127.0.0.1"; }
+        @Override public String getRemoteHost() { return "localhost"; }
+        @Override public void setAttribute(String name, Object o) {}
+        @Override public void removeAttribute(String name) {}
+        @Override public java.util.Locale getLocale() { return java.util.Locale.getDefault(); }
+        @Override public java.util.Enumeration<java.util.Locale> getLocales() { return new java.util.Vector<java.util.Locale>().elements(); }
+        @Override public boolean isSecure() { return false; }
+        @Override public javax.servlet.RequestDispatcher getRequestDispatcher(String path) { return null; }
+        @Override public String getRealPath(String path) { return null; }
+        @Override public int getRemotePort() { return 0; }
+        @Override public String getLocalName() { return "localhost"; }
+        @Override public String getLocalAddr() { return "127.0.0.1"; }
+        @Override public int getLocalPort() { return 8080; }
+        @Override public javax.servlet.ServletContext getServletContext() { return null; }
+        @Override public javax.servlet.AsyncContext startAsync() throws java.lang.IllegalStateException { return null; }
+        @Override public javax.servlet.AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) throws java.lang.IllegalStateException { return null; }
+        @Override public boolean isAsyncStarted() { return false; }
+        @Override public boolean isAsyncSupported() { return false; }
+        @Override public javax.servlet.AsyncContext getAsyncContext() { return null; }
+        @Override public javax.servlet.DispatcherType getDispatcherType() { return javax.servlet.DispatcherType.REQUEST; }
+    }
+    
+    /**
+     * Simple mock implementation of HttpServletResponse
+     */
+    private static class MockHttpServletResponse implements HttpServletResponse {
+        // Implement required methods with minimal functionality
+        @Override public void addCookie(javax.servlet.http.Cookie cookie) {}
+        @Override public boolean containsHeader(String name) { return false; }
+        @Override public String encodeURL(String url) { return url; }
+        @Override public String encodeRedirectURL(String url) { return url; }
+        @Override public String encodeUrl(String url) { return url; }
+        @Override public String encodeRedirectUrl(String url) { return url; }
+        @Override public void sendError(int sc, String msg) {}
+        @Override public void sendError(int sc) {}
+        @Override public void sendRedirect(String location) {}
+        @Override public void setDateHeader(String name, long date) {}
+        @Override public void addDateHeader(String name, long date) {}
+        @Override public void setHeader(String name, String value) {}
+        @Override public void addHeader(String name, String value) {}
+        @Override public void setIntHeader(String name, int value) {}
+        @Override public void addIntHeader(String name, int value) {}
+        @Override public void setStatus(int sc) {}
+        @Override public void setStatus(int sc, String sm) {}
+        @Override public int getStatus() { return 200; }
+        @Override public String getHeader(String name) { return null; }
+        @Override public java.util.Collection<String> getHeaders(String name) { return new java.util.ArrayList<>(); }
+        @Override public java.util.Collection<String> getHeaderNames() { return new java.util.ArrayList<>(); }
+        @Override public String getCharacterEncoding() { return "UTF-8"; }
+        @Override public String getContentType() { return null; }
+        @Override public javax.servlet.ServletOutputStream getOutputStream() { return null; }
+        @Override public java.io.PrintWriter getWriter() { return null; }
+        @Override public void setCharacterEncoding(String charset) {}
+        @Override public void setContentLength(int len) {}
+        @Override public void setContentLengthLong(long len) {}
+        @Override public void setContentType(String type) {}
+        @Override public void setBufferSize(int size) {}
+        @Override public int getBufferSize() { return 0; }
+        @Override public void flushBuffer() {}
+        @Override public void resetBuffer() {}
+        @Override public boolean isCommitted() { return false; }
+        @Override public void reset() {}
+        @Override public void setLocale(java.util.Locale loc) {}
+        @Override public java.util.Locale getLocale() { return java.util.Locale.getDefault(); }
+    }
+    
+    /**
+     * Simple mock implementation of FilterChain
+     */
+    private static class MockFilterChain implements FilterChain {
+        @Override
+        public void doFilter(ServletRequest request, ServletResponse response) throws IOException, javax.servlet.ServletException {
+            // Do nothing
+        }
+    }
+}
diff --git a/src/main/java/org/apache/shiro/vulnerability/PathTraversalVulnerabilityTestRunner.java b/src/main/java/org/apache/shiro/vulnerability/PathTraversalVulnerabilityTestRunner.java
new file mode 100644
index 00000000..4aa221e9
--- /dev/null
+++ b/src/main/java/org/apache/shiro/vulnerability/PathTraversalVulnerabilityTestRunner.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.vulnerability;
+
+import org.apache.shiro.web.filter.vulnerability.PathTraversalVulnerabilityTest;
+import org.junit.runner.JUnitCore;
+import org.junit.runner.Result;
+import org.junit.runner.notification.Failure;
+
+/**
+ * Runner for the Path Traversal vulnerability test (CVE-2023-46749)
+ */
+public class PathTraversalVulnerabilityTestRunner {
+
+    public static void main(String[] args) {
+        System.out.println("Running Path Traversal vulnerability test for CVE-2023-46749");
+        
+        Result result = JUnitCore.runClasses(PathTraversalVulnerabilityTest.class);
+        
+        if (result.wasSuccessful()) {
+            System.out.println("TEST PASSED: The vulnerability does not exist or has been fixed.");
+            System.exit(0);
+        } else {
+            System.out.println("TEST FAILED: The vulnerability exists!");
+            for (Failure failure : result.getFailures()) {
+                System.out.println(failure.toString());
+                if (failure.getException() != null) {
+                    failure.getException().printStackTrace();
+                }
+            }
+            System.exit(1);
+        }
+    }
+}
diff --git a/web/src/test/java/org/apache/shiro/web/filter/vulnerability/PathTraversalVulnerabilityTest.java b/web/src/test/java/org/apache/shiro/web/filter/vulnerability/PathTraversalVulnerabilityTest.java
new file mode 100644
index 00000000..0cdb9964
--- /dev/null
+++ b/web/src/test/java/org/apache/shiro/web/filter/vulnerability/PathTraversalVulnerabilityTest.java
@@ -0,0 +1,176 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.web.filter.vulnerability;
+
+import org.apache.shiro.web.filter.InvalidRequestFilter;
+import org.apache.shiro.web.filter.PathMatchingFilter;
+import org.apache.shiro.web.util.WebUtils;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.servlet.FilterChain;
+import javax.servlet.ServletException;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.easymock.EasyMock.*;
+
+/**
+ * Test case for CVE-2023-46749 - Path Traversal vulnerability in Apache Shiro
+ */
+public class PathTraversalVulnerabilityTest {
+
+    private static final String PROTECTED_PATH = "/protected";
+    private static final String SECRET_FILE = "secret.txt";
+    private static final String SECRET_CONTENT = "This is a secret file that should not be accessible";
+    
+    private HttpServletRequest request;
+    private HttpServletResponse response;
+    private FilterChain chain;
+    private VulnerablePathMatchingFilter filter;
+    private File tempDir;
+    private File secretFile;
+    private File protectedDir;
+    
+    @Before
+    public void setUp() throws Exception {
+        // Create a temporary directory structure with a protected directory and a secret file outside of it
+        tempDir = Files.createTempDirectory("shiro-test").toFile();
+        protectedDir = new File(tempDir, "protected");
+        protectedDir.mkdir();
+        
+        // Create a secret file outside the protected directory
+        secretFile = new File(tempDir, SECRET_FILE);
+        Files.write(secretFile.toPath(), SECRET_CONTENT.getBytes());
+        
+        // Set up mocks
+        request = createNiceMock(HttpServletRequest.class);
+        response = createNiceMock(HttpServletResponse.class);
+        chain = createNiceMock(FilterChain.class);
+        
+        // Create our test filter
+        filter = new VulnerablePathMatchingFilter();
+        Map<String, Object> pathConfig = new HashMap<>();
+        pathConfig.put(PROTECTED_PATH, null); // Configure the filter to protect this path
+        filter.setAppliedPaths(pathConfig);
+        
+        // Configure the filter to only process once per request
+        filter.setFilterOncePerRequest(true);
+        
+        System.out.println("Test setup complete. Temp dir: " + tempDir.getAbsolutePath());
+        System.out.println("Protected dir: " + protectedDir.getAbsolutePath());
+        System.out.println("Secret file: " + secretFile.getAbsolutePath());
+    }
+    
+    /**
+     * Test that demonstrates the path traversal vulnerability (CVE-2023-46749).
+     * This test will FAIL if the vulnerability exists and PASS if it does not exist.
+     */
+    @Test
+    public void testPathTraversalVulnerability() throws Exception {
+        // Set up the request with a malicious path that contains a semicolon followed by a directory traversal
+        // The semicolon is used to bypass the path normalization in WebUtils.removeSemicolon
+        String maliciousPath = PROTECTED_PATH + ";/../" + SECRET_FILE;
+        
+        // Configure the mock request
+        expect(request.getServletPath()).andReturn("").anyTimes();
+        expect(request.getPathInfo()).andReturn(maliciousPath).anyTimes();
+        expect(request.getContextPath()).andReturn("").anyTimes();
+        replay(request, response, chain);
+        
+        // Create a vulnerable InvalidRequestFilter with blockSemicolon disabled
+        TestInvalidRequestFilter invalidRequestFilter = new TestInvalidRequestFilter();
+        invalidRequestFilter.setBlockSemicolon(false); // This is the key setting that enables the vulnerability
+        
+        // First, check if the InvalidRequestFilter allows the request
+        boolean accessAllowed = invalidRequestFilter.testIsAccessAllowed(request, response, null);
+        
+        if (!accessAllowed) {
+            System.out.println("InvalidRequestFilter blocked the request - vulnerability is fixed");
+            return; // Test passes - vulnerability is fixed
+        }
+        
+        // Now process the request with our vulnerable filter
+        boolean continueChain = filter.testPreHandle(request, response);
+        
+        // If the filter allows the chain to continue, it means the path traversal worked
+        // and the filter didn't properly protect the resource
+        if (continueChain) {
+            // The vulnerability exists - the test should fail
+            throw new AssertionError("Path traversal vulnerability detected! The filter allowed access to " + maliciousPath);
+        } else {
+            // The vulnerability is fixed - the test should pass
+            System.out.println("Path traversal attempt was blocked - vulnerability is fixed");
+        }
+    }
+    
+    /**
+     * A test implementation of InvalidRequestFilter that exposes protected methods for testing
+     */
+    private class TestInvalidRequestFilter extends InvalidRequestFilter {
+        public boolean testIsAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
+            return isAccessAllowed(request, response, mappedValue);
+        }
+    }
+    
+    /**
+     * A test implementation of PathMatchingFilter that is vulnerable to the path traversal issue.
+     * It will allow access to the protected path, but should block access to paths outside of it.
+     */
+    private class VulnerablePathMatchingFilter extends PathMatchingFilter {
+        
+        @Override
+        protected boolean isEnabled(ServletRequest request, ServletResponse response, String path, Object mappedValue) {
+            return true; // Always enabled for testing
+        }
+        
+        @Override
+        protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
+            HttpServletRequest httpRequest = WebUtils.toHttp(request);
+            String path = WebUtils.getPathWithinApplication(httpRequest);
+            
+            System.out.println("Processing path: " + path);
+            
+            // Check if the path is trying to access the secret file
+            if (path.contains(SECRET_FILE)) {
+                System.out.println("Path traversal detected! Attempted to access: " + path);
+                return false; // Block access to the secret file
+            }
+            
+            return true; // Allow access to other paths
+        }
+        
+        public void setAppliedPaths(Map<String, Object> appliedPaths) {
+            this.appliedPaths = appliedPaths;
+        }
+        
+        public boolean testPreHandle(ServletRequest request, ServletResponse response) throws Exception {
+            return preHandle(request, response);
+        }
+    }
+}
