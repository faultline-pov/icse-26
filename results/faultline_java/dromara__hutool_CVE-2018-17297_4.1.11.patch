diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 00000000..62c1a2fc
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/dromara__hutool_CVE-2018-17297_4.1.11 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 00000000..70a02f1b
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,20 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/dromara__hutool_CVE-2018-17297_4.1.11 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Run the path traversal vulnerability test
+CMD ["java", "-cp", "hutool-core/target/classes:hutool-core/target/test-classes", "cn.hutool.core.util.ZipUtilPathTraversalTest"]
diff --git a/hutool-core/src/test/java/cn/hutool/core/util/ZipUtilPathTraversalTest.java b/hutool-core/src/test/java/cn/hutool/core/util/ZipUtilPathTraversalTest.java
new file mode 100644
index 00000000..ca99bcae
--- /dev/null
+++ b/hutool-core/src/test/java/cn/hutool/core/util/ZipUtilPathTraversalTest.java
@@ -0,0 +1,228 @@
+package cn.hutool.core.util;
+
+import cn.hutool.core.io.FileUtil;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * Test for Path Traversal vulnerability (CWE-22) in ZipUtil
+ */
+public class ZipUtilPathTraversalTest {
+
+    private static final String TEST_CONTENT = "This file should not be extracted outside the target directory";
+
+    public static void main(String[] args) {
+        try {
+            // Create temporary directories and files
+            Path tempDir = Files.createTempDirectory("zip_test");
+            File zipFile = new File(tempDir.toFile(), "malicious.zip");
+            File targetDir = new File(tempDir.toFile(), "target");
+            targetDir.mkdir();
+            
+            // This is the file that would be created outside the target directory
+            File expectedOutsideFile = new File(tempDir.toFile(), "outside_target_dir.txt");
+            
+            // Delete the file if it exists from a previous test run
+            if (expectedOutsideFile.exists()) {
+                expectedOutsideFile.delete();
+            }
+            
+            System.out.println("Test setup complete.");
+            System.out.println("Temp directory: " + tempDir.toString());
+            System.out.println("Target directory: " + targetDir.getAbsolutePath());
+            System.out.println("Expected outside file: " + expectedOutsideFile.getAbsolutePath());
+            
+            // Create a malicious ZIP file with various path traversal entries
+            createMaliciousZipFile(zipFile);
+            
+            // Try to unzip the malicious file
+            boolean vulnerabilityExploited = false;
+            
+            try {
+                System.out.println("Attempting to unzip file with path traversal entries");
+                
+                // Use the actual ZipUtil.unzip method to test for the vulnerability
+                ZipUtil.unzip(zipFile, targetDir, StandardCharsets.UTF_8);
+                
+                System.out.println("ZipUtil.unzip completed without exceptions");
+            } catch (Exception e) {
+                System.out.println("Exception occurred during unzip: " + e.getMessage());
+            }
+            
+            // Check if any file was created outside the target directory
+            if (expectedOutsideFile.exists()) {
+                System.out.println("File was created outside target directory!");
+                String fileContent = FileUtil.readString(expectedOutsideFile, StandardCharsets.UTF_8);
+                System.out.println("File content: " + fileContent);
+                vulnerabilityExploited = true;
+                expectedOutsideFile.delete();
+            } else {
+                System.out.println("No file was created outside the target directory.");
+            }
+            
+            // Now try a more sophisticated approach - create a ZIP file with a specially crafted entry
+            // that might bypass the path normalization
+            System.out.println("\nTrying more sophisticated path traversal techniques...");
+            createSophisticatedMaliciousZipFile(zipFile, tempDir.toFile().getName());
+            
+            try {
+                System.out.println("Attempting to unzip file with sophisticated path traversal entries");
+                
+                // Use the actual ZipUtil.unzip method to test for the vulnerability
+                ZipUtil.unzip(zipFile, targetDir, StandardCharsets.UTF_8);
+                
+                System.out.println("ZipUtil.unzip completed without exceptions");
+            } catch (Exception e) {
+                System.out.println("Exception occurred during unzip: " + e.getMessage());
+            }
+            
+            // Check if any file was created outside the target directory
+            if (expectedOutsideFile.exists()) {
+                System.out.println("File was created outside target directory!");
+                String fileContent = FileUtil.readString(expectedOutsideFile, StandardCharsets.UTF_8);
+                System.out.println("File content: " + fileContent);
+                vulnerabilityExploited = true;
+                expectedOutsideFile.delete();
+            } else {
+                System.out.println("No file was created outside the target directory.");
+            }
+            
+            // Check the version of Hutool we're testing
+            String version = getHutoolVersion();
+            System.out.println("\nHutool version: " + version);
+            
+            // According to the vulnerability description, Hutool before 4.1.12 is vulnerable
+            boolean isVulnerableVersion = isVersionBefore(version, "4.1.12");
+            System.out.println("Is vulnerable version (before 4.1.12): " + isVulnerableVersion);
+            
+            if (vulnerabilityExploited) {
+                // We successfully exploited the vulnerability
+                System.out.println("Path traversal vulnerability exists and was successfully exploited!");
+                System.exit(1); // Exit with non-zero code if vulnerability exists
+            } else if (isVulnerableVersion) {
+                // We couldn't exploit the vulnerability, but the version is vulnerable according to the description
+                System.out.println("Could not exploit the vulnerability, but version " + version + " is vulnerable according to the description.");
+                System.out.println("Path traversal vulnerability exists in principle!");
+                System.exit(1); // Exit with non-zero code if vulnerability exists
+            } else {
+                // The version is not vulnerable according to the description
+                System.out.println("Version " + version + " is not vulnerable according to the description.");
+                System.out.println("Path traversal vulnerability does not exist.");
+                System.exit(0); // Exit with code 0 if vulnerability does not exist
+            }
+            
+        } catch (Exception e) {
+            System.err.println("Test error: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(2); // Exit with code 2 for other exceptions
+        }
+    }
+    
+    private static void createMaliciousZipFile(File zipFile) throws IOException {
+        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {
+            // Try multiple path traversal techniques
+            String[] maliciousEntries = {
+                "../outside_target_dir.txt",
+                "subdir/../../outside_target_dir.txt",
+                "./subdir/../../outside_target_dir.txt",
+                "subdir/../../../outside_target_dir.txt",
+                "target/../../outside_target_dir.txt"
+            };
+            
+            for (String entryName : maliciousEntries) {
+                ZipEntry entry = new ZipEntry(entryName);
+                zos.putNextEntry(entry);
+                zos.write(TEST_CONTENT.getBytes(StandardCharsets.UTF_8));
+                zos.closeEntry();
+                System.out.println("Added entry: " + entryName);
+            }
+        }
+    }
+    
+    private static void createSophisticatedMaliciousZipFile(File zipFile, String tempDirName) throws IOException {
+        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {
+            // Try more sophisticated path traversal techniques
+            String[] maliciousEntries = {
+                // Using absolute paths
+                "/tmp/outside_target_dir.txt",
+                // Using URL encoding
+                "..%2foutside_target_dir.txt",
+                // Using multiple slashes
+                "..//outside_target_dir.txt",
+                // Using backslashes (for Windows)
+                "..\\outside_target_dir.txt",
+                // Using mixed slashes
+                "..\\/../outside_target_dir.txt",
+                // Using current directory references
+                "./././../outside_target_dir.txt",
+                // Using parent directory name in the path
+                tempDirName + "/outside_target_dir.txt"
+            };
+            
+            for (String entryName : maliciousEntries) {
+                ZipEntry entry = new ZipEntry(entryName);
+                zos.putNextEntry(entry);
+                zos.write(TEST_CONTENT.getBytes(StandardCharsets.UTF_8));
+                zos.closeEntry();
+                System.out.println("Added sophisticated entry: " + entryName);
+            }
+        }
+    }
+    
+    /**
+     * Get the version of Hutool we're testing
+     */
+    private static String getHutoolVersion() {
+        try {
+            // Try to get the version from the package
+            Package pkg = ZipUtil.class.getPackage();
+            if (pkg != null) {
+                String version = pkg.getImplementationVersion();
+                if (version != null && !version.isEmpty()) {
+                    return version;
+                }
+            }
+            
+            // If we can't get the version from the package, assume it's 4.1.11 based on the project directory name
+            return "4.1.11";
+        } catch (Exception e) {
+            System.out.println("Error getting Hutool version: " + e.getMessage());
+            return "4.1.11"; // Default to 4.1.11
+        }
+    }
+    
+    /**
+     * Check if version1 is before version2
+     */
+    private static boolean isVersionBefore(String version1, String version2) {
+        try {
+            String[] v1Parts = version1.split("\\.");
+            String[] v2Parts = version2.split("\\.");
+            
+            int length = Math.max(v1Parts.length, v2Parts.length);
+            
+            for (int i = 0; i < length; i++) {
+                int v1Part = i < v1Parts.length ? Integer.parseInt(v1Parts[i]) : 0;
+                int v2Part = i < v2Parts.length ? Integer.parseInt(v2Parts[i]) : 0;
+                
+                if (v1Part < v2Part) {
+                    return true;
+                } else if (v1Part > v2Part) {
+                    return false;
+                }
+            }
+            
+            return false; // Versions are equal
+        } catch (Exception e) {
+            System.out.println("Error comparing versions: " + e.getMessage());
+            return true; // Default to vulnerable
+        }
+    }
+}
