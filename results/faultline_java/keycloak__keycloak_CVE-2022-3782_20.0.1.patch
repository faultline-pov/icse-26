diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 0000000000..d73386e809
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
+COPY ./java-env/apache-maven-3.9.10 $WORKSPACE_BASE/java-env/apache-maven-3.9.10
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.9.10/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/keycloak__keycloak_CVE-2022-3782_20.0.1 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000000..a8d063ea43
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,25 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
+COPY ./java-env/apache-maven-3.9.10 $WORKSPACE_BASE/java-env/apache-maven-3.9.10
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.9.10/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/keycloak__keycloak_CVE-2022-3782_20.0.1 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+
+# Build only the necessary modules to reduce build time
+RUN mvn clean install -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn -pl services,common
+
+# Compile our test
+RUN javac -cp ".:services/target/classes:common/target/classes" PathTraversalTest.java
+
+# Run the test
+CMD ["java", "-cp", ".:services/target/classes:common/target/classes", "PathTraversalTest"]
\ No newline at end of file
diff --git a/PathTraversalTest.java b/PathTraversalTest.java
new file mode 100644
index 0000000000..4f0dfe8e3c
--- /dev/null
+++ b/PathTraversalTest.java
@@ -0,0 +1,122 @@
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.net.URI;
+import java.net.URLEncoder;
+import java.nio.charset.StandardCharsets;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.UUID;
+
+/**
+ * Test for CVE-2022-3782: Path Traversal vulnerability in Keycloak
+ * This test directly tests the RedirectUtils.verifyRedirectUri method
+ */
+public class PathTraversalTest {
+    // Test file that will be created outside the project directory
+    private static final String TEST_FILE_PATH = "/tmp/keycloak_test_file_" + UUID.randomUUID().toString();
+    private static final String TEST_FILE_CONTENT = "This is a test file for path traversal vulnerability";
+    
+    public static void main(String[] args) {
+        try {
+            // Create a test file outside the project directory
+            createTestFile();
+            
+            // Test the vulnerability
+            boolean isVulnerable = testPathTraversalVulnerability();
+            
+            // Delete the test file
+            deleteTestFile();
+            
+            // Exit with appropriate code
+            if (isVulnerable) {
+                System.out.println("FAIL: Keycloak is vulnerable to path traversal via double URL encoding");
+                System.exit(1);
+            } else {
+                System.out.println("PASS: Keycloak is not vulnerable to path traversal via double URL encoding");
+                System.exit(0);
+            }
+            
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+    
+    private static void createTestFile() throws IOException {
+        File file = new File(TEST_FILE_PATH);
+        try (FileWriter writer = new FileWriter(file)) {
+            writer.write(TEST_FILE_CONTENT);
+        }
+        System.out.println("Created test file at: " + TEST_FILE_PATH);
+    }
+    
+    private static void deleteTestFile() {
+        File file = new File(TEST_FILE_PATH);
+        if (file.exists() && file.delete()) {
+            System.out.println("Deleted test file: " + TEST_FILE_PATH);
+        }
+    }
+    
+    private static boolean testPathTraversalVulnerability() {
+        System.out.println("Testing path traversal vulnerability...");
+        
+        try {
+            // Set up valid redirects
+            Set<String> validRedirects = new HashSet<>();
+            validRedirects.add("http://localhost:8080/app/*");
+            
+            // Create a malicious redirect URI with double URL encoding
+            // First level of encoding for '../../../../../../../tmp/keycloak_test_file_xxx'
+            String maliciousPath = "../../../../../../../" + TEST_FILE_PATH;
+            String firstLevelEncoded = URLEncoder.encode(maliciousPath, StandardCharsets.UTF_8);
+            
+            // Second level of encoding
+            String doubleEncoded = URLEncoder.encode(firstLevelEncoded, StandardCharsets.UTF_8);
+            
+            // Create a redirect URI that should match the valid redirects pattern but contains the encoded traversal
+            String redirectUri = "http://localhost:8080/app/" + doubleEncoded;
+            
+            System.out.println("Testing with redirect URI: " + redirectUri);
+            
+            // Call the verifyRedirectUri method directly
+            // This is the method that should prevent path traversal
+            String verifiedUri = org.keycloak.protocol.oidc.utils.RedirectUtils.verifyRedirectUri(
+                null, "http://localhost:8080", redirectUri, validRedirects, true);
+            
+            System.out.println("Verified URI: " + verifiedUri);
+            
+            // If the vulnerability exists, the verified URI will contain our test file path
+            // or will be a URI that points to our test file
+            if (verifiedUri != null) {
+                try {
+                    // Try to decode the URI to see if it contains our test file path
+                    String decodedUri = java.net.URLDecoder.decode(java.net.URLDecoder.decode(verifiedUri, StandardCharsets.UTF_8), StandardCharsets.UTF_8);
+                    System.out.println("Decoded URI: " + decodedUri);
+                    
+                    if (decodedUri.contains(TEST_FILE_PATH)) {
+                        System.out.println("Vulnerability detected! URI contains path to test file.");
+                        return true;
+                    }
+                    
+                    // Try to create a URI and check if it resolves to our test file
+                    URI uri = URI.create(verifiedUri);
+                    File file = new File(uri);
+                    if (file.exists() && file.getAbsolutePath().equals(TEST_FILE_PATH)) {
+                        System.out.println("Vulnerability detected! URI resolves to test file.");
+                        return true;
+                    }
+                } catch (Exception e) {
+                    // Ignore exceptions during URI processing
+                    System.out.println("Error processing URI: " + e.getMessage());
+                }
+            }
+            
+            return false;
+            
+        } catch (Exception e) {
+            e.printStackTrace();
+            return false;
+        }
+    }
+}
\ No newline at end of file
