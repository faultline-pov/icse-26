diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 0000000..a9311b1
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/apache__sling-org-apache-sling-servlets-resolver_CVE-2024-23673_2.10.0 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..279504b
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,27 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/apache__sling-org-apache-sling-servlets-resolver_CVE-2024-23673_2.10.0 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+
+# Create a script to run our vulnerability test
+RUN echo '#!/bin/bash' > /project/run-vulnerability-test.sh && \
+    echo 'cd /project' >> /project/run-vulnerability-test.sh && \
+    echo 'mvn clean test-compile' >> /project/run-vulnerability-test.sh && \
+    echo 'mvn exec:java -Dexec.mainClass="org.apache.sling.servlets.resolver.internal.PathTraversalVulnerabilityTest" -Dexec.classpathScope=test' >> /project/run-vulnerability-test.sh && \
+    echo 'exit $?' >> /project/run-vulnerability-test.sh
+
+RUN chmod +x /project/run-vulnerability-test.sh
+
+CMD ["/bin/bash", "/project/run-vulnerability-test.sh"]
\ No newline at end of file
diff --git a/src/test/java/org/apache/sling/servlets/resolver/PathTraversalVulnerabilityTest.java b/src/test/java/org/apache/sling/servlets/resolver/PathTraversalVulnerabilityTest.java
new file mode 100644
index 0000000..d159066
--- /dev/null
+++ b/src/test/java/org/apache/sling/servlets/resolver/PathTraversalVulnerabilityTest.java
@@ -0,0 +1,199 @@
+package org.apache.sling.servlets.resolver;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicReference;
+
+import javax.servlet.Servlet;
+import javax.servlet.http.HttpServlet;
+
+import org.apache.sling.api.resource.Resource;
+import org.apache.sling.api.resource.ResourceResolver;
+import org.apache.sling.api.resource.ResourceUtil;
+import org.apache.sling.api.resource.ValueMap;
+import org.apache.sling.api.wrappers.ValueMapDecorator;
+import org.apache.sling.servlets.resolver.internal.SlingServletResolver;
+import org.apache.sling.servlets.resolver.internal.helper.AbstractResourceCollector;
+import org.junit.Test;
+
+/**
+ * Test for CVE-2024-23673: Path traversal vulnerability in Apache Sling Servlets Resolver
+ * This test verifies if the path traversal vulnerability exists in the current version.
+ */
+public class PathTraversalVulnerabilityTest {
+
+    /**
+     * Test for the path traversal vulnerability.
+     * The test will exit with code 1 if the vulnerability exists,
+     * and with code 0 if it does not exist.
+     */
+    @Test
+    public void testPathTraversalVulnerability() throws Exception {
+        // Create a secret file outside the project directory
+        File secretFile = createSecretFile();
+        System.out.println("Created secret file at: " + secretFile.getAbsolutePath());
+        
+        // Create a mock ResourceResolver that will return our secret file
+        ResourceResolver mockResolver = createMockResourceResolver(secretFile);
+        
+        // Create a SlingServletResolver instance with null execution paths (allowing all paths)
+        SlingServletResolver resolver = createServletResolver();
+        
+        // Construct a path with traversal sequences
+        String maliciousPath = "/apps/../../../../../../" + secretFile.getAbsolutePath();
+        System.out.println("Testing with malicious path: " + maliciousPath);
+        
+        try {
+            // Call the vulnerable method directly using reflection
+            Method resolveServletInternalMethod = SlingServletResolver.class.getDeclaredMethod(
+                    "resolveServletInternal", 
+                    org.apache.sling.api.SlingHttpServletRequest.class,
+                    Resource.class, 
+                    String.class, 
+                    ResourceResolver.class);
+            resolveServletInternalMethod.setAccessible(true);
+            
+            // Invoke the method with our malicious path
+            Object servlet = resolveServletInternalMethod.invoke(resolver, null, null, maliciousPath, mockResolver);
+            
+            // If we get a non-null result, the vulnerability exists
+            if (servlet != null) {
+                System.out.println("VULNERABILITY DETECTED: Path traversal allowed access to: " + maliciousPath);
+                System.exit(1); // Vulnerability exists
+            } else {
+                System.out.println("Path traversal attempt blocked: " + maliciousPath);
+                System.exit(0); // Vulnerability does not exist
+            }
+        } catch (Exception e) {
+            System.out.println("Exception during test: " + e.getMessage());
+            e.printStackTrace();
+            
+            // Check if the exception message indicates the vulnerability is fixed
+            if (e.getMessage() != null && e.getMessage().contains("path traversal")) {
+                System.out.println("Vulnerability appears to be fixed based on exception message");
+                System.exit(0);
+            } else {
+                System.out.println("Test inconclusive due to unexpected exception");
+                System.exit(1);
+            }
+        }
+    }
+    
+    /**
+     * Creates a secret file outside the project directory
+     */
+    private File createSecretFile() throws IOException {
+        File secretFile = File.createTempFile("secret", ".txt");
+        secretFile.deleteOnExit();
+        
+        try (FileWriter writer = new FileWriter(secretFile)) {
+            writer.write("This is a secret file that should not be accessible");
+        }
+        
+        return secretFile;
+    }
+    
+    /**
+     * Creates a mock ResourceResolver that will return our secret file as a resource
+     */
+    private ResourceResolver createMockResourceResolver(final File secretFile) {
+        return new ResourceResolver() {
+            @Override
+            public Resource getResource(String path) {
+                System.out.println("Mock resolver asked for resource at path: " + path);
+                // If the path contains our secret file path, return a mock resource
+                if (path != null && path.contains(secretFile.getName())) {
+                    System.out.println("Returning mock resource for: " + path);
+                    return new Resource() {
+                        @Override
+                        public String getPath() {
+                            return path;
+                        }
+                        
+                        @Override
+                        public String getResourceType() {
+                            return "sling/servlet/default";
+                        }
+                        
+                        @Override
+                        public String getResourceSuperType() {
+                            return null;
+                        }
+                        
+                        @Override
+                        public ResourceResolver getResourceResolver() {
+                            return null;
+                        }
+                        
+                        @Override
+                        public <AdapterType> AdapterType adaptTo(Class<AdapterType> type) {
+                            // This is the key part - return a mock servlet when requested
+                            if (type.getName().equals("javax.servlet.Servlet")) {
+                                System.out.println("Adapting to Servlet - VULNERABILITY CONFIRMED");
+                                return (AdapterType) new HttpServlet() {};
+                            }
+                            return null;
+                        }
+                        
+                        @Override
+                        public ValueMap getValueMap() {
+                            return new ValueMapDecorator(new HashMap<String, Object>());
+                        }
+                    };
+                }
+                return null;
+            }
+            
+            // Implement other methods with minimal functionality
+            @Override public Resource resolve(String path) { return null; }
+            @Override public Resource resolve(javax.servlet.http.HttpServletRequest request) { return null; }
+            @Override public String map(String resourcePath) { return null; }
+            @Override public String map(javax.servlet.http.HttpServletRequest request, String resourcePath) { return null; }
+            @Override public Resource getResource(Resource base, String path) { return null; }
+            @Override public String[] getSearchPath() { return new String[0]; }
+            @Override public java.util.Iterator<Resource> listChildren(Resource parent) { return java.util.Collections.emptyIterator(); }
+            @Override public java.util.Iterator<Resource> findResources(String query, String language) { return java.util.Collections.emptyIterator(); }
+            @Override public java.util.Iterator<java.util.Map<String, Object>> queryResources(String query, String language) { return java.util.Collections.emptyIterator(); }
+            @Override public boolean hasChildren(Resource resource) { return false; }
+            @Override public ResourceResolver clone(java.util.Map<String, Object> authenticationInfo) { return null; }
+            @Override public boolean isLive() { return true; }
+            @Override public void close() {}
+            @Override public String getUserID() { return null; }
+            @Override public java.util.Iterator<String> getAttributeNames() { return java.util.Collections.emptyIterator(); }
+            @Override public Object getAttribute(String name) { return null; }
+            @Override public void delete(Resource resource) {}
+            @Override public Resource create(Resource parent, String name, java.util.Map<String, Object> properties) { return null; }
+            @Override public void revert() {}
+            @Override public void commit() {}
+            @Override public boolean hasChanges() { return false; }
+            @Override public String getParentResourceType(Resource resource) { return null; }
+            @Override public String getParentResourceType(String resourceType) { return null; }
+            @Override public boolean isResourceType(Resource resource, String resourceType) { return false; }
+            @Override public void refresh() {}
+            @Override public java.util.Map<String, Object> getPropertyMap() { return new java.util.HashMap<>(); }
+            @Override public boolean move(String srcAbsPath, String destAbsPath) throws org.apache.sling.api.resource.PersistenceException { return false; }
+        };
+    }
+    
+    /**
+     * Creates a SlingServletResolver with null execution paths (allowing all paths)
+     */
+    private SlingServletResolver createServletResolver() throws Exception {
+        SlingServletResolver resolver = new SlingServletResolver();
+        
+        // Set executionPaths to null to allow all paths
+        Field executionPathsField = SlingServletResolver.class.getDeclaredField("executionPaths");
+        executionPathsField.setAccessible(true);
+        AtomicReference<String[]> executionPaths = new AtomicReference<>();
+        executionPaths.set(null); // null means all paths are allowed
+        executionPathsField.set(resolver, executionPaths);
+        
+        return resolver;
+    }
+}
diff --git a/src/test/java/org/apache/sling/servlets/resolver/internal/PathTraversalVulnerabilityTest.java b/src/test/java/org/apache/sling/servlets/resolver/internal/PathTraversalVulnerabilityTest.java
new file mode 100644
index 0000000..e3cb8b7
--- /dev/null
+++ b/src/test/java/org/apache/sling/servlets/resolver/internal/PathTraversalVulnerabilityTest.java
@@ -0,0 +1,115 @@
+package org.apache.sling.servlets.resolver.internal;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicReference;
+
+import javax.servlet.Servlet;
+
+import org.apache.sling.api.resource.Resource;
+import org.apache.sling.api.resource.ResourceResolver;
+import org.apache.sling.api.resource.ResourceUtil;
+import org.junit.Test;
+
+/**
+ * Test for CVE-2024-23673: Path traversal vulnerability in Apache Sling Servlets Resolver
+ * This test verifies if the path traversal vulnerability exists in the current version.
+ */
+public class PathTraversalVulnerabilityTest {
+
+    /**
+     * Main method to run the test directly
+     */
+    public static void main(String[] args) {
+        try {
+            new PathTraversalVulnerabilityTest().testPathTraversalVulnerability();
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+
+    /**
+     * Test for the path traversal vulnerability.
+     * The test will exit with code 1 if the vulnerability exists,
+     * and with code 0 if it does not exist.
+     */
+    @Test
+    public void testPathTraversalVulnerability() throws Exception {
+        // Create a secret file outside the project directory
+        File secretFile = createSecretFile();
+        System.out.println("Created secret file at: " + secretFile.getAbsolutePath());
+        
+        // Create a SlingServletResolver instance
+        SlingServletResolver resolver = new SlingServletResolver();
+        
+        // Set up the resolver with reflection to bypass initialization requirements
+        Field executionPathsField = SlingServletResolver.class.getDeclaredField("executionPaths");
+        executionPathsField.setAccessible(true);
+        AtomicReference<String[]> executionPaths = new AtomicReference<>();
+        executionPaths.set(new String[]{"/apps/"});
+        executionPathsField.set(resolver, executionPaths);
+        
+        // Test multiple path formats to find one that works with the vulnerability
+        testPathFormat(resolver, executionPaths, "/apps/../etc/passwd");
+        testPathFormat(resolver, executionPaths, "/apps/../../etc/passwd");
+        testPathFormat(resolver, executionPaths, "/apps/something/../../../etc/passwd");
+        testPathFormat(resolver, executionPaths, "/apps/something/../../something/../../../etc/passwd");
+        
+        // If we get here, the vulnerability doesn't exist or our test couldn't trigger it
+        System.out.println("\nCould not trigger the vulnerability with any of the tested paths.");
+        System.out.println("This suggests the vulnerability has been fixed or our test setup is incomplete.");
+        System.exit(0);
+    }
+    
+    /**
+     * Test a specific path format for the vulnerability
+     */
+    private void testPathFormat(SlingServletResolver resolver, AtomicReference<String[]> executionPaths, String maliciousPath) {
+        System.out.println("\nTesting with malicious path: " + maliciousPath);
+        
+        try {
+            // Normalize the path as the resolver would
+            String normalizedPath = ResourceUtil.normalize(maliciousPath);
+            System.out.println("Normalized path: " + normalizedPath);
+            
+            if (normalizedPath == null) {
+                System.out.println("Path normalization returned null, skipping this path format.");
+                return;
+            }
+            
+            // Check if the path is allowed
+            boolean isAllowed = resolver.isPathAllowed(normalizedPath, executionPaths.get());
+            System.out.println("Is path allowed: " + isAllowed);
+            
+            // If the path is allowed after normalization and it's outside the allowed directory,
+            // the vulnerability exists
+            if (isAllowed && !normalizedPath.startsWith("/apps/")) {
+                System.out.println("VULNERABILITY DETECTED: Path traversal allowed access to: " + normalizedPath);
+                System.exit(1); // Vulnerability exists
+            }
+        } catch (Exception e) {
+            System.out.println("Error testing path format: " + e.getMessage());
+        }
+    }
+    
+    /**
+     * Creates a secret file outside the project directory
+     */
+    private File createSecretFile() throws IOException {
+        File secretFile = File.createTempFile("secret", ".txt");
+        secretFile.deleteOnExit();
+        
+        try (FileWriter writer = new FileWriter(secretFile)) {
+            writer.write("This is a secret file that should not be accessible");
+        }
+        
+        return secretFile;
+    }
+}
