diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 00000000..4110425d
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/ESAPI__esapi-java-legacy_CVE-2022-23457_2.2.3.1 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 00000000..8b137891
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 00000000..a94df494
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,19 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/ESAPI__esapi-java-legacy_CVE-2022-23457_2.2.3.1 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+
+# Run the test directly with Maven
+CMD ["mvn", "test", "-Dtest=PathTraversalVulnerabilityTest"]
diff --git a/src/main/java/org/owasp/esapi/reference/PathTraversalVulnerabilityTestRunner.java b/src/main/java/org/owasp/esapi/reference/PathTraversalVulnerabilityTestRunner.java
new file mode 100644
index 00000000..df5465bc
--- /dev/null
+++ b/src/main/java/org/owasp/esapi/reference/PathTraversalVulnerabilityTestRunner.java
@@ -0,0 +1,74 @@
+package org.owasp.esapi.reference;
+
+import org.owasp.esapi.ESAPI;
+import org.owasp.esapi.Validator;
+import org.owasp.esapi.errors.ValidationException;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Standalone test runner for the path traversal vulnerability test.
+ * Exits with code 1 if the vulnerability exists,
+ * and exits with code 0 if the vulnerability is fixed.
+ */
+public class PathTraversalVulnerabilityTestRunner {
+    public static void main(String[] args) {
+        try {
+            // Create a temporary directory structure for testing
+            File tempDir = new File(System.getProperty("java.io.tmpdir"), "esapi-test-parent");
+            tempDir.mkdir();
+            tempDir.deleteOnExit();
+            
+            File childDir = new File(tempDir, "child");
+            childDir.mkdir();
+            childDir.deleteOnExit();
+            
+            // Create a file in the child directory to verify we can access it
+            File testFile = new File(childDir, "test.txt");
+            testFile.createNewFile();
+            testFile.deleteOnExit();
+            
+            // Get the canonical paths
+            String parentPath = tempDir.getCanonicalPath();
+            String childPath = childDir.getCanonicalPath();
+            
+            // Create a specially crafted input that exploits the vulnerability
+            // The vulnerability is in the comparison between canonical path and input
+            // We'll create an input that has the same canonical path as childDir
+            // but doesn't match the input string directly
+            String maliciousInput = childPath;
+            
+            try {
+                Validator validator = ESAPI.validator();
+                
+                // This should throw a ValidationException if the vulnerability is fixed
+                // If vulnerable, it will return the canonical path without exception
+                String result = validator.getValidDirectoryPath("test", maliciousInput, tempDir, false);
+                
+                // If we get here without exception, the vulnerability exists
+                // We'll verify we can access files outside the intended directory
+                if (testFile.exists()) {
+                    // Vulnerability exists - test fails with exit code 1
+                    System.out.println("VULNERABILITY DETECTED: Path traversal in getValidDirectoryPath");
+                    System.exit(1);
+                }
+            } catch (ValidationException e) {
+                // If we get a ValidationException, the vulnerability is fixed
+                // The exception message should contain "does not match the canonical path"
+                if (e.getMessage().contains("does not match the canonical path")) {
+                    System.out.println("VULNERABILITY FIXED: Path traversal in getValidDirectoryPath is fixed");
+                    System.exit(0);
+                } else {
+                    // Unexpected exception - test fails
+                    System.out.println("Unexpected exception: " + e.getMessage());
+                    System.exit(1);
+                }
+            }
+        } catch (IOException e) {
+            System.out.println("Error setting up test: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+}
diff --git a/src/test/java/org/owasp/esapi/reference/PathTraversalVulnerabilityTest.java b/src/test/java/org/owasp/esapi/reference/PathTraversalVulnerabilityTest.java
new file mode 100644
index 00000000..d2e8eec3
--- /dev/null
+++ b/src/test/java/org/owasp/esapi/reference/PathTraversalVulnerabilityTest.java
@@ -0,0 +1,101 @@
+package org.owasp.esapi.reference;
+
+import org.junit.Test;
+import org.owasp.esapi.ESAPI;
+import org.owasp.esapi.Validator;
+import org.owasp.esapi.errors.ValidationException;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Test for path traversal vulnerability in DefaultValidator.getValidDirectoryPath()
+ * CVE-2022-23457
+ */
+public class PathTraversalVulnerabilityTest {
+
+    /**
+     * Test for path traversal vulnerability in DefaultValidator.getValidDirectoryPath()
+     * This test will fail if the vulnerability exists and pass if it's fixed.
+     */
+    @Test
+    public void testPathTraversalVulnerability() throws IOException {
+        // Create a temporary directory structure for testing
+        File tempDir = new File(System.getProperty("java.io.tmpdir"), "esapi-test-parent");
+        tempDir.mkdir();
+        tempDir.deleteOnExit();
+        
+        File childDir = new File(tempDir, "child");
+        childDir.mkdir();
+        childDir.deleteOnExit();
+        
+        // Create a file in the child directory to verify we can access it
+        File testFile = new File(childDir, "test.txt");
+        testFile.createNewFile();
+        testFile.deleteOnExit();
+        
+        // Get the canonical paths
+        String parentPath = tempDir.getCanonicalPath();
+        String childPath = childDir.getCanonicalPath();
+        
+        // Create a specially crafted input that exploits the vulnerability
+        // The vulnerability is in the comparison between canonical path and input
+        // We'll create an input that has the same canonical path as childDir
+        // but doesn't match the input string directly
+        String maliciousInput = childPath + File.separator + "." + File.separator;
+        
+        boolean vulnerabilityExists = false;
+        
+        try {
+            Validator validator = ESAPI.validator();
+            
+            // This should throw a ValidationException if the vulnerability is fixed
+            // If vulnerable, it will return the canonical path without exception
+            String result = validator.getValidDirectoryPath("test", maliciousInput, tempDir, false);
+            
+            // If we get here without exception, the vulnerability exists
+            System.out.println("VULNERABILITY DETECTED: Path traversal in getValidDirectoryPath");
+            System.out.println("Result: " + result);
+            vulnerabilityExists = true;
+        } catch (ValidationException e) {
+            // If we get a ValidationException with message about canonical path not matching,
+            // the vulnerability is fixed
+            if (e.getMessage().contains("does not match the canonical path") || 
+                e.getMessage().contains("Invalid directory name")) {
+                System.out.println("VULNERABILITY FIXED: Path traversal in getValidDirectoryPath is fixed");
+                System.out.println("Exception: " + e.getMessage());
+            } else {
+                // Unexpected exception - rethrow
+                System.out.println("Unexpected exception: " + e.getMessage());
+                throw new RuntimeException(e);
+            }
+        }
+        
+        // The test should fail if the vulnerability exists
+        if (vulnerabilityExists) {
+            throw new AssertionError("Path traversal vulnerability exists: getValidDirectoryPath accepted a path that doesn't match the input string");
+        }
+    }
+    
+    /**
+     * Main method to run the test directly
+     */
+    public static void main(String[] args) {
+        try {
+            PathTraversalVulnerabilityTest test = new PathTraversalVulnerabilityTest();
+            test.testPathTraversalVulnerability();
+            // If we get here, the test passed (vulnerability is fixed)
+            System.out.println("TEST PASSED: Vulnerability is fixed");
+            System.exit(0);
+        } catch (AssertionError e) {
+            // Test failed - vulnerability exists
+            System.out.println("TEST FAILED: " + e.getMessage());
+            System.exit(1);
+        } catch (Exception e) {
+            // Unexpected error
+            System.out.println("TEST ERROR: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(2);
+        }
+    }
+}
