diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 0000000..9885aba
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/jenkinsci__script-security-plugin_CVE-2023-24422_1228.vd93135a_2fb_25 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..695d330
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,29 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/jenkinsci__script-security-plugin_CVE-2023-24422_1228.vd93135a_2fb_25 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+
+# Build the project
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Compile the test class
+RUN mvn test-compile
+
+# Create a simple script to run the test
+RUN echo '#!/bin/bash\njava -cp target/classes:target/test-classes:~/.m2/repository/junit/junit/4.13.2/junit-4.13.2.jar:~/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar:$(mvn dependency:build-classpath -q -Dmdep.outputFile=/dev/stdout) org.junit.runner.JUnitCore org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.MapConstructorBypassTest' > /project/run_test.sh
+RUN chmod +x /project/run_test.sh
+
+# Run the test
+CMD ["/project/run_test.sh"]
\ No newline at end of file
diff --git a/src/main/java/TestMapConstructorBypass.java b/src/main/java/TestMapConstructorBypass.java
new file mode 100644
index 0000000..5ea0cd2
--- /dev/null
+++ b/src/main/java/TestMapConstructorBypass.java
@@ -0,0 +1,67 @@
+import groovy.lang.Binding;
+import groovy.lang.GroovyShell;
+import org.codehaus.groovy.control.CompilerConfiguration;
+import org.jenkinsci.plugins.scriptsecurity.sandbox.RejectedAccessException;
+import org.jenkinsci.plugins.scriptsecurity.sandbox.Whitelist;
+import org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.GroovySandbox;
+import org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SandboxInterceptor;
+import org.jenkinsci.plugins.scriptsecurity.sandbox.whitelists.StaticWhitelist;
+
+import java.io.File;
+
+/**
+ * Simple program to test for CVE-2023-24422 vulnerability
+ */
+public class TestMapConstructorBypass {
+
+    public static void main(String[] args) {
+        System.out.println("Starting vulnerability test");
+        
+        // Create a marker file to check if command execution succeeded
+        File markerFile = new File("/tmp/sandbox-bypass-marker");
+        if (markerFile.exists()) {
+            markerFile.delete();
+            System.out.println("Deleted existing marker file");
+        }
+        
+        // The script that attempts to exploit the vulnerability
+        String script = 
+            "// Attempt to bypass sandbox using map constructor\n" +
+            "def pb = new java.lang.ProcessBuilder([command: 'touch /tmp/sandbox-bypass-marker']);\n" +
+            "// Try to execute the command\n" +
+            "pb.command(pb.command().get('command').split(' ')).start();\n" +
+            "return 'Script executed';";
+        
+        System.out.println("Script to execute:\n" + script);
+        
+        try {
+            System.out.println("Creating sandbox environment");
+            Whitelist whitelist = StaticWhitelist.builtIn();
+            
+            // Execute the script in a sandbox
+            System.out.println("Executing script in sandbox");
+            Object result = GroovySandbox.run(script, whitelist);
+            System.out.println("Script execution result: " + result);
+            
+            // If we get here without exception, check if the command was executed
+            if (markerFile.exists()) {
+                // Vulnerability exists - command was executed
+                System.out.println("VULNERABILITY DETECTED: Command execution succeeded");
+                System.exit(1); // Test fails if vulnerability exists
+            } else {
+                // Script ran but command didn't execute
+                System.out.println("Script ran but command didn't execute");
+                System.exit(0); // Test passes
+            }
+        } catch (RejectedAccessException e) {
+            // This is expected if the vulnerability is fixed
+            System.out.println("SECURE: Sandbox properly rejected access: " + e.getMessage());
+            System.exit(0); // Test passes if access is rejected
+        } catch (Exception e) {
+            // Unexpected exception
+            System.out.println("Unexpected exception: " + e);
+            e.printStackTrace();
+            System.exit(1); // Test fails on unexpected exceptions
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/VulnerabilityTester.java b/src/main/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/VulnerabilityTester.java
new file mode 100644
index 0000000..7305131
--- /dev/null
+++ b/src/main/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/VulnerabilityTester.java
@@ -0,0 +1,72 @@
+package org.jenkinsci.plugins.scriptsecurity.sandbox.groovy;
+
+import groovy.lang.Binding;
+import org.jenkinsci.plugins.scriptsecurity.sandbox.RejectedAccessException;
+import org.jenkinsci.plugins.scriptsecurity.sandbox.Whitelist;
+import org.jenkinsci.plugins.scriptsecurity.sandbox.whitelists.StaticWhitelist;
+
+import java.io.File;
+
+/**
+ * Standalone program to test for CVE-2023-24422 vulnerability
+ */
+public class VulnerabilityTester {
+
+    public static void main(String[] args) {
+        System.out.println("Starting vulnerability test");
+        
+        // Create a marker file to check if command execution succeeded
+        File markerFile = new File("/tmp/sandbox-bypass-marker");
+        if (markerFile.exists()) {
+            markerFile.delete();
+            System.out.println("Deleted existing marker file");
+        }
+        
+        // The command to execute if sandbox is bypassed
+        String command = "touch /tmp/sandbox-bypass-marker";
+        System.out.println("Command to execute: " + command);
+        
+        // The script that attempts to exploit the vulnerability
+        String script = 
+            "// Attempt to bypass sandbox using map constructor\n" +
+            "def rt = new java.util.HashMap([command: '" + command + "']);\n" +
+            "println 'Created HashMap: ' + rt\n" +
+            "println 'Command value: ' + rt.command\n" +
+            "return 'Script executed';";
+        
+        System.out.println("Script to execute:\n" + script);
+        
+        try {
+            System.out.println("Creating sandbox environment");
+            Whitelist whitelist = StaticWhitelist.builtIn();
+            
+            // Create a binding for the script
+            Binding binding = new Binding();
+            
+            // Execute the script in a sandbox
+            System.out.println("Executing script in sandbox");
+            Object result = GroovySandbox.run(script, whitelist, binding);
+            System.out.println("Script execution result: " + result);
+            
+            // If we get here without exception, check if the command was executed
+            if (markerFile.exists()) {
+                // Vulnerability exists - command was executed
+                System.out.println("VULNERABILITY DETECTED: Command execution succeeded");
+                System.exit(1); // Test fails if vulnerability exists
+            } else {
+                // Script ran but command didn't execute
+                System.out.println("Script ran but command didn't execute");
+                System.exit(0); // Test passes
+            }
+        } catch (RejectedAccessException e) {
+            // This is expected if the vulnerability is fixed
+            System.out.println("SECURE: Sandbox properly rejected access: " + e.getMessage());
+            System.exit(0); // Test passes if access is rejected
+        } catch (Exception e) {
+            // Unexpected exception
+            System.out.println("Unexpected exception: " + e);
+            e.printStackTrace();
+            System.exit(1); // Test fails on unexpected exceptions
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/MapConstructorBypassTest.java b/src/test/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/MapConstructorBypassTest.java
new file mode 100644
index 0000000..f9774b8
--- /dev/null
+++ b/src/test/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/MapConstructorBypassTest.java
@@ -0,0 +1,40 @@
+package org.jenkinsci.plugins.scriptsecurity.sandbox.groovy;
+
+import org.jenkinsci.plugins.scriptsecurity.sandbox.RejectedAccessException;
+import org.jenkinsci.plugins.scriptsecurity.sandbox.whitelists.StaticWhitelist;
+import org.junit.Test;
+
+/**
+ * Test for CVE-2023-24422: Sandbox bypass vulnerability involving map constructors
+ */
+public class MapConstructorBypassTest {
+
+    @Test
+    public void testMapConstructorBypass() {
+        // The script that attempts to exploit the vulnerability
+        String script = 
+            "// Attempt to bypass sandbox using map constructor\n" +
+            "def rt = new java.lang.ProcessBuilder([command: 'touch /tmp/sandbox-bypass-marker']);\n" +
+            "// Try to execute the command\n" +
+            "rt.command(rt.command().get('command').split(' ')).start();\n" +
+            "return 'Script executed';";
+        
+        try {
+            // Execute the script in a sandbox
+            GroovySandbox.run(script, StaticWhitelist.builtIn());
+            
+            // If we get here without exception, the vulnerability exists
+            System.out.println("VULNERABILITY DETECTED: Sandbox bypass succeeded");
+            System.exit(1); // Test fails if vulnerability exists
+        } catch (RejectedAccessException e) {
+            // This is expected if the vulnerability is fixed
+            System.out.println("SECURE: Sandbox properly rejected access: " + e.getMessage());
+            System.exit(0); // Test passes if access is rejected
+        } catch (Exception e) {
+            // Unexpected exception
+            System.out.println("Unexpected exception: " + e);
+            e.printStackTrace();
+            System.exit(1); // Test fails on unexpected exceptions
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/MapConstructorSandboxBypassTest.java b/src/test/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/MapConstructorSandboxBypassTest.java
new file mode 100644
index 0000000..a4cb073
--- /dev/null
+++ b/src/test/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/MapConstructorSandboxBypassTest.java
@@ -0,0 +1,94 @@
+package org.jenkinsci.plugins.scriptsecurity.sandbox.groovy;
+
+import groovy.lang.Binding;
+import groovy.lang.GroovyShell;
+import org.jenkinsci.plugins.scriptsecurity.sandbox.RejectedAccessException;
+import org.jenkinsci.plugins.scriptsecurity.sandbox.Whitelist;
+import org.jenkinsci.plugins.scriptsecurity.sandbox.whitelists.StaticWhitelist;
+import org.junit.Test;
+import java.io.File;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Test for CVE-2023-24422: Sandbox bypass vulnerability involving map constructors
+ */
+public class MapConstructorSandboxBypassTest {
+
+    /**
+     * This test attempts to exploit the vulnerability by creating a Runtime
+     * using a map constructor and then executing a command.
+     * If the vulnerability exists, the test will create a file as evidence of command execution.
+     * If the vulnerability is fixed, a RejectedAccessException should be thrown.
+     */
+    @Test
+    public void testMapConstructorSandboxBypass() throws Exception {
+        System.out.println("Starting MapConstructorSandboxBypassTest");
+        
+        // Create a marker file to check if command execution succeeded
+        File markerFile = new File("/tmp/sandbox-bypass-marker");
+        if (markerFile.exists()) {
+            markerFile.delete();
+            System.out.println("Deleted existing marker file");
+        }
+        
+        // The command to execute if sandbox is bypassed
+        String command = "touch /tmp/sandbox-bypass-marker";
+        System.out.println("Command to execute: " + command);
+        
+        // The script that attempts to exploit the vulnerability
+        String script = 
+            "import java.io.File;\n" +
+            "import java.util.HashMap;\n" +
+            "\n" +
+            "// Attempt to bypass sandbox using map constructor\n" +
+            "def rt = new java.lang.Runtime([exec: '" + command + "']);\n" +
+            "\n" +
+            "// Try to execute the command\n" +
+            "try {\n" +
+            "    rt.exec(rt.exec);\n" +
+            "    println 'Command executed'\n" +
+            "} catch (Exception e) {\n" +
+            "    println 'Exception: ' + e\n" +
+            "}\n" +
+            "\n" +
+            "return 'Script executed';";
+        
+        System.out.println("Script to execute:\n" + script);
+        
+        try {
+            System.out.println("Creating sandbox environment");
+            Whitelist whitelist = StaticWhitelist.builtIn();
+            
+            // Create a binding for the script
+            Binding binding = new Binding();
+            
+            // Execute the script in a sandbox
+            System.out.println("Executing script in sandbox");
+            Object result = GroovySandbox.run(script, whitelist, binding);
+            System.out.println("Script execution result: " + result);
+            
+            // If we get here without exception, check if the command was executed
+            if (markerFile.exists()) {
+                // Vulnerability exists - command was executed
+                System.out.println("VULNERABILITY DETECTED: Command execution succeeded");
+                System.exit(1); // Test fails if vulnerability exists
+            } else {
+                // Script ran but command didn't execute
+                System.out.println("Script ran but command didn't execute");
+                System.exit(0); // Test passes
+            }
+        } catch (RejectedAccessException e) {
+            // This is expected if the vulnerability is fixed
+            System.out.println("SECURE: Sandbox properly rejected access: " + e.getMessage());
+            System.exit(0); // Test passes if access is rejected
+        } catch (Exception e) {
+            // Unexpected exception
+            System.out.println("Unexpected exception: " + e);
+            e.printStackTrace();
+            System.exit(1); // Test fails on unexpected exceptions
+        }
+    }
+}
\ No newline at end of file
