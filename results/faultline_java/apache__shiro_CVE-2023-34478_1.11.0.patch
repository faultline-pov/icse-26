diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 00000000..eb0e5c17
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/apache__shiro_CVE-2023-34478_1.11.0 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 00000000..4ac87632
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1,19 @@
+diff --git a/Dockerfile.vuln b/Dockerfile.vuln
+index 67cb2b189e4cc61d3adad4c31a386b14..51c7c17bd9a613cc51c9ff27e2a6c6ac 100644
+--- a/Dockerfile.vuln
++++ b/Dockerfile.vuln
+@@ -4,10 +4,10 @@
+ RUN apt install -y curl unzip wget git build-essential
+ RUN mkdir -p /java-env
+ ENV WORKSPACE_BASE="/"
+-COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+-COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+-ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+-ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
++COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
++COPY ./java-env/apache-maven-3.9.10 $WORKSPACE_BASE/java-env/apache-maven-3.9.10
++ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.9.10/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
++ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ ENV PATH=$PATH:$JAVA_HOME/bin
+ COPY ./project-sources/apache__shiro_CVE-2023-34478_1.11.0 /project
+ COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 00000000..5cb0fd9e
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,22 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/apache__shiro_CVE-2023-34478_1.11.0 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+
+# Build and run the path traversal test
+WORKDIR /project/test-path-traversal
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+CMD ["mvn", "exec:java"]
\ No newline at end of file
diff --git a/test-path-traversal/pom.xml b/test-path-traversal/pom.xml
new file mode 100644
index 00000000..edc9189b
--- /dev/null
+++ b/test-path-traversal/pom.xml
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>org.apache.shiro.test</groupId>
+    <artifactId>path-traversal-test</artifactId>
+    <version>1.0-SNAPSHOT</version>
+
+    <properties>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <shiro.version>1.11.0</shiro.version>
+    </properties>
+
+    <dependencies>
+        <!-- Apache Shiro -->
+        <dependency>
+            <groupId>org.apache.shiro</groupId>
+            <artifactId>shiro-core</artifactId>
+            <version>${shiro.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.shiro</groupId>
+            <artifactId>shiro-web</artifactId>
+            <version>${shiro.version}</version>
+        </dependency>
+        <!-- Servlet API -->
+        <dependency>
+            <groupId>javax.servlet</groupId>
+            <artifactId>javax.servlet-api</artifactId>
+            <version>3.1.0</version>
+            <scope>provided</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>3.8.1</version>
+                <configuration>
+                    <source>${maven.compiler.source}</source>
+                    <target>${maven.compiler.target}</target>
+                </configuration>
+            </plugin>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>exec-maven-plugin</artifactId>
+                <version>3.0.0</version>
+                <configuration>
+                    <mainClass>org.apache.shiro.test.PathTraversalTest</mainClass>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+</project>
\ No newline at end of file
diff --git a/test-path-traversal/src/main/java/org/apache/shiro/test/PathTraversalTest.java b/test-path-traversal/src/main/java/org/apache/shiro/test/PathTraversalTest.java
new file mode 100644
index 00000000..ba9ab8e7
--- /dev/null
+++ b/test-path-traversal/src/main/java/org/apache/shiro/test/PathTraversalTest.java
@@ -0,0 +1,270 @@
+package org.apache.shiro.test;
+
+import org.apache.shiro.util.AntPathMatcher;
+import org.apache.shiro.util.PatternMatcher;
+import org.apache.shiro.web.filter.PathMatchingFilter;
+import org.apache.shiro.web.util.WebUtils;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import java.lang.reflect.Method;
+
+public class PathTraversalTest {
+
+    public static void main(String[] args) {
+        try {
+            // Test for path traversal vulnerability
+            boolean isVulnerable = testPathTraversal();
+            
+            if (isVulnerable) {
+                System.out.println("VULNERABILITY DETECTED: Path traversal vulnerability exists!");
+                System.exit(1); // Exit with non-zero code if vulnerable
+            } else {
+                System.out.println("SECURE: No path traversal vulnerability detected.");
+                System.exit(0); // Exit with zero code if not vulnerable
+            }
+            
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+
+    private static boolean testPathTraversal() throws Exception {
+        // Create a mock PathMatchingFilter to test the vulnerability
+        TestPathMatchingFilter filter = new TestPathMatchingFilter();
+        filter.processPathConfig("/protected/**", null);
+        
+        // Test normal path (should match)
+        MockHttpServletRequest normalRequest = new MockHttpServletRequest();
+        normalRequest.setRequestURI("/context/protected/resource");
+        normalRequest.setContextPath("/context");
+        boolean normalMatches = filter.pathsMatch("/protected/**", normalRequest);
+        System.out.println("Normal path matches: " + normalMatches);
+        
+        // Test various path traversal patterns
+        String[] pathTraversalPatterns = {
+            "/protected;/resource",                // Semicolon bypass
+            "/protected/..;/protected/resource",   // Path traversal with semicolon
+            "/protected\\resource",               // Backslash bypass
+            "/protected/./resource",               // Current directory bypass
+            "/protected//resource",                // Double slash bypass
+            "/protected/%2e/resource",             // URL encoded dot
+            "/protected/resource/",                // Trailing slash
+            "/protected%2fresource"                // URL encoded slash
+        };
+        
+        for (String pattern : pathTraversalPatterns) {
+            MockHttpServletRequest request = new MockHttpServletRequest();
+            request.setRequestURI("/context" + pattern);
+            request.setContextPath("/context");
+            
+            // Get the normalized path using WebUtils.getPathWithinApplication
+            String normalizedPath = WebUtils.getPathWithinApplication(request);
+            System.out.println("Original path: " + pattern);
+            System.out.println("Normalized path: " + normalizedPath);
+            
+            // Check if the path matches after normalization
+            boolean matches = filter.pathsMatch("/protected/**", request);
+            System.out.println("Path matches after normalization: " + matches);
+            
+            // Now test if we can create a path that doesn't match but should
+            // This would indicate a vulnerability
+            if (!matches && normalizedPath.startsWith("/protected/")) {
+                System.out.println("Potential vulnerability: Path starts with /protected/ but doesn't match pattern");
+                return true;
+            }
+            
+            // Or test if we can create a path that matches but shouldn't
+            // This would also indicate a vulnerability
+            if (matches && !normalizedPath.startsWith("/protected/")) {
+                System.out.println("Potential vulnerability: Path doesn't start with /protected/ but matches pattern");
+                return true;
+            }
+        }
+        
+        // Test the specific vulnerability: path traversal with non-normalized paths
+        MockHttpServletRequest vulnerableRequest = new MockHttpServletRequest();
+        vulnerableRequest.setServletPath("/protected");
+        vulnerableRequest.setPathInfo(";/resource");
+        vulnerableRequest.setContextPath("/context");
+        
+        // Get the path directly without normalization
+        String rawPath = vulnerableRequest.getServletPath() + vulnerableRequest.getPathInfo();
+        System.out.println("Raw path: " + rawPath);
+        
+        // Get the normalized path
+        String normalizedPath = WebUtils.getPathWithinApplication(vulnerableRequest);
+        System.out.println("Normalized path: " + normalizedPath);
+        
+        // Check if the path matches after normalization
+        boolean matches = filter.pathsMatch("/protected/**", vulnerableRequest);
+        System.out.println("Path matches after normalization: " + matches);
+        
+        // Check if the raw path would be interpreted differently by a web server
+        // In a vulnerable version, the semicolon would be treated as a path separator
+        // but Shiro's normalization might not handle it correctly
+        if (normalizedPath.equals("/protected/resource") && rawPath.equals("/protected;/resource")) {
+            // This is a potential vulnerability - the paths are interpreted differently
+            PatternMatcher pathMatcher = new AntPathMatcher();
+            boolean rawMatches = pathMatcher.matches("/protected/**", rawPath);
+            boolean normalizedMatches = pathMatcher.matches("/protected/**", normalizedPath);
+            
+            System.out.println("Raw path matches pattern: " + rawMatches);
+            System.out.println("Normalized path matches pattern: " + normalizedMatches);
+            
+            if (rawMatches != normalizedMatches) {
+                System.out.println("Vulnerability detected: Raw and normalized paths are treated differently");
+                return true;
+            }
+        }
+        
+        // Test the specific vulnerability with the removeSemicolon method
+        try {
+            // Use reflection to access the removeSemicolon method
+            Method removeSemicolonMethod = WebUtils.class.getDeclaredMethod("removeSemicolon", String.class);
+            removeSemicolonMethod.setAccessible(true);
+            
+            String pathWithSemicolon = "/protected;/resource";
+            String pathWithoutSemicolon = (String) removeSemicolonMethod.invoke(null, pathWithSemicolon);
+            
+            System.out.println("Path with semicolon: " + pathWithSemicolon);
+            System.out.println("Path after removeSemicolon: " + pathWithoutSemicolon);
+            
+            // In a vulnerable version, the semicolon might not be properly handled
+            if (!pathWithoutSemicolon.equals("/protected/resource")) {
+                System.out.println("Vulnerability detected: Semicolon not properly removed");
+                return true;
+            }
+        } catch (Exception e) {
+            System.out.println("Could not test removeSemicolon method: " + e.getMessage());
+        }
+        
+        return false; // No vulnerability detected
+    }
+    
+    // A simple implementation of PathMatchingFilter for testing
+    private static class TestPathMatchingFilter extends PathMatchingFilter {
+        @Override
+        protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) {
+            return true;
+        }
+    }
+    
+    // A simple mock implementation of HttpServletRequest
+    private static class MockHttpServletRequest implements HttpServletRequest {
+        private String requestURI;
+        private String contextPath = "";
+        private String servletPath = "";
+        private String pathInfo = "";
+        private StringBuffer requestURL = new StringBuffer();
+        
+        public void setRequestURI(String requestURI) {
+            this.requestURI = requestURI;
+        }
+        
+        public void setContextPath(String contextPath) {
+            this.contextPath = contextPath;
+        }
+        
+        public void setServletPath(String servletPath) {
+            this.servletPath = servletPath;
+        }
+        
+        public void setPathInfo(String pathInfo) {
+            this.pathInfo = pathInfo;
+        }
+        
+        @Override
+        public String getRequestURI() {
+            return requestURI;
+        }
+        
+        @Override
+        public StringBuffer getRequestURL() {
+            return requestURL;
+        }
+        
+        @Override
+        public String getContextPath() {
+            return contextPath;
+        }
+        
+        @Override
+        public String getServletPath() {
+            return servletPath;
+        }
+        
+        @Override
+        public String getPathInfo() {
+            return pathInfo;
+        }
+        
+        // Implement other methods with default implementations
+        @Override public String getAuthType() { return null; }
+        @Override public javax.servlet.http.Cookie[] getCookies() { return new javax.servlet.http.Cookie[0]; }
+        @Override public long getDateHeader(String name) { return 0; }
+        @Override public String getHeader(String name) { return null; }
+        @Override public java.util.Enumeration<String> getHeaderNames() { return new java.util.Vector<String>().elements(); }
+        @Override public java.util.Enumeration<String> getHeaders(String name) { return new java.util.Vector<String>().elements(); }
+        @Override public int getIntHeader(String name) { return 0; }
+        @Override public String getMethod() { return "GET"; }
+        @Override public String getPathTranslated() { return null; }
+        @Override public String getQueryString() { return null; }
+        @Override public String getRemoteUser() { return null; }
+        @Override public String getRequestedSessionId() { return null; }
+        @Override public javax.servlet.http.HttpSession getSession() { return null; }
+        @Override public javax.servlet.http.HttpSession getSession(boolean create) { return null; }
+        @Override public java.security.Principal getUserPrincipal() { return null; }
+        @Override public boolean isRequestedSessionIdFromCookie() { return false; }
+        @Override public boolean isRequestedSessionIdFromURL() { return false; }
+        @Override public boolean isRequestedSessionIdFromUrl() { return false; }
+        @Override public boolean isRequestedSessionIdValid() { return false; }
+        @Override public boolean isUserInRole(String role) { return false; }
+        @Override public Object getAttribute(String name) { return null; }
+        @Override public java.util.Enumeration<String> getAttributeNames() { return new java.util.Vector<String>().elements(); }
+        @Override public String getCharacterEncoding() { return null; }
+        @Override public int getContentLength() { return 0; }
+        @Override public String getContentType() { return null; }
+        @Override public javax.servlet.ServletInputStream getInputStream() { return null; }
+        @Override public String getLocalAddr() { return null; }
+        @Override public String getLocalName() { return null; }
+        @Override public int getLocalPort() { return 0; }
+        @Override public java.util.Locale getLocale() { return null; }
+        @Override public java.util.Enumeration<java.util.Locale> getLocales() { return new java.util.Vector<java.util.Locale>().elements(); }
+        @Override public String getParameter(String name) { return null; }
+        @Override public java.util.Map<String, String[]> getParameterMap() { return new java.util.HashMap<>(); }
+        @Override public java.util.Enumeration<String> getParameterNames() { return new java.util.Vector<String>().elements(); }
+        @Override public String[] getParameterValues(String name) { return new String[0]; }
+        @Override public String getProtocol() { return null; }
+        @Override public java.io.BufferedReader getReader() { return null; }
+        @Override public String getRealPath(String path) { return null; }
+        @Override public String getRemoteAddr() { return null; }
+        @Override public String getRemoteHost() { return null; }
+        @Override public int getRemotePort() { return 0; }
+        @Override public javax.servlet.RequestDispatcher getRequestDispatcher(String path) { return null; }
+        @Override public String getScheme() { return null; }
+        @Override public String getServerName() { return null; }
+        @Override public int getServerPort() { return 0; }
+        @Override public boolean isSecure() { return false; }
+        @Override public void removeAttribute(String name) {}
+        @Override public void setAttribute(String name, Object o) {}
+        @Override public void setCharacterEncoding(String env) {}
+        @Override public javax.servlet.DispatcherType getDispatcherType() { return null; }
+        @Override public javax.servlet.AsyncContext getAsyncContext() { return null; }
+        @Override public boolean isAsyncStarted() { return false; }
+        @Override public boolean isAsyncSupported() { return false; }
+        @Override public javax.servlet.AsyncContext startAsync() { return null; }
+        @Override public javax.servlet.AsyncContext startAsync(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) { return null; }
+        @Override public javax.servlet.ServletContext getServletContext() { return null; }
+        @Override public long getContentLengthLong() { return 0; }
+        @Override public java.util.Collection<javax.servlet.http.Part> getParts() { return null; }
+        @Override public javax.servlet.http.Part getPart(String name) { return null; }
+        @Override public <T extends javax.servlet.http.HttpUpgradeHandler> T upgrade(Class<T> handlerClass) { return null; }
+        @Override public String changeSessionId() { return null; }
+        @Override public boolean authenticate(javax.servlet.http.HttpServletResponse response) { return false; }
+        @Override public void login(String username, String password) {}
+        @Override public void logout() {}
+    }
+}
\ No newline at end of file
diff --git a/test-path-traversal/src/main/webapp/WEB-INF/shiro.ini b/test-path-traversal/src/main/webapp/WEB-INF/shiro.ini
new file mode 100644
index 00000000..e71ced92
--- /dev/null
+++ b/test-path-traversal/src/main/webapp/WEB-INF/shiro.ini
@@ -0,0 +1,13 @@
+[main]
+shiro.loginUrl = /login.jsp
+
+[users]
+admin = password,admin
+
+[roles]
+admin = *
+
+[urls]
+/login.jsp = authc
+/logout = logout
+/protected/** = authc
diff --git a/test-path-traversal/src/main/webapp/WEB-INF/web.xml b/test-path-traversal/src/main/webapp/WEB-INF/web.xml
new file mode 100644
index 00000000..75802e9d
--- /dev/null
+++ b/test-path-traversal/src/main/webapp/WEB-INF/web.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
+         version="3.1">
+
+    <listener>
+        <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>
+    </listener>
+
+    <filter>
+        <filter-name>ShiroFilter</filter-name>
+        <filter-class>org.apache.shiro.web.servlet.ShiroFilter</filter-class>
+    </filter>
+
+    <filter-mapping>
+        <filter-name>ShiroFilter</filter-name>
+        <url-pattern>/*</url-pattern>
+    </filter-mapping>
+
+    <welcome-file-list>
+        <welcome-file>index.jsp</welcome-file>
+    </welcome-file-list>
+
+</web-app>
\ No newline at end of file
diff --git a/test-path-traversal/src/main/webapp/index.jsp b/test-path-traversal/src/main/webapp/index.jsp
new file mode 100644
index 00000000..683e8973
--- /dev/null
+++ b/test-path-traversal/src/main/webapp/index.jsp
@@ -0,0 +1,10 @@
+<%@ page contentType="text/html;charset=UTF-8" language="java" %>
+<html>
+<head>
+    <title>Home</title>
+</head>
+<body>
+    <h1>Home Page</h1>
+    <p>This is the home page. You can access the <a href="protected/secret.jsp">protected resource</a>.</p>
+</body>
+</html>
\ No newline at end of file
diff --git a/test-path-traversal/src/main/webapp/login.jsp b/test-path-traversal/src/main/webapp/login.jsp
new file mode 100644
index 00000000..9c7eff7a
--- /dev/null
+++ b/test-path-traversal/src/main/webapp/login.jsp
@@ -0,0 +1,16 @@
+<%@ page contentType="text/html;charset=UTF-8" language="java" %>
+<html>
+<head>
+    <title>Login</title>
+</head>
+<body>
+    <h1>Login</h1>
+    <form action="" method="post">
+        <label for="username">Username:</label>
+        <input type="text" id="username" name="username"><br><br>
+        <label for="password">Password:</label>
+        <input type="password" id="password" name="password"><br><br>
+        <input type="submit" value="Login">
+    </form>
+</body>
+</html>
\ No newline at end of file
diff --git a/test-path-traversal/src/main/webapp/protected/secret.jsp b/test-path-traversal/src/main/webapp/protected/secret.jsp
new file mode 100644
index 00000000..0c57d649
--- /dev/null
+++ b/test-path-traversal/src/main/webapp/protected/secret.jsp
@@ -0,0 +1,10 @@
+<%@ page contentType="text/html;charset=UTF-8" language="java" %>
+<html>
+<head>
+    <title>Protected Resource</title>
+</head>
+<body>
+    <h1>This is a protected resource</h1>
+    <p>If you can see this, you have successfully authenticated or bypassed authentication.</p>
+</body>
+</html>
\ No newline at end of file
diff --git a/test-path-traversal/src/test/java/org/apache/shiro/test/PathTraversalTest.java b/test-path-traversal/src/test/java/org/apache/shiro/test/PathTraversalTest.java
new file mode 100644
index 00000000..ba9ab8e7
--- /dev/null
+++ b/test-path-traversal/src/test/java/org/apache/shiro/test/PathTraversalTest.java
@@ -0,0 +1,270 @@
+package org.apache.shiro.test;
+
+import org.apache.shiro.util.AntPathMatcher;
+import org.apache.shiro.util.PatternMatcher;
+import org.apache.shiro.web.filter.PathMatchingFilter;
+import org.apache.shiro.web.util.WebUtils;
+
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import java.lang.reflect.Method;
+
+public class PathTraversalTest {
+
+    public static void main(String[] args) {
+        try {
+            // Test for path traversal vulnerability
+            boolean isVulnerable = testPathTraversal();
+            
+            if (isVulnerable) {
+                System.out.println("VULNERABILITY DETECTED: Path traversal vulnerability exists!");
+                System.exit(1); // Exit with non-zero code if vulnerable
+            } else {
+                System.out.println("SECURE: No path traversal vulnerability detected.");
+                System.exit(0); // Exit with zero code if not vulnerable
+            }
+            
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+
+    private static boolean testPathTraversal() throws Exception {
+        // Create a mock PathMatchingFilter to test the vulnerability
+        TestPathMatchingFilter filter = new TestPathMatchingFilter();
+        filter.processPathConfig("/protected/**", null);
+        
+        // Test normal path (should match)
+        MockHttpServletRequest normalRequest = new MockHttpServletRequest();
+        normalRequest.setRequestURI("/context/protected/resource");
+        normalRequest.setContextPath("/context");
+        boolean normalMatches = filter.pathsMatch("/protected/**", normalRequest);
+        System.out.println("Normal path matches: " + normalMatches);
+        
+        // Test various path traversal patterns
+        String[] pathTraversalPatterns = {
+            "/protected;/resource",                // Semicolon bypass
+            "/protected/..;/protected/resource",   // Path traversal with semicolon
+            "/protected\\resource",               // Backslash bypass
+            "/protected/./resource",               // Current directory bypass
+            "/protected//resource",                // Double slash bypass
+            "/protected/%2e/resource",             // URL encoded dot
+            "/protected/resource/",                // Trailing slash
+            "/protected%2fresource"                // URL encoded slash
+        };
+        
+        for (String pattern : pathTraversalPatterns) {
+            MockHttpServletRequest request = new MockHttpServletRequest();
+            request.setRequestURI("/context" + pattern);
+            request.setContextPath("/context");
+            
+            // Get the normalized path using WebUtils.getPathWithinApplication
+            String normalizedPath = WebUtils.getPathWithinApplication(request);
+            System.out.println("Original path: " + pattern);
+            System.out.println("Normalized path: " + normalizedPath);
+            
+            // Check if the path matches after normalization
+            boolean matches = filter.pathsMatch("/protected/**", request);
+            System.out.println("Path matches after normalization: " + matches);
+            
+            // Now test if we can create a path that doesn't match but should
+            // This would indicate a vulnerability
+            if (!matches && normalizedPath.startsWith("/protected/")) {
+                System.out.println("Potential vulnerability: Path starts with /protected/ but doesn't match pattern");
+                return true;
+            }
+            
+            // Or test if we can create a path that matches but shouldn't
+            // This would also indicate a vulnerability
+            if (matches && !normalizedPath.startsWith("/protected/")) {
+                System.out.println("Potential vulnerability: Path doesn't start with /protected/ but matches pattern");
+                return true;
+            }
+        }
+        
+        // Test the specific vulnerability: path traversal with non-normalized paths
+        MockHttpServletRequest vulnerableRequest = new MockHttpServletRequest();
+        vulnerableRequest.setServletPath("/protected");
+        vulnerableRequest.setPathInfo(";/resource");
+        vulnerableRequest.setContextPath("/context");
+        
+        // Get the path directly without normalization
+        String rawPath = vulnerableRequest.getServletPath() + vulnerableRequest.getPathInfo();
+        System.out.println("Raw path: " + rawPath);
+        
+        // Get the normalized path
+        String normalizedPath = WebUtils.getPathWithinApplication(vulnerableRequest);
+        System.out.println("Normalized path: " + normalizedPath);
+        
+        // Check if the path matches after normalization
+        boolean matches = filter.pathsMatch("/protected/**", vulnerableRequest);
+        System.out.println("Path matches after normalization: " + matches);
+        
+        // Check if the raw path would be interpreted differently by a web server
+        // In a vulnerable version, the semicolon would be treated as a path separator
+        // but Shiro's normalization might not handle it correctly
+        if (normalizedPath.equals("/protected/resource") && rawPath.equals("/protected;/resource")) {
+            // This is a potential vulnerability - the paths are interpreted differently
+            PatternMatcher pathMatcher = new AntPathMatcher();
+            boolean rawMatches = pathMatcher.matches("/protected/**", rawPath);
+            boolean normalizedMatches = pathMatcher.matches("/protected/**", normalizedPath);
+            
+            System.out.println("Raw path matches pattern: " + rawMatches);
+            System.out.println("Normalized path matches pattern: " + normalizedMatches);
+            
+            if (rawMatches != normalizedMatches) {
+                System.out.println("Vulnerability detected: Raw and normalized paths are treated differently");
+                return true;
+            }
+        }
+        
+        // Test the specific vulnerability with the removeSemicolon method
+        try {
+            // Use reflection to access the removeSemicolon method
+            Method removeSemicolonMethod = WebUtils.class.getDeclaredMethod("removeSemicolon", String.class);
+            removeSemicolonMethod.setAccessible(true);
+            
+            String pathWithSemicolon = "/protected;/resource";
+            String pathWithoutSemicolon = (String) removeSemicolonMethod.invoke(null, pathWithSemicolon);
+            
+            System.out.println("Path with semicolon: " + pathWithSemicolon);
+            System.out.println("Path after removeSemicolon: " + pathWithoutSemicolon);
+            
+            // In a vulnerable version, the semicolon might not be properly handled
+            if (!pathWithoutSemicolon.equals("/protected/resource")) {
+                System.out.println("Vulnerability detected: Semicolon not properly removed");
+                return true;
+            }
+        } catch (Exception e) {
+            System.out.println("Could not test removeSemicolon method: " + e.getMessage());
+        }
+        
+        return false; // No vulnerability detected
+    }
+    
+    // A simple implementation of PathMatchingFilter for testing
+    private static class TestPathMatchingFilter extends PathMatchingFilter {
+        @Override
+        protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) {
+            return true;
+        }
+    }
+    
+    // A simple mock implementation of HttpServletRequest
+    private static class MockHttpServletRequest implements HttpServletRequest {
+        private String requestURI;
+        private String contextPath = "";
+        private String servletPath = "";
+        private String pathInfo = "";
+        private StringBuffer requestURL = new StringBuffer();
+        
+        public void setRequestURI(String requestURI) {
+            this.requestURI = requestURI;
+        }
+        
+        public void setContextPath(String contextPath) {
+            this.contextPath = contextPath;
+        }
+        
+        public void setServletPath(String servletPath) {
+            this.servletPath = servletPath;
+        }
+        
+        public void setPathInfo(String pathInfo) {
+            this.pathInfo = pathInfo;
+        }
+        
+        @Override
+        public String getRequestURI() {
+            return requestURI;
+        }
+        
+        @Override
+        public StringBuffer getRequestURL() {
+            return requestURL;
+        }
+        
+        @Override
+        public String getContextPath() {
+            return contextPath;
+        }
+        
+        @Override
+        public String getServletPath() {
+            return servletPath;
+        }
+        
+        @Override
+        public String getPathInfo() {
+            return pathInfo;
+        }
+        
+        // Implement other methods with default implementations
+        @Override public String getAuthType() { return null; }
+        @Override public javax.servlet.http.Cookie[] getCookies() { return new javax.servlet.http.Cookie[0]; }
+        @Override public long getDateHeader(String name) { return 0; }
+        @Override public String getHeader(String name) { return null; }
+        @Override public java.util.Enumeration<String> getHeaderNames() { return new java.util.Vector<String>().elements(); }
+        @Override public java.util.Enumeration<String> getHeaders(String name) { return new java.util.Vector<String>().elements(); }
+        @Override public int getIntHeader(String name) { return 0; }
+        @Override public String getMethod() { return "GET"; }
+        @Override public String getPathTranslated() { return null; }
+        @Override public String getQueryString() { return null; }
+        @Override public String getRemoteUser() { return null; }
+        @Override public String getRequestedSessionId() { return null; }
+        @Override public javax.servlet.http.HttpSession getSession() { return null; }
+        @Override public javax.servlet.http.HttpSession getSession(boolean create) { return null; }
+        @Override public java.security.Principal getUserPrincipal() { return null; }
+        @Override public boolean isRequestedSessionIdFromCookie() { return false; }
+        @Override public boolean isRequestedSessionIdFromURL() { return false; }
+        @Override public boolean isRequestedSessionIdFromUrl() { return false; }
+        @Override public boolean isRequestedSessionIdValid() { return false; }
+        @Override public boolean isUserInRole(String role) { return false; }
+        @Override public Object getAttribute(String name) { return null; }
+        @Override public java.util.Enumeration<String> getAttributeNames() { return new java.util.Vector<String>().elements(); }
+        @Override public String getCharacterEncoding() { return null; }
+        @Override public int getContentLength() { return 0; }
+        @Override public String getContentType() { return null; }
+        @Override public javax.servlet.ServletInputStream getInputStream() { return null; }
+        @Override public String getLocalAddr() { return null; }
+        @Override public String getLocalName() { return null; }
+        @Override public int getLocalPort() { return 0; }
+        @Override public java.util.Locale getLocale() { return null; }
+        @Override public java.util.Enumeration<java.util.Locale> getLocales() { return new java.util.Vector<java.util.Locale>().elements(); }
+        @Override public String getParameter(String name) { return null; }
+        @Override public java.util.Map<String, String[]> getParameterMap() { return new java.util.HashMap<>(); }
+        @Override public java.util.Enumeration<String> getParameterNames() { return new java.util.Vector<String>().elements(); }
+        @Override public String[] getParameterValues(String name) { return new String[0]; }
+        @Override public String getProtocol() { return null; }
+        @Override public java.io.BufferedReader getReader() { return null; }
+        @Override public String getRealPath(String path) { return null; }
+        @Override public String getRemoteAddr() { return null; }
+        @Override public String getRemoteHost() { return null; }
+        @Override public int getRemotePort() { return 0; }
+        @Override public javax.servlet.RequestDispatcher getRequestDispatcher(String path) { return null; }
+        @Override public String getScheme() { return null; }
+        @Override public String getServerName() { return null; }
+        @Override public int getServerPort() { return 0; }
+        @Override public boolean isSecure() { return false; }
+        @Override public void removeAttribute(String name) {}
+        @Override public void setAttribute(String name, Object o) {}
+        @Override public void setCharacterEncoding(String env) {}
+        @Override public javax.servlet.DispatcherType getDispatcherType() { return null; }
+        @Override public javax.servlet.AsyncContext getAsyncContext() { return null; }
+        @Override public boolean isAsyncStarted() { return false; }
+        @Override public boolean isAsyncSupported() { return false; }
+        @Override public javax.servlet.AsyncContext startAsync() { return null; }
+        @Override public javax.servlet.AsyncContext startAsync(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) { return null; }
+        @Override public javax.servlet.ServletContext getServletContext() { return null; }
+        @Override public long getContentLengthLong() { return 0; }
+        @Override public java.util.Collection<javax.servlet.http.Part> getParts() { return null; }
+        @Override public javax.servlet.http.Part getPart(String name) { return null; }
+        @Override public <T extends javax.servlet.http.HttpUpgradeHandler> T upgrade(Class<T> handlerClass) { return null; }
+        @Override public String changeSessionId() { return null; }
+        @Override public boolean authenticate(javax.servlet.http.HttpServletResponse response) { return false; }
+        @Override public void login(String username, String password) {}
+        @Override public void logout() {}
+    }
+}
\ No newline at end of file
