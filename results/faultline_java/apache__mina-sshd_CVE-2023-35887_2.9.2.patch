diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 00000000..610a5898
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/apache__mina-sshd_CVE-2023-35887_2.9.2 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 00000000..8b137891
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 00000000..d7c4be09
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,29 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/apache__mina-sshd_CVE-2023-35887_2.9.2 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+
+# Build the project
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Copy all the dependencies to a lib directory
+RUN mkdir -p lib
+RUN cp sshd-common/target/sshd-common-2.9.3-SNAPSHOT.jar lib/
+RUN cp sshd-core/target/sshd-core-2.9.3-SNAPSHOT.jar lib/
+# RUN mvn dependency:copy-dependencies -DoutputDirectory=lib
+
+# Compile and run the test
+RUN javac -cp "lib/*" PathTraversalTest.java
+CMD ["java", "-cp", ".:lib/*", "PathTraversalTest"]
\ No newline at end of file
diff --git a/PathTraversalTest.java b/PathTraversalTest.java
new file mode 100644
index 00000000..baeb3e04
--- /dev/null
+++ b/PathTraversalTest.java
@@ -0,0 +1,186 @@
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.sshd.common.file.root.RootedFileSystem;
+import org.apache.sshd.common.file.root.RootedFileSystemProvider;
+import org.apache.sshd.common.file.root.RootedPath;
+
+public class PathTraversalTest {
+    public static void main(String[] args) throws Exception {
+        // Create a temporary directory to serve as our root
+        Path tempDir = Files.createTempDirectory("rooted-fs-test");
+        System.out.println("Created root directory: " + tempDir);
+        
+        // Create a test file inside the root directory
+        Path testFile = tempDir.resolve("test-file.txt");
+        Files.write(testFile, "Test content".getBytes());
+        System.out.println("Created test file inside root: " + testFile);
+        
+        // Create a test file outside the root directory
+        Path outsideFile = Paths.get("/tmp/outside-file.txt");
+        Files.write(outsideFile, "Outside content".getBytes());
+        System.out.println("Created file outside root: " + outsideFile);
+        
+        // Create a RootedFileSystemProvider and a RootedFileSystem
+        RootedFileSystemProvider provider = new RootedFileSystemProvider();
+        Map<String, Object> env = new HashMap<>();
+        RootedFileSystem rootedFs = (RootedFileSystem) provider.newFileSystem(tempDir, env);
+        System.out.println("Created rooted file system with root: " + rootedFs.getRoot());
+        
+        // Create a subdirectory to make the traversal more complex
+        Path subDir = tempDir.resolve("subdir");
+        Files.createDirectories(subDir);
+        System.out.println("Created subdirectory: " + subDir);
+        
+        // Create a symbolic link inside the root that points outside
+        Path symlink = tempDir.resolve("symlink-to-outside");
+        try {
+            Files.createSymbolicLink(symlink, outsideFile);
+            System.out.println("Created symbolic link: " + symlink + " -> " + outsideFile);
+        } catch (Exception e) {
+            System.out.println("Could not create symbolic link: " + e.getMessage());
+        }
+        
+        boolean isVulnerable = false;
+        
+        // Test 1: Direct path traversal attempts
+        String[] traversalPatterns = {
+            "/../outside-file.txt",
+            "/subdir/../../outside-file.txt",
+            "/./../../outside-file.txt",
+            "/test-file.txt/../../outside-file.txt"
+        };
+        
+        System.out.println("\n=== Test 1: Direct path traversal attempts ===");
+        for (String pattern : traversalPatterns) {
+            System.out.println("\nTrying traversal pattern: " + pattern);
+            try {
+                Path traversalPath = rootedFs.getPath(pattern);
+                System.out.println("Traversal path: " + traversalPath);
+                
+                try {
+                    boolean exists = Files.exists(traversalPath);
+                    System.out.println("Path exists: " + exists);
+                    if (exists) {
+                        System.out.println("VULNERABLE: Path traversal succeeded with pattern: " + pattern);
+                        isVulnerable = true;
+                    }
+                } catch (Exception e) {
+                    System.out.println("Exception during exists check: " + e.getClass().getName() + ": " + e.getMessage());
+                }
+            } catch (Exception e) {
+                System.out.println("Exception creating path: " + e.getClass().getName() + ": " + e.getMessage());
+            }
+        }
+        
+        // Test 2: Symlink-based path traversal
+        System.out.println("\n=== Test 2: Symlink-based path traversal ===");
+        try {
+            Path symlinkPath = rootedFs.getPath("/symlink-to-outside");
+            System.out.println("Symlink path: " + symlinkPath);
+            
+            try {
+                boolean exists = Files.exists(symlinkPath);
+                System.out.println("Symlink exists: " + exists);
+                
+                if (exists) {
+                    try {
+                        BasicFileAttributes attrs = Files.readAttributes(symlinkPath, BasicFileAttributes.class);
+                        System.out.println("Could read attributes of symlink: " + attrs);
+                        
+                        try {
+                            byte[] content = Files.readAllBytes(symlinkPath);
+                            String contentStr = new String(content);
+                            System.out.println("Read content through symlink: " + contentStr);
+                            
+                            if (contentStr.equals("Outside content")) {
+                                System.out.println("VULNERABLE: Could read content of file outside root through symlink!");
+                                isVulnerable = true;
+                            }
+                        } catch (Exception e) {
+                            System.out.println("Exception reading content: " + e.getClass().getName() + ": " + e.getMessage());
+                        }
+                    } catch (Exception e) {
+                        System.out.println("Exception reading attributes: " + e.getClass().getName() + ": " + e.getMessage());
+                    }
+                }
+            } catch (Exception e) {
+                System.out.println("Exception during exists check: " + e.getClass().getName() + ": " + e.getMessage());
+            }
+        } catch (Exception e) {
+            System.out.println("Exception creating symlink path: " + e.getClass().getName() + ": " + e.getMessage());
+        }
+        
+        // Test 3: Using path resolution
+        System.out.println("\n=== Test 3: Using path resolution ===");
+        try {
+            // Try to directly check if a file outside the root exists
+            Path traversalPath = rootedFs.getPath("/test-file.txt");
+            System.out.println("Base path: " + traversalPath);
+            
+            // Try to resolve a path that goes outside the root
+            try {
+                Path resolvedPath = traversalPath.resolve("../../outside-file.txt");
+                System.out.println("Resolved path: " + resolvedPath);
+                
+                try {
+                    boolean exists = Files.exists(resolvedPath);
+                    System.out.println("Path exists check: " + exists);
+                    
+                    if (exists) {
+                        System.out.println("VULNERABLE: Path resolution reports file outside root exists!");
+                        isVulnerable = true;
+                    }
+                } catch (Exception e) {
+                    System.out.println("Exception during exists check: " + e.getClass().getName() + ": " + e.getMessage());
+                }
+            } catch (Exception e) {
+                System.out.println("Exception resolving path: " + e.getClass().getName() + ": " + e.getMessage());
+            }
+        } catch (Exception e) {
+            System.out.println("Exception in path resolution test: " + e.getClass().getName() + ": " + e.getMessage());
+        }
+        
+        // Test 4: Using internal methods if possible
+        System.out.println("\n=== Test 4: Testing internal path resolution ===");
+        try {
+            Path traversalPath = rootedFs.getPath("/test-file.txt/../../outside-file.txt");
+            System.out.println("Traversal path: " + traversalPath);
+            
+            if (traversalPath instanceof RootedPath) {
+                RootedPath rootedPath = (RootedPath) traversalPath;
+                System.out.println("RootedPath: " + rootedPath);
+                System.out.println("Delegate path: " + rootedPath.getFileSystem().toString());
+                
+                // Try to get information about the path
+                try {
+                    String pathToString = rootedPath.toString();
+                    System.out.println("Path toString: " + pathToString);
+                    
+                    if (pathToString.contains("/outside-file.txt") && !pathToString.contains(tempDir.toString())) {
+                        System.out.println("VULNERABLE: Path string representation points outside root!");
+                        isVulnerable = true;
+                    }
+                } catch (Exception e) {
+                    System.out.println("Exception getting path string: " + e.getClass().getName() + ": " + e.getMessage());
+                }
+            }
+        } catch (Exception e) {
+            System.out.println("Exception in internal path test: " + e.getClass().getName() + ": " + e.getMessage());
+        }
+        
+        if (isVulnerable) {
+            System.out.println("\nVULNERABLE: The system is vulnerable to path traversal!");
+            System.exit(1); // Fail if vulnerable
+        } else {
+            System.out.println("\nNOT VULNERABLE: The system is protected against path traversal.");
+            System.exit(0); // Pass if not vulnerable
+        }
+    }
+}
\ No newline at end of file
diff --git a/VulnTest.java b/VulnTest.java
new file mode 100644
index 00000000..ca030b2e
--- /dev/null
+++ b/VulnTest.java
@@ -0,0 +1,93 @@
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.sshd.common.file.root.RootedFileSystem;
+import org.apache.sshd.common.file.root.RootedFileSystemProvider;
+
+public class VulnTest {
+    public static void main(String[] args) throws Exception {
+        // Create a temporary directory to serve as our root
+        Path tempDir = Files.createTempDirectory("rooted-fs-test");
+        System.out.println("Created root directory: " + tempDir);
+        
+        // Create a test file inside the root directory
+        Path testFile = tempDir.resolve("test-file.txt");
+        Files.write(testFile, "Test content".getBytes());
+        System.out.println("Created test file inside root: " + testFile);
+        
+        // Create a test file outside the root directory
+        Path outsideFile = Paths.get("/tmp/outside-file.txt");
+        Files.write(outsideFile, "Outside content".getBytes());
+        System.out.println("Created file outside root: " + outsideFile);
+        
+        // Create a RootedFileSystemProvider and a RootedFileSystem
+        RootedFileSystemProvider provider = new RootedFileSystemProvider();
+        Map<String, Object> env = new HashMap<>();
+        RootedFileSystem rootedFs = (RootedFileSystem) provider.newFileSystem(tempDir, env);
+        System.out.println("Created rooted file system with root: " + rootedFs.getRoot());
+        
+        // Test with a valid path inside the root
+        Path validPath = rootedFs.getPath("/test-file.txt");
+        boolean validExists = Files.exists(validPath);
+        System.out.println("\nValid path: " + validPath);
+        System.out.println("Valid path exists: " + validExists);
+        
+        // Try different path traversal patterns
+        String[] traversalPatterns = {
+            "/../outside-file.txt",
+            "/..\\outside-file.txt",
+            "/folder/../../../outside-file.txt",
+            "/../../../outside-file.txt",
+            "/test-file.txt/../../outside-file.txt"
+        };
+        
+        boolean isVulnerable = false;
+        
+        for (String pattern : traversalPatterns) {
+            System.out.println("\nTrying traversal pattern: " + pattern);
+            try {
+                Path traversalPath = rootedFs.getPath(pattern);
+                System.out.println("Traversal path: " + traversalPath);
+                
+                try {
+                    boolean traversalExists = Files.exists(traversalPath);
+                    System.out.println("Traversal path exists check result: " + traversalExists);
+                    
+                    // If we can detect the outside file, the system is vulnerable
+                    if (traversalExists) {
+                        System.out.println("VULNERABLE: Path traversal succeeded with pattern: " + pattern);
+                        isVulnerable = true;
+                        break;
+                    }
+                } catch (Exception e) {
+                    System.out.println("Exception during exists check: " + e.getClass().getName() + ": " + e.getMessage());
+                }
+                
+                // Try to get file attributes
+                try {
+                    Files.readAttributes(traversalPath, "*");
+                    System.out.println("VULNERABLE: Could read attributes of file outside root!");
+                    isVulnerable = true;
+                    break;
+                } catch (Exception e) {
+                    System.out.println("Exception during attributes check: " + e.getClass().getName() + ": " + e.getMessage());
+                }
+            } catch (Exception e) {
+                System.out.println("Exception creating path: " + e.getClass().getName() + ": " + e.getMessage());
+            }
+        }
+        
+        if (isVulnerable) {
+            System.out.println("\nVULNERABLE: The system is vulnerable to path traversal!");
+            System.exit(1); // Fail if vulnerable
+        } else {
+            System.out.println("\nNOT VULNERABLE: The system is protected against path traversal.");
+            System.exit(0); // Pass if not vulnerable
+        }
+    }
+}
\ No newline at end of file
diff --git a/VulnTest2.java b/VulnTest2.java
new file mode 100644
index 00000000..4317c2ee
--- /dev/null
+++ b/VulnTest2.java
@@ -0,0 +1,84 @@
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.sshd.common.file.root.RootedFileSystem;
+import org.apache.sshd.common.file.root.RootedFileSystemProvider;
+
+public class VulnTest2 {
+    public static void main(String[] args) throws Exception {
+        // Create a temporary directory to serve as our root
+        Path tempDir = Files.createTempDirectory("rooted-fs-test");
+        System.out.println("Created root directory: " + tempDir);
+        
+        // Create a test file inside the root directory
+        Path testFile = tempDir.resolve("test-file.txt");
+        Files.write(testFile, "Test content".getBytes());
+        System.out.println("Created test file inside root: " + testFile);
+        
+        // Create a test file outside the root directory
+        Path outsideFile = Paths.get("/tmp/outside-file.txt");
+        Files.write(outsideFile, "Outside content".getBytes());
+        System.out.println("Created file outside root: " + outsideFile);
+        
+        // Create a RootedFileSystemProvider and a RootedFileSystem
+        RootedFileSystemProvider provider = new RootedFileSystemProvider();
+        Map<String, Object> env = new HashMap<>();
+        RootedFileSystem rootedFs = (RootedFileSystem) provider.newFileSystem(tempDir, env);
+        System.out.println("Created rooted file system with root: " + rootedFs.getRoot());
+        
+        // Test with a valid path inside the root
+        Path validPath = rootedFs.getPath("/test-file.txt");
+        boolean validExists = Files.exists(validPath);
+        System.out.println("\nValid path: " + validPath);
+        System.out.println("Valid path exists: " + validExists);
+        
+        // Try different path traversal patterns
+        String[] traversalPatterns = {
+            "/../outside-file.txt",
+            "/..\\outside-file.txt",
+            "/folder/../../../outside-file.txt",
+            "/../../../outside-file.txt",
+            "/test-file.txt/../../outside-file.txt",
+            "/./../../outside-file.txt"
+        };
+        
+        boolean isVulnerable = false;
+        
+        for (String pattern : traversalPatterns) {
+            System.out.println("\nTrying traversal pattern: " + pattern);
+            try {
+                Path traversalPath = rootedFs.getPath(pattern);
+                System.out.println("Traversal path: " + traversalPath);
+                
+                try {
+                    boolean traversalExists = provider.exists(traversalPath);
+                    System.out.println("Traversal path exists check result: " + traversalExists);
+                    
+                    // If we can detect the outside file, the system is vulnerable
+                    if (traversalExists) {
+                        System.out.println("VULNERABLE: Path traversal succeeded with pattern: " + pattern);
+                        isVulnerable = true;
+                        break;
+                    }
+                } catch (Exception e) {
+                    System.out.println("Exception during exists check: " + e.getClass().getName() + ": " + e.getMessage());
+                }
+            } catch (Exception e) {
+                System.out.println("Exception creating path: " + e.getClass().getName() + ": " + e.getMessage());
+            }
+        }
+        
+        if (isVulnerable) {
+            System.out.println("\nVULNERABLE: The system is vulnerable to path traversal!");
+            System.exit(1); // Fail if vulnerable
+        } else {
+            System.out.println("\nNOT VULNERABLE: The system is protected against path traversal.");
+            System.exit(0); // Pass if not vulnerable
+        }
+    }
+}
\ No newline at end of file
diff --git a/VulnerabilityTest.java b/VulnerabilityTest.java
new file mode 100644
index 00000000..84df4fcf
--- /dev/null
+++ b/VulnerabilityTest.java
@@ -0,0 +1,89 @@
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.sshd.common.file.root.RootedFileSystem;
+import org.apache.sshd.common.file.root.RootedFileSystemProvider;
+
+/**
+ * Test case for CVE-2023-35887 - Path traversal vulnerability in RootedFileSystem
+ * This test demonstrates the vulnerability by creating a RootedFileSystem and
+ * attempting to check if files outside the root directory exist.
+ */
+public class VulnerabilityTest {
+    
+    public static void main(String[] args) {
+        try {
+            // Create a temporary directory to serve as our root
+            Path tempDir = Files.createTempDirectory("rooted-fs-test");
+            System.out.println("Created temp directory: " + tempDir);
+            
+            // Create a test file inside the root directory
+            Path testFile = tempDir.resolve("test-file.txt");
+            Files.write(testFile, "Test content".getBytes());
+            System.out.println("Created test file: " + testFile);
+            
+            // Create a test file outside the root directory
+            Path outsideFile = Paths.get(System.getProperty("java.io.tmpdir"), "outside-file.txt");
+            Files.write(outsideFile, "Outside content".getBytes());
+            System.out.println("Created outside file: " + outsideFile);
+            
+            // Create a RootedFileSystemProvider and a RootedFileSystem
+            RootedFileSystemProvider provider = new RootedFileSystemProvider();
+            Map<String, Object> env = new HashMap<>();
+            RootedFileSystem rootedFs = (RootedFileSystem) provider.newFileSystem(tempDir, env);
+            
+            System.out.println("\nTesting path traversal vulnerability...");
+            
+            // Test with a valid path inside the root
+            Path validPath = rootedFs.getPath("/test-file.txt");
+            testPathExists(provider, validPath, "Valid path inside root");
+            
+            // Test with a path traversal attempt to access a file outside the root
+            // This should fail in a secure implementation but succeed if vulnerable
+            Path traversalPath = rootedFs.getPath("/.." + outsideFile.toString());
+            boolean vulnerable = testPathExists(provider, traversalPath, "Path traversal attempt");
+            
+            // Clean up
+            Files.delete(testFile);
+            Files.delete(outsideFile);
+            Files.delete(tempDir);
+            
+            // Exit with appropriate code
+            if (vulnerable) {
+                System.out.println("\nVULNERABLE: The system is vulnerable to path traversal!");
+                System.exit(1); // Fail if vulnerable
+            } else {
+                System.out.println("\nNOT VULNERABLE: The system is protected against path traversal.");
+                System.exit(0); // Pass if not vulnerable
+            }
+            
+        } catch (Exception e) {
+            System.err.println("Error during test: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(2);
+        }
+    }
+    
+    private static boolean testPathExists(RootedFileSystemProvider provider, Path path, String description) {
+        try {
+            System.out.println("\nTesting: " + description);
+            System.out.println("Path: " + path);
+            
+            // This is where the vulnerability would be triggered
+            // The provider will check if the file exists, and in vulnerable versions,
+            // it will allow checking existence of files outside the root
+            boolean exists = Files.exists(path);
+            
+            System.out.println("File exists: " + exists);
+            return exists;
+        } catch (Exception e) {
+            System.out.println("Exception: " + e.getClass().getName() + ": " + e.getMessage());
+            return false;
+        }
+    }
+}
diff --git a/sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java.debug b/sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java.debug
new file mode 100644
index 00000000..6368a8c2
--- /dev/null
+++ b/sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java.debug
@@ -0,0 +1,338 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.sshd.common.file.root;
+
+import java.io.IOException;
+import java.net.URI;
+import java.nio.channels.AsynchronousFileChannel;
+import java.nio.channels.FileChannel;
+import java.nio.channels.SeekableByteChannel;
+import java.nio.file.AccessMode;
+import java.nio.file.CopyOption;
+import java.nio.file.DirectoryStream;
+import java.nio.file.DirectoryStream.Filter;
+import java.nio.file.FileStore;
+import java.nio.file.FileSystem;
+import java.nio.file.FileSystemAlreadyExistsException;
+import java.nio.file.FileSystemNotFoundException;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+import java.nio.file.LinkOption;
+import java.nio.file.OpenOption;
+import java.nio.file.Path;
+import java.nio.file.ProviderMismatchException;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.nio.file.attribute.FileAttribute;
+import java.nio.file.attribute.FileAttributeView;
+import java.nio.file.spi.FileSystemProvider;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+
+import org.apache.sshd.common.util.ValidateUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * File system provider which restricts access to a specific root directory.
+ *
+ * @author <a href="mailto:dev@mina.apache.org">Apache MINA SSHD Project</a>
+ */
+public class RootedFileSystemProvider extends FileSystemProvider {
+
+    protected final Logger log;
+    protected final FileSystemProvider provider;
+    protected final Map<Path, RootedFileSystem> fileSystems = new HashMap<>();
+
+    public RootedFileSystemProvider() {
+        this(FileSystems.getDefault().provider());
+    }
+
+    public RootedFileSystemProvider(FileSystemProvider provider) {
+        this.provider = Objects.requireNonNull(provider, "No delegate provider");
+        log = LoggerFactory.getLogger(getClass());
+    }
+
+    @Override
+    public String getScheme() {
+        return "root";
+    }
+
+    @Override
+    public FileSystem newFileSystem(URI uri, Map<String, ?> env) throws IOException {
+        throw new UnsupportedOperationException("URI scheme not supported");
+    }
+
+    @Override
+    public FileSystem getFileSystem(URI uri) {
+        throw new UnsupportedOperationException("URI scheme not supported");
+    }
+
+    @Override
+    public Path getPath(URI uri) {
+        throw new UnsupportedOperationException("URI scheme not supported");
+    }
+
+    @Override
+    public FileSystem newFileSystem(Path path, Map<String, ?> env) throws IOException {
+        ValidateUtils.checkNotNullAndNotEmpty(env, "No environment provided");
+
+        Path root = path.toRealPath();
+        if (fileSystems.containsKey(root)) {
+            throw new FileSystemAlreadyExistsException(root.toString());
+        }
+
+        RootedFileSystem fileSystem = new RootedFileSystem(this, root, env);
+        fileSystems.put(root, fileSystem);
+        return fileSystem;
+    }
+
+    @Override
+    public FileSystem newFileSystem(Path path, Map<String, ?> env, RootedFileSystem fileSystem) throws IOException {
+        ValidateUtils.checkNotNullAndNotEmpty(env, "No environment provided");
+
+        Path root = path.toRealPath();
+        if (fileSystems.containsKey(root)) {
+            throw new FileSystemAlreadyExistsException(root.toString());
+        }
+
+        fileSystems.put(root, fileSystem);
+        return fileSystem;
+    }
+
+    @Override
+    public FileSystem getFileSystem(Path path) throws IOException {
+        Path root = path.toRealPath();
+        FileSystem fileSystem = fileSystems.get(root);
+        if (fileSystem == null) {
+            throw new FileSystemNotFoundException(root.toString());
+        }
+        return fileSystem;
+    }
+
+    @Override
+    public void checkAccess(Path path, AccessMode... modes) throws IOException {
+        provider.checkAccess(toDelegate(path), modes);
+    }
+
+    @Override
+    public void copy(Path source, Path target, CopyOption... options) throws IOException {
+        provider.copy(toDelegate(source), toDelegate(target), options);
+    }
+
+    @Override
+    public void createDirectory(Path dir, FileAttribute<?>... attrs) throws IOException {
+        provider.createDirectory(toDelegate(dir), attrs);
+    }
+
+    @Override
+    public void delete(Path path) throws IOException {
+        provider.delete(toDelegate(path));
+    }
+
+    @Override
+    public <V extends FileAttributeView> V getFileAttributeView(Path path, Class<V> type, LinkOption... options) {
+        return provider.getFileAttributeView(toDelegate(path), type, options);
+    }
+
+    @Override
+    public FileStore getFileStore(Path path) throws IOException {
+        return provider.getFileStore(toDelegate(path));
+    }
+
+    @Override
+    public boolean isHidden(Path path) throws IOException {
+        return provider.isHidden(toDelegate(path));
+    }
+
+    @Override
+    public boolean isSameFile(Path path, Path path2) throws IOException {
+        return provider.isSameFile(toDelegate(path), toDelegate(path2));
+    }
+
+    @Override
+    public void move(Path source, Path target, CopyOption... options) throws IOException {
+        provider.move(toDelegate(source), toDelegate(target), options);
+    }
+
+    @Override
+    public AsynchronousFileChannel newAsynchronousFileChannel(Path path, Set<? extends OpenOption> options,
+            ExecutorService executor, FileAttribute<?>... attrs) throws IOException {
+        return provider.newAsynchronousFileChannel(toDelegate(path), options, executor, attrs);
+    }
+
+    @Override
+    public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs)
+            throws IOException {
+        return provider.newByteChannel(toDelegate(path), options, attrs);
+    }
+
+    @Override
+    public DirectoryStream<Path> newDirectoryStream(Path dir, Filter<? super Path> filter) throws IOException {
+        final DirectoryStream<Path> stream = provider.newDirectoryStream(toDelegate(dir), filter);
+        return new DirectoryStream<Path>() {
+            @Override
+            public Iterator<Path> iterator() {
+                final Iterator<Path> iterator = stream.iterator();
+                return new Iterator<Path>() {
+                    @Override
+                    public boolean hasNext() {
+                        return iterator.hasNext();
+                    }
+
+                    @Override
+                    public Path next() {
+                        return fromDelegate(iterator.next());
+                    }
+
+                    @Override
+                    public void remove() {
+                        iterator.remove();
+                    }
+                };
+            }
+
+            @Override
+            public void close() throws IOException {
+                stream.close();
+            }
+        };
+    }
+
+    @Override
+    public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs)
+            throws IOException {
+        return provider.newFileChannel(toDelegate(path), options, attrs);
+    }
+
+    @Override
+    public <A extends BasicFileAttributes> A readAttributes(Path path, Class<A> type, LinkOption... options) throws IOException {
+        return provider.readAttributes(toDelegate(path), type, options);
+    }
+
+    @Override
+    public Map<String, Object> readAttributes(Path path, String attributes, LinkOption... options) throws IOException {
+        return provider.readAttributes(toDelegate(path), attributes, options);
+    }
+
+    @Override
+    public void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException {
+        provider.setAttribute(toDelegate(path), attribute, value, options);
+    }
+
+    /**
+     * Converts a path from the rooted file system to a path of the delegate file system.
+     *
+     * @param  path The path to convert
+     * @return      The converted path
+     */
+    public Path toDelegate(Path path) {
+        if (!(path instanceof RootedPath)) {
+            throw new ProviderMismatchException();
+        }
+        RootedPath rootedPath = (RootedPath) path;
+        if (rootedPath.getFileSystem().provider() != this) {
+            throw new ProviderMismatchException();
+        }
+        Path result = resolveLocalPath(rootedPath);
+        System.out.println("DEBUG - toDelegate: " + path + " -> " + result);
+        return result;
+    }
+
+    /**
+     * Converts a path from the delegate file system to a path of the rooted file system.
+     *
+     * @param  path The path to convert
+     * @return      The converted path
+     */
+    public Path fromDelegate(Path path) {
+        for (Map.Entry<Path, RootedFileSystem> entry : fileSystems.entrySet()) {
+            Path root = entry.getKey();
+            if (path.startsWith(root)) {
+                RootedFileSystem fileSystem = entry.getValue();
+                String relativePath = path.toString().substring(root.toString().length());
+                if (relativePath.isEmpty()) {
+                    relativePath = "/";
+                } else if (relativePath.charAt(0) != '/') {
+                    relativePath = "/" + relativePath;
+                }
+                return fileSystem.getPath(relativePath);
+            }
+        }
+        throw new IllegalArgumentException("Path " + path + " is not under any known root");
+    }
+
+    /**
+     * Resolves a path from the rooted file system to a path of the delegate file system.
+     *
+     * @param  path The path to resolve
+     * @return      The resolved path
+     */
+    protected Path resolveLocalPath(RootedPath path) {
+        Path root = path.getFileSystem().getRoot();
+        String pathString = path.toString();
+        System.out.println("DEBUG - resolveLocalPath: path=" + path + ", root=" + root + ", pathString=" + pathString);
+        if (pathString.equals("/")) {
+            System.out.println("DEBUG - resolveLocalPath: returning root: " + root);
+            return root;
+        }
+        if (pathString.charAt(0) == '/') {
+            pathString = pathString.substring(1);
+        }
+        Path result = root.resolve(pathString);
+        System.out.println("DEBUG - resolveLocalPath: resolved path: " + result);
+        
+        // Check if the resolved path is still under the root
+        try {
+            Path normalizedResult = result.normalize();
+            System.out.println("DEBUG - resolveLocalPath: normalized path: " + normalizedResult);
+            if (!normalizedResult.startsWith(root)) {
+                System.out.println("DEBUG - resolveLocalPath: SECURITY VIOLATION - Path escapes root: " + normalizedResult);
+                throw new IllegalArgumentException("Not under root: " + path);
+            }
+            return normalizedResult;
+        } catch (Exception e) {
+            System.out.println("DEBUG - resolveLocalPath: Exception during normalization: " + e.getMessage());
+            throw new IllegalArgumentException("Not under root: " + path, e);
+        }
+    }
+
+    /**
+     * Checks if a file exists.
+     *
+     * @param  path The path to check
+     * @return      True if the file exists, false otherwise
+     */
+    public boolean exists(Path path) {
+        try {
+            System.out.println("DEBUG - exists check for path: " + path);
+            Path delegatePath = toDelegate(path);
+            System.out.println("DEBUG - exists check for delegate path: " + delegatePath);
+            boolean result = Files.exists(delegatePath);
+            System.out.println("DEBUG - exists result: " + result);
+            return result;
+        } catch (Exception e) {
+            System.out.println("DEBUG - exists check exception: " + e.getClass().getName() + ": " + e.getMessage());
+            return false;
+        }
+    }
+}
