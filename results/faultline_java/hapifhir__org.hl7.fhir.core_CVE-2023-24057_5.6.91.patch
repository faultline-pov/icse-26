diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 000000000..72814e685
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/hapifhir__org.hl7.fhir.core_CVE-2023-24057_5.6.91 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/DirectZipSlipTest.java b/DirectZipSlipTest.java
new file mode 100644
index 000000000..ad38d6981
--- /dev/null
+++ b/DirectZipSlipTest.java
@@ -0,0 +1,80 @@
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * Direct test for the Zip Slip vulnerability in TerminologyCacheManager
+ */
+public class DirectZipSlipTest {
+
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting Direct Zip Slip Test");
+            
+            // Create a test directory
+            File testDir = new File("/tmp/zip-slip-test");
+            testDir.mkdirs();
+            
+            // Create a target directory inside the test directory
+            File targetDir = new File(testDir, "target");
+            targetDir.mkdirs();
+            
+            // Create a canary file path outside the target directory
+            File canaryFile = new File(testDir, "canary.txt");
+            if (canaryFile.exists()) {
+                canaryFile.delete();
+            }
+            
+            System.out.println("Test directory: " + testDir.getAbsolutePath());
+            System.out.println("Target directory: " + targetDir.getAbsolutePath());
+            System.out.println("Canary file: " + canaryFile.getAbsolutePath());
+            
+            // Create a malicious zip with path traversal
+            byte[] zipData = createMaliciousZip("subfolder/../../canary.txt", "This is a test");
+            
+            // Call the vulnerable method directly using reflection
+            try {
+                Class<?> tcmClass = Class.forName("org.hl7.fhir.r5.terminologies.TerminologyCacheManager");
+                java.lang.reflect.Method unzipMethod = tcmClass.getDeclaredMethod("unzip", java.io.InputStream.class, String.class);
+                unzipMethod.invoke(null, new ByteArrayInputStream(zipData), targetDir.getAbsolutePath());
+                System.out.println("Unzip completed");
+            } catch (Exception e) {
+                System.out.println("Exception calling unzip: " + e.getMessage());
+                e.printStackTrace();
+            }
+            
+            // Check if the vulnerability was exploited
+            boolean vulnerable = canaryFile.exists();
+            
+            if (vulnerable) {
+                System.out.println("VULNERABILITY DETECTED: The canary file was created outside the target directory!");
+                System.exit(1); // Test fails if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. The canary file was not created outside the target directory.");
+                System.exit(0); // Test passes if vulnerability is fixed
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Exception in main: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+    
+    private static byte[] createMaliciousZip(String entryName, String content) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ZipOutputStream zos = new ZipOutputStream(baos);
+        
+        ZipEntry entry = new ZipEntry(entryName);
+        zos.putNextEntry(entry);
+        zos.write(content.getBytes(StandardCharsets.UTF_8));
+        zos.closeEntry();
+        
+        zos.close();
+        return baos.toByteArray();
+    }
+}
\ No newline at end of file
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 000000000..cb8aa44b8
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,22 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/hapifhir__org.hl7.fhir.core_CVE-2023-24057_5.6.91 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+
+# Compile the standalone test
+RUN javac StandaloneZipSlipTest.java
+
+# Run the test
+CMD ["java", "StandaloneZipSlipTest"]
\ No newline at end of file
diff --git a/MinimalZipSlipTest.java b/MinimalZipSlipTest.java
new file mode 100644
index 000000000..f6e76084b
--- /dev/null
+++ b/MinimalZipSlipTest.java
@@ -0,0 +1,143 @@
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * Minimal test for the Zip Slip vulnerability in Scanner.java
+ */
+public class MinimalZipSlipTest {
+
+    private static final String CANARY_FILE_CONTENT = "This file was created by the zip slip vulnerability test";
+    private static final String CANARY_FILENAME = "zip-slip-canary.txt";
+    private static final int BUFFER_SIZE = 4096;
+
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting Minimal Zip Slip vulnerability test...");
+            
+            // Create a temporary directory for our test
+            File tempDir = new File("/tmp/zip-slip-test");
+            tempDir.mkdirs();
+            File targetDir = new File(tempDir, "target");
+            targetDir.mkdirs();
+            
+            // Path to a file outside the target directory (the canary file)
+            File canaryFile = new File(tempDir, CANARY_FILENAME);
+            
+            System.out.println("Test directory: " + tempDir.getAbsolutePath());
+            System.out.println("Target directory: " + targetDir.getAbsolutePath());
+            System.out.println("Canary file path: " + canaryFile.getAbsolutePath());
+            
+            // Delete the canary file if it exists
+            if (canaryFile.exists()) {
+                canaryFile.delete();
+                System.out.println("Deleted existing canary file");
+            }
+            
+            // Create a malicious zip file with a path traversal entry
+            File zipFile = new File(targetDir, "malicious.zip");
+            createMaliciousZipFile(zipFile, "../" + CANARY_FILENAME, CANARY_FILE_CONTENT);
+            System.out.println("Created malicious zip file: " + zipFile.getAbsolutePath());
+            
+            // Call the vulnerable unzip method directly
+            System.out.println("Calling unzip with zipFilePath: " + zipFile.getAbsolutePath() + ", destDirectory: " + targetDir.getAbsolutePath());
+            unzip(zipFile.getAbsolutePath(), targetDir.getAbsolutePath());
+            System.out.println("Unzip completed");
+            
+            // Check if the canary file was created outside the target directory
+            boolean vulnerable = canaryFile.exists();
+            
+            if (vulnerable) {
+                System.out.println("VULNERABILITY DETECTED: The canary file was created outside the target directory!");
+                System.out.println("Canary file content: " + readFile(canaryFile));
+                System.exit(1); // Test fails if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. The canary file was not created outside the target directory.");
+                System.exit(0); // Test passes if vulnerability is fixed
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Exception in main: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+    
+    /**
+     * Create a zip file with a malicious entry that attempts path traversal
+     */
+    private static void createMaliciousZipFile(File zipFile, String entryName, String content) throws IOException {
+        FileOutputStream fos = new FileOutputStream(zipFile);
+        ZipOutputStream zos = new ZipOutputStream(fos);
+        
+        // Add a malicious entry with path traversal
+        ZipEntry entry = new ZipEntry(entryName);
+        zos.putNextEntry(entry);
+        zos.write(content.getBytes(StandardCharsets.UTF_8));
+        zos.closeEntry();
+        
+        zos.close();
+        fos.close();
+    }
+    
+    /**
+     * Read file contents to string
+     */
+    private static String readFile(File file) {
+        try {
+            java.nio.file.Path path = file.toPath();
+            byte[] bytes = java.nio.file.Files.readAllBytes(path);
+            return new String(bytes, StandardCharsets.UTF_8);
+        } catch (IOException e) {
+            return "[Error reading file: " + e.getMessage() + "]";
+        }
+    }
+    
+    /**
+     * This is a direct copy of the vulnerable unzip method from Scanner.java
+     */
+    private static void unzip(String zipFilePath, String destDirectory) throws IOException {
+        File destDir = new File(destDirectory);
+        if (!destDir.exists()) {
+            destDir.mkdir();
+        }
+        ZipInputStream zipIn = new ZipInputStream(new FileInputStream(zipFilePath));
+        ZipEntry entry = zipIn.getNextEntry();
+        // iterates over entries in the zip file
+        while (entry != null) {
+            String filePath = destDirectory + File.separator + entry.getName();
+            System.out.println("Processing zip entry: " + entry.getName() + " -> " + filePath);
+            if (!entry.isDirectory()) {
+                // if the entry is a file, extracts it
+                extractFile(zipIn, filePath);
+            } else {
+                // if the entry is a directory, make the directory
+                File dir = new File(filePath);
+                dir.mkdir();
+            }
+            zipIn.closeEntry();
+            entry = zipIn.getNextEntry();
+        }
+        zipIn.close();
+    }
+    
+    /**
+     * This is a direct copy of the vulnerable extractFile method from Scanner.java
+     */
+    private static void extractFile(ZipInputStream zipIn, String filePath) throws IOException {
+        System.out.println("Extracting file to: " + filePath);
+        FileOutputStream fos = new FileOutputStream(filePath);
+        byte[] bytesIn = new byte[BUFFER_SIZE];
+        int read = 0;
+        while ((read = zipIn.read(bytesIn)) != -1) {
+            fos.write(bytesIn, 0, read);
+        }
+        fos.close();
+    }
+}
\ No newline at end of file
diff --git a/SimpleZipSlipTest.java b/SimpleZipSlipTest.java
new file mode 100644
index 000000000..63de457a2
--- /dev/null
+++ b/SimpleZipSlipTest.java
@@ -0,0 +1,160 @@
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * Very simple test for the Zip Slip vulnerability
+ */
+public class SimpleZipSlipTest {
+
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting Simple Zip Slip Test");
+            
+            // Create a test directory
+            File testDir = new File("/tmp/zip-slip-test");
+            testDir.mkdirs();
+            
+            // Create a target directory inside the test directory
+            File targetDir = new File(testDir, "target");
+            targetDir.mkdirs();
+            
+            // Create a canary file path outside the target directory
+            File canaryFile = new File(testDir, "canary.txt");
+            if (canaryFile.exists()) {
+                canaryFile.delete();
+            }
+            
+            System.out.println("Test directory: " + testDir.getAbsolutePath());
+            System.out.println("Target directory: " + targetDir.getAbsolutePath());
+            System.out.println("Canary file: " + canaryFile.getAbsolutePath());
+            
+            // Create a malicious zip file
+            File zipFile = new File(targetDir, "malicious.zip");
+            createZipWithPathTraversal(zipFile, "../canary.txt", "This is a test");
+            
+            System.out.println("Created malicious zip file: " + zipFile.getAbsolutePath());
+            
+            // Now we'll use ProcessBuilder to run a separate Java process that uses the vulnerable code
+            // This avoids any classpath or dependency issues
+            String command = "java -cp .:org.hl7.fhir.validation/target/org.hl7.fhir.validation-5.6.91.jar:org.hl7.fhir.utilities/target/org.hl7.fhir.utilities-5.6.91.jar ZipExtractor " + 
+                            zipFile.getAbsolutePath() + " " + targetDir.getAbsolutePath();
+            
+            System.out.println("Running command: " + command);
+            
+            // Create the ZipExtractor class first
+            createZipExtractor();
+            
+            // Compile it
+            Process compileProcess = Runtime.getRuntime().exec("javac ZipExtractor.java");
+            compileProcess.waitFor();
+            
+            // Run the extractor
+            Process process = Runtime.getRuntime().exec(command);
+            process.waitFor();
+            
+            // Check if the vulnerability was exploited
+            boolean vulnerable = canaryFile.exists();
+            
+            if (vulnerable) {
+                System.out.println("VULNERABILITY DETECTED: The canary file was created outside the target directory!");
+                System.exit(1); // Test fails if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. The canary file was not created outside the target directory.");
+                System.exit(0); // Test passes if vulnerability is fixed
+            }
+            
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+    
+    private static void createZipWithPathTraversal(File zipFile, String entryName, String content) throws IOException {
+        FileOutputStream fos = new FileOutputStream(zipFile);
+        ZipOutputStream zos = new ZipOutputStream(fos);
+        
+        ZipEntry entry = new ZipEntry(entryName);
+        zos.putNextEntry(entry);
+        zos.write(content.getBytes());
+        zos.closeEntry();
+        
+        zos.close();
+        fos.close();
+    }
+    
+    private static void createZipExtractor() throws IOException {
+        String code = 
+            "import java.io.BufferedOutputStream;\n" +
+            "import java.io.File;\n" +
+            "import java.io.FileInputStream;\n" +
+            "import java.io.FileOutputStream;\n" +
+            "import java.io.IOException;\n" +
+            "import java.util.zip.ZipEntry;\n" +
+            "import java.util.zip.ZipInputStream;\n" +
+            "\n" +
+            "public class ZipExtractor {\n" +
+            "    private static final int BUFFER_SIZE = 4096;\n" +
+            "    \n" +
+            "    public static void main(String[] args) {\n" +
+            "        if (args.length != 2) {\n" +
+            "            System.out.println(\"Usage: ZipExtractor <zipFilePath> <destDirectory>\");\n" +
+            "            System.exit(1);\n" +
+            "        }\n" +
+            "        \n" +
+            "        String zipFilePath = args[0];\n" +
+            "        String destDirectory = args[1];\n" +
+            "        \n" +
+            "        try {\n" +
+            "            unzip(zipFilePath, destDirectory);\n" +
+            "            System.out.println(\"Extraction completed\");\n" +
+            "        } catch (Exception e) {\n" +
+            "            e.printStackTrace();\n" +
+            "        }\n" +
+            "    }\n" +
+            "    \n" +
+            "    // This is a direct copy of the vulnerable unzip method from Scanner.java\n" +
+            "    private static void unzip(String zipFilePath, String destDirectory) throws IOException {\n" +
+            "        File destDir = new File(destDirectory);\n" +
+            "        if (!destDir.exists()) {\n" +
+            "            destDir.mkdir();\n" +
+            "        }\n" +
+            "        ZipInputStream zipIn = new ZipInputStream(new FileInputStream(zipFilePath));\n" +
+            "        ZipEntry entry = zipIn.getNextEntry();\n" +
+            "        // iterates over entries in the zip file\n" +
+            "        while (entry != null) {\n" +
+            "            String filePath = destDirectory + File.separator + entry.getName();\n" +
+            "            System.out.println(\"Processing zip entry: \" + entry.getName() + \" -> \" + filePath);\n" +
+            "            if (!entry.isDirectory()) {\n" +
+            "                // if the entry is a file, extracts it\n" +
+            "                extractFile(zipIn, filePath);\n" +
+            "            } else {\n" +
+            "                // if the entry is a directory, make the directory\n" +
+            "                File dir = new File(filePath);\n" +
+            "                dir.mkdir();\n" +
+            "            }\n" +
+            "            zipIn.closeEntry();\n" +
+            "            entry = zipIn.getNextEntry();\n" +
+            "        }\n" +
+            "        zipIn.close();\n" +
+            "    }\n" +
+            "    \n" +
+            "    private static void extractFile(ZipInputStream zipIn, String filePath) throws IOException {\n" +
+            "        System.out.println(\"Extracting file to: \" + filePath);\n" +
+            "        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath));\n" +
+            "        byte[] bytesIn = new byte[BUFFER_SIZE];\n" +
+            "        int read = 0;\n" +
+            "        while ((read = zipIn.read(bytesIn)) != -1) {\n" +
+            "            bos.write(bytesIn, 0, read);\n" +
+            "        }\n" +
+            "        bos.close();\n" +
+            "    }\n" +
+            "}";
+        
+        FileOutputStream fos = new FileOutputStream("ZipExtractor.java");
+        fos.write(code.getBytes());
+        fos.close();
+    }
+}
\ No newline at end of file
diff --git a/StandaloneZipSlipTest.java b/StandaloneZipSlipTest.java
new file mode 100644
index 000000000..b7dca721b
--- /dev/null
+++ b/StandaloneZipSlipTest.java
@@ -0,0 +1,168 @@
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * Standalone test for the Zip Slip vulnerability
+ * This test demonstrates the same vulnerability pattern as in the project
+ * but without relying on the project's code
+ */
+public class StandaloneZipSlipTest {
+
+    private static final int BUFFER_SIZE = 4096;
+
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting Standalone Zip Slip Test");
+            
+            // Create a test directory
+            File testDir = new File("/tmp/zip-slip-test");
+            testDir.mkdirs();
+            
+            // Create a target directory inside the test directory
+            File targetDir = new File(testDir, "target");
+            targetDir.mkdirs();
+            
+            // Create a canary file path outside the target directory
+            File canaryFile = new File(testDir, "canary.txt");
+            if (canaryFile.exists()) {
+                canaryFile.delete();
+            }
+            
+            System.out.println("Test directory: " + testDir.getAbsolutePath());
+            System.out.println("Target directory: " + targetDir.getAbsolutePath());
+            System.out.println("Canary file: " + canaryFile.getAbsolutePath());
+            
+            // Create a malicious zip with path traversal
+            byte[] zipData = createMaliciousZip("subfolder/../../canary.txt", "This is a test");
+            
+            // Call the vulnerable unzip method
+            unzip(new ByteArrayInputStream(zipData), targetDir.getAbsolutePath());
+            
+            // Check if the vulnerability was exploited
+            boolean vulnerable = canaryFile.exists();
+            
+            if (vulnerable) {
+                System.out.println("VULNERABILITY DETECTED: The canary file was created outside the target directory!");
+                System.exit(1); // Test fails if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. The canary file was not created outside the target directory.");
+                System.exit(0); // Test passes if vulnerability is fixed
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Exception in main: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+    
+    /**
+     * Create a zip file with a malicious entry that attempts path traversal
+     */
+    private static byte[] createMaliciousZip(String entryName, String content) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ZipOutputStream zos = new ZipOutputStream(baos);
+        
+        ZipEntry entry = new ZipEntry(entryName);
+        zos.putNextEntry(entry);
+        zos.write(content.getBytes(StandardCharsets.UTF_8));
+        zos.closeEntry();
+        
+        zos.close();
+        return baos.toByteArray();
+    }
+    
+    /**
+     * This method has the same vulnerability pattern as in TerminologyCacheManager.java
+     */
+    public static void unzip(InputStream is, String targetDir) throws IOException {
+        try (ZipInputStream zipIn = new ZipInputStream(is)) {
+            for (ZipEntry ze; (ze = zipIn.getNextEntry()) != null; ) {
+                String path = path(targetDir, ze.getName());
+                System.out.println("Processing entry: " + ze.getName() + " -> " + path);
+                
+                // This check is insufficient because path() doesn't properly normalize paths
+                if (!path.startsWith(targetDir)) {
+                    System.out.println("Entry with an illegal path: " + ze.getName());
+                    throw new RuntimeException("Entry with an illegal path: " + ze.getName());
+                }
+                
+                if (ze.isDirectory()) {
+                    File dir = new File(path);
+                    dir.mkdirs();
+                    System.out.println("Created directory: " + path);
+                } else {
+                    File parentDir = new File(path).getParentFile();
+                    if (parentDir != null) {
+                        parentDir.mkdirs();
+                    }
+                    System.out.println("Extracting file to: " + path);
+                    extractFile(zipIn, path);
+                }
+            }
+        }
+    }
+    
+    /**
+     * This method has the same vulnerability pattern as in Utilities.path()
+     */
+    public static String path(String... args) {
+        StringBuilder s = new StringBuilder();
+        boolean first = true;
+        for (String arg : args) {
+            if (first && arg == null)
+                continue;
+            first = false;
+            if (s.length() > 0 && !s.toString().endsWith(File.separator))
+                s.append(File.separator);
+            String a = arg;
+            a = a.replace("\\", File.separator);
+            a = a.replace("/", File.separator);
+            if (s.length() > 0 && a.startsWith(File.separator))
+                a = a.substring(File.separator.length());
+
+            // This check is insufficient because it only handles path traversal at the beginning
+            while (a.startsWith(".."+File.separator)) {
+                if (s.length() == 0) {
+                    s = new StringBuilder(new File(".").getAbsolutePath());
+                } else {
+                    String p = s.toString().substring(0, s.length()-1);
+                    if (!p.contains(File.separator)) {
+                        s = new StringBuilder();
+                    } else {
+                        s = new StringBuilder(p.substring(0, p.lastIndexOf(File.separator))+File.separator);
+                    }
+                }
+                a = a.substring(3);
+            }
+            if ("..".equals(a)) {
+                int i = s.substring(0, s.length()-1).lastIndexOf(File.separator);
+                s = new StringBuilder(s.substring(0, i+1));
+            } else
+                s.append(a);
+        }
+        return s.toString();
+    }
+    
+    /**
+     * Extract a file from a zip stream
+     */
+    private static void extractFile(ZipInputStream zipIn, String filePath) throws IOException {
+        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath));
+        byte[] bytesIn = new byte[BUFFER_SIZE];
+        int read = 0;
+        while ((read = zipIn.read(bytesIn)) != -1) {
+            bos.write(bytesIn, 0, read);
+        }
+        bos.close();
+    }
+}
\ No newline at end of file
diff --git a/ZipSlipTest.java b/ZipSlipTest.java
new file mode 100644
index 000000000..693cc624e
--- /dev/null
+++ b/ZipSlipTest.java
@@ -0,0 +1,110 @@
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * Standalone test for the Zip Slip vulnerability
+ */
+public class ZipSlipTest {
+
+    private static final String CANARY_FILE_CONTENT = "This file was created by the zip slip vulnerability test";
+    private static final String CANARY_FILENAME = "zip-slip-canary.txt";
+
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting Zip Slip vulnerability test...");
+            
+            // Create a temporary directory for our test
+            File tempDir = new File("/tmp/zip-slip-test");
+            tempDir.mkdirs();
+            File targetDir = new File(tempDir, "target");
+            targetDir.mkdirs();
+            
+            // Path to a file outside the target directory (the canary file)
+            File canaryFile = new File(tempDir, CANARY_FILENAME);
+            
+            System.out.println("Test directory: " + tempDir.getAbsolutePath());
+            System.out.println("Target directory: " + targetDir.getAbsolutePath());
+            System.out.println("Canary file path: " + canaryFile.getAbsolutePath());
+            
+            // Delete the canary file if it exists
+            if (canaryFile.exists()) {
+                canaryFile.delete();
+                System.out.println("Deleted existing canary file");
+            }
+            
+            // Create a malicious zip file with a path traversal entry
+            byte[] zipData = createMaliciousZip("subfolder/../../" + CANARY_FILENAME, CANARY_FILE_CONTENT);
+            System.out.println("Created malicious zip with entry: subfolder/../../" + CANARY_FILENAME);
+            
+            // Save the zip file for debugging
+            File zipFile = new File(targetDir, "malicious.zip");
+            FileOutputStream fos = new FileOutputStream(zipFile);
+            fos.write(zipData);
+            fos.close();
+            System.out.println("Saved malicious zip to: " + zipFile.getAbsolutePath());
+            
+            // Call the vulnerable method directly
+            System.out.println("Calling unzip with targetDir: " + targetDir.getAbsolutePath());
+            
+            // We'll use reflection to call the method to avoid compilation dependencies
+            Class<?> tcmClass = Class.forName("org.hl7.fhir.r5.terminologies.TerminologyCacheManager");
+            java.lang.reflect.Method unzipMethod = tcmClass.getMethod("unzip", java.io.InputStream.class, String.class);
+            unzipMethod.invoke(null, new ByteArrayInputStream(zipData), targetDir.getAbsolutePath());
+            
+            System.out.println("Unzip completed");
+            
+            // Check if the canary file was created outside the target directory
+            boolean vulnerable = canaryFile.exists();
+            
+            if (vulnerable) {
+                System.out.println("VULNERABILITY DETECTED: The canary file was created outside the target directory!");
+                System.out.println("Canary file content: " + readFile(canaryFile));
+                System.exit(1); // Test fails if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. The canary file was not created outside the target directory.");
+                System.exit(0); // Test passes if vulnerability is fixed
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Exception in main: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+    
+    /**
+     * Create a zip file with a malicious entry that attempts path traversal
+     */
+    private static byte[] createMaliciousZip(String entryName, String content) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ZipOutputStream zos = new ZipOutputStream(baos);
+        
+        // Add a malicious entry with path traversal
+        ZipEntry entry = new ZipEntry(entryName);
+        zos.putNextEntry(entry);
+        zos.write(content.getBytes(StandardCharsets.UTF_8));
+        zos.closeEntry();
+        
+        zos.close();
+        return baos.toByteArray();
+    }
+    
+    /**
+     * Read file contents to string
+     */
+    private static String readFile(File file) {
+        try {
+            java.nio.file.Path path = file.toPath();
+            byte[] bytes = java.nio.file.Files.readAllBytes(path);
+            return new String(bytes, StandardCharsets.UTF_8);
+        } catch (IOException e) {
+            return "[Error reading file: " + e.getMessage() + "]";
+        }
+    }
+}
\ No newline at end of file
diff --git a/org.hl7.fhir.validation/src/test/java/org/hl7/fhir/validation/test/ZipSlipVulnerabilityTest.java b/org.hl7.fhir.validation/src/test/java/org/hl7/fhir/validation/test/ZipSlipVulnerabilityTest.java
new file mode 100644
index 000000000..6dd9f54d2
--- /dev/null
+++ b/org.hl7.fhir.validation/src/test/java/org/hl7/fhir/validation/test/ZipSlipVulnerabilityTest.java
@@ -0,0 +1,118 @@
+package org.hl7.fhir.validation.test;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+import org.hl7.fhir.r5.terminologies.TerminologyCacheManager;
+import org.hl7.fhir.utilities.TextFile;
+
+/**
+ * Test case to demonstrate the Zip Slip vulnerability in the project.
+ * This test creates a malicious zip file with path traversal entries
+ * and attempts to extract it using the vulnerable code.
+ */
+public class ZipSlipVulnerabilityTest {
+
+    private static final String CANARY_FILE_CONTENT = "This file was created by the zip slip vulnerability test";
+    private static final String CANARY_FILENAME = "zip-slip-canary.txt";
+    
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting Zip Slip vulnerability test...");
+            
+            // Create a temporary directory for our test
+            File tempDir = new File("/tmp/zip-slip-test");
+            tempDir.mkdirs();
+            File targetDir = new File(tempDir, "target");
+            targetDir.mkdirs();
+            
+            // Path to a file outside the target directory (the canary file)
+            File canaryFile = new File(tempDir, CANARY_FILENAME);
+            
+            System.out.println("Test directory: " + tempDir.getAbsolutePath());
+            System.out.println("Target directory: " + targetDir.getAbsolutePath());
+            System.out.println("Canary file path: " + canaryFile.getAbsolutePath());
+            
+            // Delete the canary file if it exists
+            if (canaryFile.exists()) {
+                canaryFile.delete();
+                System.out.println("Deleted existing canary file");
+            }
+            
+            // Test the TerminologyCacheManager.java vulnerability
+            testTerminologyCacheManagerVulnerability(targetDir.getAbsolutePath(), canaryFile.getAbsolutePath());
+            
+            // Check if the canary file was created outside the target directory
+            boolean vulnerable = canaryFile.exists();
+            
+            if (vulnerable) {
+                System.out.println("VULNERABILITY DETECTED: The canary file was created outside the target directory!");
+                System.out.println("Canary file content: " + TextFile.fileToString(canaryFile.getAbsolutePath()));
+                System.exit(1); // Test fails if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. The canary file was not created outside the target directory.");
+                System.exit(0); // Test passes if vulnerability is fixed
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Exception in main: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+    
+    /**
+     * Test the vulnerability in TerminologyCacheManager.java
+     */
+    private static void testTerminologyCacheManagerVulnerability(String targetDir, String canaryPath) {
+        System.out.println("\nTesting TerminologyCacheManager.java vulnerability...");
+        
+        try {
+            // Create a malicious zip file with a path traversal entry that bypasses the check
+            // The entry name contains path traversal sequences in the middle, not at the beginning
+            byte[] zipData = createMaliciousZip("subfolder/../../" + CANARY_FILENAME, CANARY_FILE_CONTENT);
+            System.out.println("Created malicious zip with entry: subfolder/../../" + CANARY_FILENAME);
+            
+            // Save the zip file for debugging
+            File zipFile = new File(targetDir, "malicious.zip");
+            FileOutputStream fos = new FileOutputStream(zipFile);
+            fos.write(zipData);
+            fos.close();
+            System.out.println("Saved malicious zip to: " + zipFile.getAbsolutePath());
+            
+            // Call the vulnerable method directly
+            System.out.println("Calling TerminologyCacheManager.unzip with targetDir: " + targetDir);
+            TerminologyCacheManager.unzip(new ByteArrayInputStream(zipData), targetDir);
+            System.out.println("TerminologyCacheManager.unzip completed");
+        } catch (Exception e) {
+            System.out.println("Exception during TerminologyCacheManager.unzip: " + e.getMessage());
+            e.printStackTrace();
+        }
+    }
+    
+    /**
+     * Create a zip file with a malicious entry that attempts path traversal
+     */
+    private static byte[] createMaliciousZip(String entryName, String content) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ZipOutputStream zos = new ZipOutputStream(baos);
+        
+        // Add a malicious entry with path traversal
+        ZipEntry entry = new ZipEntry(entryName);
+        zos.putNextEntry(entry);
+        zos.write(content.getBytes(StandardCharsets.UTF_8));
+        zos.closeEntry();
+        
+        zos.close();
+        return baos.toByteArray();
+    }
+}
\ No newline at end of file
