diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 0000000..4336cc1
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/xerial__sqlite-jdbc_CVE-2023-32697_3.41.2.1 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..bdaf147
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,20 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk-17.0.12 $WORKSPACE_BASE/java-env/jdk-17.0.12
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk-17.0.12/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk-17.0.12
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/xerial__sqlite-jdbc_CVE-2023-32697_3.41.2.1 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Run our vulnerability test
+CMD ["java", "-cp", "target/sqlite-jdbc-3.41.2.1.jar:target/test-classes", "org.sqlite.CVE_2023_32697_Test"]
\ No newline at end of file
diff --git a/src/test/java/org/sqlite/CVE_2023_32697_Test.java b/src/test/java/org/sqlite/CVE_2023_32697_Test.java
new file mode 100644
index 0000000..a84586e
--- /dev/null
+++ b/src/test/java/org/sqlite/CVE_2023_32697_Test.java
@@ -0,0 +1,112 @@
+package org.sqlite;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.sql.Connection;
+import java.sql.DriverManager;
+import java.sql.SQLException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Test for CVE-2023-32697 - Remote Code Execution vulnerability in sqlite-jdbc
+ * when JDBC URL is attacker controlled.
+ */
+public class CVE_2023_32697_Test {
+
+    private static final int PORT = 8099;
+    private static final String MALICIOUS_URL = "jdbc:sqlite::resource:http://localhost:" + PORT + "/malicious.db";
+    private static final CountDownLatch serverStarted = new CountDownLatch(1);
+    private static final CountDownLatch connectionAttempted = new CountDownLatch(1);
+    private static boolean vulnerabilityDetected = false;
+
+    public static void main(String[] args) {
+        System.out.println("Starting CVE-2023-32697 test...");
+        
+        // Start a simple HTTP server in a separate thread
+        Thread serverThread = new Thread(() -> startMaliciousServer());
+        serverThread.setDaemon(true);
+        serverThread.start();
+        
+        try {
+            // Wait for server to start
+            if (!serverStarted.await(5, TimeUnit.SECONDS)) {
+                System.err.println("Failed to start test server");
+                System.exit(1);
+            }
+            
+            System.out.println("Attempting to connect to malicious URL: " + MALICIOUS_URL);
+            
+            try {
+                // Attempt to connect using the malicious URL
+                Connection conn = DriverManager.getConnection(MALICIOUS_URL);
+                // If we get here without exception, the connection was successful
+                // This might indicate the vulnerability exists but our test didn't trigger it properly
+                System.out.println("Connection succeeded without exception");
+                conn.close();
+            } catch (SQLException e) {
+                // Check if the exception is related to our test server
+                if (e.getMessage().contains("failed to load http://localhost")) {
+                    System.out.println("Connection attempt reached our test server");
+                } else {
+                    System.out.println("Connection failed with unexpected error: " + e.getMessage());
+                }
+            } finally {
+                // Signal that we've attempted the connection
+                connectionAttempted.countDown();
+            }
+            
+            // Wait for the server to process the connection
+            if (!connectionAttempted.await(5, TimeUnit.SECONDS)) {
+                System.err.println("Connection attempt timed out");
+                System.exit(1);
+            }
+            
+            // Check if vulnerability was detected
+            if (vulnerabilityDetected) {
+                System.out.println("VULNERABILITY DETECTED: The library attempted to download and execute from a remote URL");
+                System.exit(1); // Test fails if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. The library properly rejected the malicious URL.");
+                System.exit(0); // Test passes if vulnerability does not exist
+            }
+            
+        } catch (InterruptedException e) {
+            System.err.println("Test was interrupted: " + e.getMessage());
+            System.exit(1);
+        }
+    }
+    
+    private static void startMaliciousServer() {
+        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
+            System.out.println("Started test server on port " + PORT);
+            serverStarted.countDown();
+            
+            // Wait for a connection
+            Socket clientSocket = serverSocket.accept();
+            System.out.println("Received connection from client");
+            
+            // If we get a connection, the vulnerability exists
+            vulnerabilityDetected = true;
+            
+            // Send a minimal HTTP response with a fake SQLite database
+            String response = "HTTP/1.1 200 OK\r\n" +
+                              "Content-Type: application/octet-stream\r\n" +
+                              "Content-Length: 16\r\n" +
+                              "\r\n" +
+                              "SQLite format 3\0"; // Minimal SQLite header
+            
+            clientSocket.getOutputStream().write(response.getBytes());
+            clientSocket.getOutputStream().flush();
+            clientSocket.close();
+            
+        } catch (IOException e) {
+            System.err.println("Server error: " + e.getMessage());
+        }
+    }
+}
