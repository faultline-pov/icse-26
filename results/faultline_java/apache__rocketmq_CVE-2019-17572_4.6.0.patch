diff --git a/.Dockerfile.backup b/.Dockerfile.backup
new file mode 100644
index 0000000..d95e8a2
--- /dev/null
+++ b/.Dockerfile.backup
@@ -0,0 +1,17 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/apache__rocketmq_CVE-2019-17572_4.6.0 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
diff --git a/.build_diff.patch b/.build_diff.patch
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/.build_diff.patch
@@ -0,0 +1 @@
+
diff --git a/DirectoryTraversalTest.java b/DirectoryTraversalTest.java
new file mode 100644
index 0000000..dd2dc63
--- /dev/null
+++ b/DirectoryTraversalTest.java
@@ -0,0 +1,58 @@
+import org.apache.rocketmq.store.ConsumeQueue;
+import java.io.File;
+
+public class DirectoryTraversalTest {
+    public static void main(String[] args) {
+        try {
+            System.out.println("Starting Directory Traversal Vulnerability Test");
+            
+            // Set up the store path
+            String storeRootPath = "/tmp/rmqstore";
+            String consumeQueuePath = storeRootPath + "/consumequeue";
+            String maliciousTopic = "../../../malicious_dir";
+            int queueId = 0;
+            
+            // Create directories
+            new File(storeRootPath).mkdirs();
+            new File(consumeQueuePath).mkdirs();
+            
+            // Delete any existing malicious directory from previous test runs
+            File maliciousDir = new File(storeRootPath, "malicious_dir");
+            if (maliciousDir.exists()) {
+                maliciousDir.delete();
+                System.out.println("Deleted existing malicious directory");
+            }
+            
+            // Verify directory doesn't exist before the test
+            if (maliciousDir.exists()) {
+                System.out.println("Error: Malicious directory exists before test");
+                System.exit(1);
+            }
+            
+            System.out.println("Creating ConsumeQueue with malicious topic: " + maliciousTopic);
+            
+            // Create a ConsumeQueue with the malicious topic name
+            // This directly tests the vulnerable code path in ConsumeQueue.java
+            ConsumeQueue queue = new ConsumeQueue(maliciousTopic, queueId, consumeQueuePath, 1000, null);
+            
+            // Sleep to allow time for directory creation
+            Thread.sleep(1000);
+            
+            // Check if the directory was created outside the intended location
+            boolean vulnerabilityExists = maliciousDir.exists();
+            
+            if (vulnerabilityExists) {
+                System.out.println("VULNERABILITY DETECTED: Directory created outside intended location: " + maliciousDir.getAbsolutePath());
+                System.exit(1); // Exit with failure code if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. Directory was not created outside intended location.");
+                System.exit(0); // Exit with success code if no vulnerability
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Exception during test: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Dockerfile.vuln b/Dockerfile.vuln
new file mode 100644
index 0000000..ea52c8e
--- /dev/null
+++ b/Dockerfile.vuln
@@ -0,0 +1,25 @@
+FROM ubuntu:22.04
+ENV DEBIAN_FRONTEND=noninteractive
+RUN apt -y update
+RUN apt install -y curl unzip wget git build-essential
+RUN mkdir -p /java-env
+ENV WORKSPACE_BASE="/"
+COPY ./java-env/jdk1.8.0_202 $WORKSPACE_BASE/java-env/jdk1.8.0_202
+COPY ./java-env/apache-maven-3.5.0 $WORKSPACE_BASE/java-env/apache-maven-3.5.0
+ENV PATH=$PATH:$WORKSPACE_BASE/java-env/apache-maven-3.5.0/bin:$WORKSPACE_BASE/java-env/jdk1.8.0_202/bin
+ENV JAVA_HOME=$WORKSPACE_BASE/java-env/jdk1.8.0_202
+ENV PATH=$PATH:$JAVA_HOME/bin
+COPY ./project-sources/apache__rocketmq_CVE-2019-17572_4.6.0 /project
+COPY ./resources/my-agent/target/agent-fat.jar /project/.agent-fat.jar
+ENV JAVA_TOOL_OPTIONS="-javaagent:/project/.agent-fat.jar"
+WORKDIR /project
+# Do not modify anything above this line
+
+# Build the project
+RUN mvn clean package -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Dspotbugs.skip -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true -Dspotless.check.skip=true -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn
+
+# Make the test script executable
+RUN chmod +x /project/run_test.sh
+
+# Run the vulnerability test
+CMD ["/bin/bash", "/project/run_test.sh"]
\ No newline at end of file
diff --git a/run_test.sh b/run_test.sh
new file mode 100644
index 0000000..0695f39
--- /dev/null
+++ b/run_test.sh
@@ -0,0 +1,12 @@
+#!/bin/bash
+
+# Create test directories
+mkdir -p /tmp/rmqstore/consumequeue
+mkdir -p /tmp/rmqstore/commitlog
+mkdir -p /tmp/rmqstore/index
+
+# Compile the test
+javac -cp "store/target/classes:common/target/classes:logging/target/classes:$(find /root/.m2/repository -name "*.jar" | tr "\n" ":")" DirectoryTraversalTest.java
+
+# Run the test
+java -cp ".:store/target/classes:common/target/classes:logging/target/classes:$(find /root/.m2/repository -name "*.jar" | tr "\n" ":")" DirectoryTraversalTest
\ No newline at end of file
diff --git a/run_vulnerability_test.sh b/run_vulnerability_test.sh
new file mode 100644
index 0000000..dfc1038
--- /dev/null
+++ b/run_vulnerability_test.sh
@@ -0,0 +1,41 @@
+#!/bin/bash
+
+# Start the name server
+echo "Starting Name Server..."
+mkdir -p /tmp/rmqstore
+mkdir -p /tmp/rmqlogs
+
+# Find all dependency jars
+DEPENDENCY_JARS=$(find /project -name "*.jar" | grep -v "test" | tr '\n' ':')
+
+# Start the name server in the background
+java -cp "namesrv/target/classes:namesrv/target/dependency/*:common/target/classes:remoting/target/classes:logging/target/classes:$DEPENDENCY_JARS" org.apache.rocketmq.namesrv.NamesrvStartup > /tmp/rmqlogs/namesrv.log 2>&1 &
+NAMESRV_PID=$!
+
+# Wait for name server to start
+sleep 5
+echo "Name Server started with PID: $NAMESRV_PID"
+
+# Start the broker in the background
+echo "Starting Broker..."
+java -cp "broker/target/classes:broker/target/dependency/*:common/target/classes:store/target/classes:remoting/target/classes:logging/target/classes:client/target/classes:filter/target/classes:srvutil/target/classes:$DEPENDENCY_JARS" org.apache.rocketmq.broker.BrokerStartup -n localhost:9876 > /tmp/rmqlogs/broker.log 2>&1 &
+BROKER_PID=$!
+
+# Wait for broker to start
+sleep 10
+echo "Broker started with PID: $BROKER_PID"
+
+# Run the vulnerability test
+echo "Running vulnerability test..."
+java -cp "test/target/test-classes:client/target/classes:common/target/classes:remoting/target/classes:logging/target/classes:$DEPENDENCY_JARS" org.apache.rocketmq.test.vulnerability.DirectoryTraversalVulnerabilityTest
+TEST_RESULT=$?
+
+# Kill the broker and name server
+kill $BROKER_PID
+kill $NAMESRV_PID
+
+# Wait for processes to terminate
+sleep 2
+
+# Return the test result
+exit $TEST_RESULT
diff --git a/test/src/test/java/org/apache/rocketmq/test/vulnerability/DirectoryTraversalTest.java b/test/src/test/java/org/apache/rocketmq/test/vulnerability/DirectoryTraversalTest.java
new file mode 100644
index 0000000..ef05bea
--- /dev/null
+++ b/test/src/test/java/org/apache/rocketmq/test/vulnerability/DirectoryTraversalTest.java
@@ -0,0 +1,143 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.test.vulnerability;
+
+import java.io.File;
+import java.util.UUID;
+
+import org.apache.rocketmq.client.exception.MQClientException;
+import org.apache.rocketmq.client.producer.DefaultMQProducer;
+import org.apache.rocketmq.client.producer.SendResult;
+import org.apache.rocketmq.common.message.Message;
+
+/**
+ * Test for directory traversal vulnerability (CVE-2019-17572)
+ */
+public class DirectoryTraversalTest {
+    
+    public static void main(String[] args) {
+        DefaultMQProducer producer = null;
+        try {
+            System.out.println("Starting Directory Traversal Vulnerability Test");
+            
+            // Generate unique topic names
+            String uniqueId = UUID.randomUUID().toString().substring(0, 8);
+            String maliciousTopicName = "../../../malicious_topic_" + uniqueId;
+            String normalTopicName = "normal_topic_" + uniqueId;
+            
+            // Create producer
+            producer = new DefaultMQProducer("ProducerGroupName");
+            producer.setNamesrvAddr("localhost:9876"); // Default nameserver address
+            producer.setCreateTopicKey("TBW102"); // Default topic
+            producer.setRetryTimesWhenSendFailed(3); // Retry 3 times
+            producer.setSendMsgTimeout(10000); // 10 second timeout
+            
+            System.out.println("Starting producer...");
+            producer.start();
+            System.out.println("Producer started successfully");
+            
+            // Get broker store root directory
+            String brokerStoreRoot = "/tmp/rmqstore";
+            System.out.println("Broker store root: " + brokerStoreRoot);
+            
+            // Calculate the directory that would be created by the malicious topic
+            File consumeQueueDir = new File(brokerStoreRoot, "consumequeue");
+            File parentDir = consumeQueueDir.getParentFile();
+            File traversalDir = new File(parentDir, "malicious_topic_" + uniqueId);
+            File normalDir = new File(consumeQueueDir, normalTopicName);
+            
+            System.out.println("Normal directory path: " + normalDir.getAbsolutePath());
+            System.out.println("Traversal directory path: " + traversalDir.getAbsolutePath());
+            
+            // Delete any existing directories from previous test runs
+            if (traversalDir.exists()) {
+                traversalDir.delete();
+                System.out.println("Deleted existing traversal directory");
+            }
+            if (normalDir.exists()) {
+                normalDir.delete();
+                System.out.println("Deleted existing normal directory");
+            }
+            
+            // Verify directories don't exist before the test
+            if (traversalDir.exists()) {
+                System.out.println("Error: Traversal directory exists before test");
+                System.exit(1);
+            }
+            if (normalDir.exists()) {
+                System.out.println("Error: Normal directory exists before test");
+                System.exit(1);
+            }
+            
+            // Send a message with a normal topic name
+            System.out.println("Sending message with normal topic: " + normalTopicName);
+            Message normalMessage = new Message(normalTopicName, "TAG", "Normal message content".getBytes());
+            SendResult normalResult = producer.send(normalMessage);
+            System.out.println("Sent message with normal topic: " + normalTopicName + ", result: " + normalResult);
+            
+            // Send a message with a malicious topic name containing directory traversal
+            System.out.println("Sending message with malicious topic: " + maliciousTopicName);
+            Message maliciousMessage = new Message(maliciousTopicName, "TAG", "Malicious message content".getBytes());
+            SendResult maliciousResult = producer.send(maliciousMessage);
+            System.out.println("Sent message with malicious topic: " + maliciousTopicName + ", result: " + maliciousResult);
+            
+            // Sleep to allow time for directory creation
+            System.out.println("Waiting for directory creation...");
+            Thread.sleep(5000);
+            
+            // Check if the normal directory was created (should be true)
+            System.out.println("Checking if normal directory was created...");
+            if (!normalDir.exists()) {
+                System.out.println("Error: Normal directory was not created. Test inconclusive.");
+                System.exit(1);
+            } else {
+                System.out.println("Normal directory was created as expected: " + normalDir.getAbsolutePath());
+            }
+            
+            // Check if the traversal directory was created outside the intended location
+            System.out.println("Checking if traversal directory was created...");
+            boolean vulnerabilityExists = traversalDir.exists();
+            
+            if (vulnerabilityExists) {
+                System.out.println("VULNERABILITY DETECTED: Directory created outside intended location: " + traversalDir.getAbsolutePath());
+                System.exit(1); // Exit with failure code if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. Directory was not created outside intended location.");
+                System.exit(0); // Exit with success code if no vulnerability
+            }
+            
+        } catch (MQClientException e) {
+            System.out.println("MQClientException: " + e.getMessage() + ", ResponseCode: " + e.getResponseCode());
+            e.printStackTrace();
+            System.exit(1);
+        } catch (Exception e) {
+            System.out.println("Exception during test: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        } finally {
+            if (producer != null) {
+                try {
+                    producer.shutdown();
+                    System.out.println("Producer shutdown");
+                } catch (Exception e) {
+                    System.out.println("Error shutting down producer: " + e.getMessage());
+                }
+            }
+        }
+    }
+}
diff --git a/test/src/test/java/org/apache/rocketmq/test/vulnerability/DirectoryTraversalVulnerabilityTest.java b/test/src/test/java/org/apache/rocketmq/test/vulnerability/DirectoryTraversalVulnerabilityTest.java
new file mode 100644
index 0000000..269b0a3
--- /dev/null
+++ b/test/src/test/java/org/apache/rocketmq/test/vulnerability/DirectoryTraversalVulnerabilityTest.java
@@ -0,0 +1,122 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.test.vulnerability;
+
+import java.io.File;
+import java.util.UUID;
+
+import org.apache.rocketmq.client.producer.DefaultMQProducer;
+import org.apache.rocketmq.common.message.Message;
+
+/**
+ * Test case for directory traversal vulnerability (CVE-2019-17572)
+ * This test verifies if a malicious topic name containing directory traversal characters
+ * can create directories outside the intended location.
+ */
+public class DirectoryTraversalVulnerabilityTest {
+    
+    public static void main(String[] args) {
+        DefaultMQProducer producer = null;
+        try {
+            System.out.println("Starting Directory Traversal Vulnerability Test");
+            
+            // Generate unique topic names
+            String uniqueId = UUID.randomUUID().toString().substring(0, 8);
+            String maliciousTopicName = "../../../malicious_topic_" + uniqueId;
+            String normalTopicName = "normal_topic_" + uniqueId;
+            
+            // Create producer
+            producer = new DefaultMQProducer("ProducerGroupName");
+            producer.setNamesrvAddr("localhost:9876"); // Default nameserver address
+            producer.setCreateTopicKey("TBW102"); // Default topic
+            producer.start();
+            System.out.println("Producer started");
+            
+            // Get broker store root directory (typically /root/store)
+            // This is the default location in the broker configuration
+            String brokerStoreRoot = "/tmp/rmqstore";
+            System.out.println("Broker store root: " + brokerStoreRoot);
+            
+            // Calculate the directory that would be created by the malicious topic
+            File consumeQueueDir = new File(brokerStoreRoot, "consumequeue");
+            File parentDir = consumeQueueDir.getParentFile();
+            File traversalDir = new File(parentDir, "malicious_topic_" + uniqueId);
+            File normalDir = new File(consumeQueueDir, normalTopicName);
+            
+            // Delete any existing directories from previous test runs
+            if (traversalDir.exists()) {
+                traversalDir.delete();
+                System.out.println("Deleted existing traversal directory");
+            }
+            if (normalDir.exists()) {
+                normalDir.delete();
+                System.out.println("Deleted existing normal directory");
+            }
+            
+            // Verify directories don't exist before the test
+            if (traversalDir.exists()) {
+                System.out.println("Error: Traversal directory exists before test");
+                System.exit(1);
+            }
+            if (normalDir.exists()) {
+                System.out.println("Error: Normal directory exists before test");
+                System.exit(1);
+            }
+            
+            // Send a message with a normal topic name
+            Message normalMessage = new Message(normalTopicName, "TAG", "Normal message content".getBytes());
+            producer.send(normalMessage);
+            System.out.println("Sent message with normal topic: " + normalTopicName);
+            
+            // Send a message with a malicious topic name containing directory traversal
+            Message maliciousMessage = new Message(maliciousTopicName, "TAG", "Malicious message content".getBytes());
+            producer.send(maliciousMessage);
+            System.out.println("Sent message with malicious topic: " + maliciousTopicName);
+            
+            // Sleep to allow time for directory creation
+            Thread.sleep(2000);
+            
+            // Check if the normal directory was created (should be true)
+            if (!normalDir.exists()) {
+                System.out.println("Error: Normal directory was not created. Test inconclusive.");
+                System.exit(1);
+            }
+            
+            // Check if the traversal directory was created outside the intended location
+            boolean vulnerabilityExists = traversalDir.exists();
+            
+            if (vulnerabilityExists) {
+                System.out.println("VULNERABILITY DETECTED: Directory created outside intended location: " + traversalDir.getAbsolutePath());
+                System.exit(1); // Exit with failure code if vulnerability exists
+            } else {
+                System.out.println("No vulnerability detected. Directory was not created outside intended location.");
+                System.exit(0); // Exit with success code if no vulnerability
+            }
+            
+        } catch (Exception e) {
+            System.out.println("Exception during test: " + e.getMessage());
+            e.printStackTrace();
+            System.exit(1);
+        } finally {
+            if (producer != null) {
+                producer.shutdown();
+                System.out.println("Producer shutdown");
+            }
+        }
+    }
+}
diff --git a/test/src/test/java/org/apache/rocketmq/test/vulnerability/DirectoryTraversalVulnerabilityTestRunner.java b/test/src/test/java/org/apache/rocketmq/test/vulnerability/DirectoryTraversalVulnerabilityTestRunner.java
new file mode 100644
index 0000000..2f971fb
--- /dev/null
+++ b/test/src/test/java/org/apache/rocketmq/test/vulnerability/DirectoryTraversalVulnerabilityTestRunner.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.test.vulnerability;
+
+import org.junit.runner.JUnitCore;
+import org.junit.runner.Result;
+
+/**
+ * Standalone runner for the DirectoryTraversalVulnerabilityTest
+ * This class provides a main method to run the test from the command line
+ */
+public class DirectoryTraversalVulnerabilityTestRunner {
+    public static void main(String[] args) {
+        System.out.println("Starting Directory Traversal Vulnerability Test");
+        Result result = JUnitCore.runClasses(DirectoryTraversalVulnerabilityTest.class);
+        
+        if (result.wasSuccessful()) {
+            System.out.println("Test PASSED: No vulnerability detected");
+            System.exit(0); // Exit with success code
+        } else {
+            System.out.println("Test FAILED: Vulnerability detected");
+            result.getFailures().forEach(failure -> {
+                System.out.println(failure.toString());
+                if (failure.getException() != null) {
+                    failure.getException().printStackTrace();
+                }
+            });
+            System.exit(1); // Exit with failure code
+        }
+    }
+}
