from vuln_agent.helpers import *
import prettytable
import json

class Evaluation:
    def __init__(self, dataset, project_name, workdir, logger):
        self.dataset = dataset
        self.project_name = project_name
        self.workdir = workdir
        self.logger = logger
    
    def get_commit_info(self):
        if self.dataset == 'cwe-bench-java':
            commit_json_path = Path(self.workdir) / f"../../../data/processed/{self.project_name}/.commit_info.json"
            if not commit_json_path.exists():
                self.logger.log_failure(f"Commit info file {commit_json_path} does not exist.")
                return None
            with open(commit_json_path, 'r') as commit_file:
                return json.load(commit_file)
        elif self.dataset == 'primevul':
            info_path = Path(self.workdir) / f"../../../processed_info.json"
            if not info_path.exists():
                self.logger.log_failure(f"Commit info file {info_path} does not exist.")
                return None
            with open(info_path, 'r') as info_file:
                info = json.load(info_file)
            if self.project_name not in info:
                self.logger.log_failure(f"Project {self.project_name} not found in commit info.")
                return None
            return {
                'fix_commit': info[self.project_name]['fix_commit'],
                'vulnerable_commit': info[self.project_name]['parent_commit']
            }
        else:
            self.logger.log_failure(f"Unknown dataset: {self.dataset}")
            return None

    def get_method_info(self):
        if self.dataset == 'cwe-bench-java':
            method_info_path = Path(self.workdir) / f"../../../data/processed/{self.project_name}/.method_info.csv"
            if not method_info_path.exists():
                self.logger.log_failure(f"Method info file {method_info_path} does not exist.")
                return None
            with open(method_info_path, 'r') as method_file:
                return method_file.read().strip()
        elif self.dataset == 'primevul':
            # For PrimeVul, we assume method info is not needed or handled differently
            return None

    def evaluate(self, instrumentation=False):
        """
        Evaluate the test case generated by the agent.
        """
        self.logger.log_status("Evaluating test case...")

        context_root = "../.." if self.dataset == 'cwe-bench-java' else "."

        commit_info = self.get_commit_info()
        if not commit_info:
            return {"status": "Failed", "error": "No commit info found."}

        os.chdir(self.workdir)
        try:
            run(f"git checkout {commit_info['vulnerable_commit']}",
                timeout=200, logger=self.logger)
        except RunException as e:
            self.logger.log_failure(f"Checkout failed: {truncate_reverse(str(e), 10000)}")
            return {"status": "Failed", "error": f"Checkout failed: {truncate_reverse(str(e), 10000)}"}

        try:
            run(f"docker build -f ./Dockerfile.vuln -t {self.project_name.lower()}_vuln {context_root}",
                timeout=600,
                logger=self.logger)
        except RunException as e:
            self.logger.log_failure(f"Build failed: {truncate_reverse(str(e), 10000)}")
            return {"status": "Incorrect", "error": f"Build failed: {truncate_reverse(str(e), 10000)}"}

        if instrumentation:
            method_info = self.get_method_info()
            # Replace newlines with \\n
            if method_info:
                method_info = method_info.replace("\n", "\\n")
                instrumentation_flag = f"-e METHODS_TO_INSTRUMENT=\"{method_info}\""
            else:
                instrumentation_flag = ""
            reached_vuln_method = False
        else:
            instrumentation_flag = ""
            reached_vuln_method = None
        os.chdir(self.workdir)
        failed = False
        try:
            stdout = run(f"docker run --rm {instrumentation_flag} {self.project_name.lower()}_vuln",
                timeout=200,
                logger=self.logger)
            if instrumentation:
                if "[INSTRUMENTATION]" in stdout:
                    self.logger.log_success(f"Test reached the vulnerable method")
                    reached_vuln_method = True
                else:
                    self.logger.log_failure(f"Test did not reach the vulnerable method") 
        except RunException as e:
            self.logger.log_success(f"Test failed in vulnerable state")
            failed = True
            if instrumentation:
                if "[INSTRUMENTATION]" in str(e):
                    self.logger.log_success(f"Test reached the vulnerable method")
                    reached_vuln_method = True
                else:
                    self.logger.log_failure(f"Test did not reach the vulnerable method")
                    return {"status": "Incorrect",
                            "error": f"Test did not reach the vulnerable method.\n{truncate_reverse(str(e), 10000)}",
                            "reached_vuln_method": reached_vuln_method}
        
        if not failed:
            self.logger.log_failure("Test passed in vulnerable state")
            return {"status": "Incorrect",
                    "error": ("Test passed in vulnerable state instead of failing.\n"
                              f"STDOUT:\n\n{truncate_reverse(stdout, 10000)}"),
                    "reached_vuln_method": reached_vuln_method}
        
        os.chdir(self.workdir)
        try:
            run(f"git checkout {commit_info['fix_commit']}", logger=self.logger)
        except RunException as e:
            self.logger.log_failure(f"Checkout failed: {truncate_reverse(str(e), 10000)}")
            try:
                run(f"git stash && git checkout {commit_info['fix_commit']} && git stash pop", logger=self.logger)
            except RunException as e2:
                self.logger.log_failure(f"Stash pop failed: {truncate_reverse(str(e2), 10000)}")
                run(f"git reset --merge && git checkout {commit_info['vulnerable_commit']}", logger=self.logger)
                return {"status": "Incorrect",
                        "error": ("An existing file was modified, that is preventing Git checkout.\n"
                                   f"{truncate_reverse(str(e), 10000)}"),
                        "reached_vuln_method": reached_vuln_method}
    
        os.chdir(self.workdir)
        if Path(".build_diff.patch").exists():
            try:
                run("git apply --allow-empty --whitespace=fix .build_diff.patch", logger=self.logger)
            except RunException as e:
                self.logger.log_failure(f"Applying diff failed: {truncate_reverse(str(e), 10000)}")
                run(f"git checkout {commit_info['vulnerable_commit']}", logger=self.logger)
                return {"status": "Failed", "error": f"Applying diff failed: {truncate_reverse(str(e), 10000)}",
                        "reached_vuln_method": reached_vuln_method}
        
        os.chdir(self.workdir)
        succeeded = True
        error_msg = ""
        try:
            run(f"docker build -f ./Dockerfile.vuln -t {self.project_name.lower()}_vuln {context_root}",
                timeout=600,
                logger=self.logger)
        except RunException as e:
            self.logger.log_failure(f"Build failed: {truncate_reverse(str(e), 10000)}")
            error_msg = ("Build failed in the fixed state. This probably means that "
                          "a class or method that the test depends on was removed or renamed.\n"
                          "The test should avoid a dependency on this class or method. Error log:\n"
                          f"{truncate_reverse(str(e), 10000)}")
            succeeded = False

        os.chdir(self.workdir)
        if succeeded:
            try:
                stdout = run(f"docker run --rm {instrumentation_flag} {self.project_name.lower()}_vuln",
                    timeout=200,
                    logger=self.logger)
                if instrumentation:
                    if "[INSTRUMENTATION]" in stdout:
                        self.logger.log_success(f"Test reached the vulnerable method")
                        reached_vuln_method = True
                    else:
                        self.logger.log_failure(f"Test did not reach the vulnerable method")
            except RunException as e:
                self.logger.log_failure(f"Test failed in fixed state.\n{truncate_reverse(str(e), 10000)}")
                error_msg = f"Test failed in fixed state.\n{truncate_reverse(str(e), 10000)}" 
                succeeded = False
                if instrumentation:
                    if "[INSTRUMENTATION]" in str(e):
                        self.logger.log_success(f"Test reached the vulnerable method")
                        reached_vuln_method = True
                    else:
                        self.logger.log_failure(f"Test did not reach the vulnerable method")

        os.chdir(self.workdir)
        try:
            run(f"git checkout {commit_info['vulnerable_commit']}", logger=self.logger)
        except RunException as e:
            self.logger.log_failure(f"Checkout failed: {truncate_reverse(str(e), 10000)}")
            try:
                run(f"git stash && git checkout {commit_info['vulnerable_commit']} && git stash pop", logger=self.logger)
            except RunException as e2:
                self.logger.log_failure(f"Revert failed: {truncate_reverse(str(e2), 10000)}")
                run(f"git reset --merge && git checkout {commit_info['vulnerable_commit']}", logger=self.logger)
                return {"status": "Incorrect",
                        "error": (f"Revert failed: {truncate_reverse(str(e), 10000)}"),
                        "reached_vuln_method": reached_vuln_method}

        os.chdir(self.workdir)
        if Path(".build_diff.patch").exists():
            try:
                run("git apply --allow-empty --whitespace=fix -R .build_diff.patch",
                    timeout=200,
                    logger=self.logger)
            except RunException as e:
                self.logger.log_failure(f"Reversing build diff failed: {truncate_reverse(str(e), 10000)}")
                return {"status": "Failed",
                        "error": f"Reversing build diff failed: {truncate_reverse(str(e), 10000)}",
                        "reached_vuln_method": reached_vuln_method}

        if not succeeded:
            return {"status": "Incorrect", "error": error_msg, "reached_vuln_method": reached_vuln_method}

        return {"status": "Correct", "reached_vuln_method": reached_vuln_method}


if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='Vuln Agent - generating vulnerability test cases')
    parser.add_argument('--dataset',    type=str,     default='cwe-bench-java', help='Dataset to use')
    parser.add_argument("--filter",     nargs="+",    type=str)
    parser.add_argument('--openhands',  action='store_true', help='Evaluate OpenHands')
    parser.add_argument('--no_flow', action='store_true', help='Results without flow analysis')
    parser.add_argument('--no_branch', action='store_true', help='Results without branch analysis')
    args = parser.parse_args()

    cwd = Path.cwd().absolute()
    logdir = cwd / "logs" if not args.openhands else cwd / "openhands_logs"
    if not logdir.exists():
        raise ValueError(f"{logdir} does not exist")

    workdir_name = "openhands_workdir" if args.openhands else "workdir"
    if args.no_flow:
        workdir_name += "_no_flow"
    if args.no_branch:
        workdir_name += "_no_branch"

    print(f"Using workdir {workdir_name}")

    if args.dataset == 'cwe-bench-java':
        project_dir = Path(f'data/cwe-bench-java/{workdir_name}/project-sources')
        if not project_dir.exists():
            raise ValueError(f"{project_dir} does not exist")
    elif args.dataset == 'primevul':
        project_dir = Path(f'data/primevul/{workdir_name}/project-sources')
        if not project_dir.exists():
            raise ValueError(f"{project_dir} does not exist")
    else:
        raise ValueError(f"Unknown dataset: {args.dataset}")

    project_slugs = list(Path(project_dir).glob("*/"))
    selected_slugs = project_slugs.copy()
    if args.filter is not None and args.filter != ["*"] and len(args.filter) > 0:
        selected_slugs = [slug for slug in selected_slugs if any(f in slug.name for f in args.filter)]

    if args.filter is None or args.filter == ["*"]:
        # Only evaluate projects that have been processed
        processed_projects = set()
        for log_file in logdir.glob('*'):
            project_name = '_'.join(log_file.name.split('_')[:-2])
            if project_name:
                processed_projects.add(project_name)
        selected_slugs = [slug for slug in selected_slugs if slug.name in processed_projects]
    
    results = []

    result_file_name = "validation_results"
    if args.no_flow:
        result_file_name += "_no_flow"
    if args.no_branch:
        result_file_name += "_no_branch"
    result_file = logdir / f'{result_file_name}.jsonl'

    if not os.path.exists(result_file):
        with open(result_file, 'w') as f:
            f.write("")

    for slug in selected_slugs:
        os.chdir(cwd)
        with open(result_file, 'r') as f:
            existing_results = [json.loads(line) for line in f.readlines()]
        if slug.name in [result['project_name'] for result in existing_results]:
            prYellow(f"Skipping {slug.name} as it has already been evaluated.")
            continue
        else:
            this_result = {
                "project_name": slug.name,
                "status": "Pending",
                "message": "",
                "reached_vuln_method": None
            }
            with open(result_file, 'a') as f:
                f.write(json.dumps(this_result) + "\n")
        print(f"Evaluating project: {slug.name}")
        workdir = slug.absolute()

        logger = DummyLogger()
        evaluation = Evaluation(dataset=args.dataset,
                                project_name=slug.name,
                                workdir=workdir,
                                logger=logger)
        if args.dataset == 'cwe-bench-java':
            result = evaluation.evaluate(instrumentation=True)
        elif args.dataset == 'primevul':
            result = evaluation.evaluate(instrumentation=True) # Added instrumentation for primevul also now.
        if result["status"] == "Failed":
            prRed(f"Evaluation failed:\n{truncate(result['error'], 50)}")
        elif result["status"] == "Incorrect":
            prRed(f"Evaluation incorrect:\n{truncate(result['error'], 50)}")
        else:
            prGreen("Evaluation passed successfully.")
        this_result = {
            "project_name": slug.name,
            "status": result["status"],
            "message": result.get("error", ""),
            "reached_vuln_method": result.get("reached_vuln_method", None),
        }
        results.append(this_result)
        with open(result_file, 'r') as f:
            existing_results = [json.loads(line) for line in f.readlines()]
        existing_results = [res for res in existing_results if res['project_name'] != slug.name]
        existing_results.append(this_result)
        with open(result_file, 'w') as f:
            for res in existing_results:
                f.write(json.dumps(res) + "\n")

    table = prettytable.PrettyTable()
    table.field_names = ["Project", "Status", "Message", "Reached Vulnerable Method"]
    for result in results:
        table.add_row([result["project_name"], result["status"], truncate(result["message"], 50), result["reached_vuln_method"]])
    print(table)