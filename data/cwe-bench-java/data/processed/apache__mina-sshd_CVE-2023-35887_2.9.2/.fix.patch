--- a/sshd-sftp/src/main/java/org/apache/sshd/sftp/server/SftpSubsystem.java
+++ b/sshd-sftp/src/main/java/org/apache/sshd/sftp/server/SftpSubsystem.java
@@ -686,7 +686,7 @@ public class SftpSubsystem
             // the upstream server decide.
             if (!(file instanceof SftpPath)) {
                 LinkOption[] options = getPathResolutionLinkOption(SftpConstants.SSH_FXP_READDIR, "", file);
-                Boolean status = IoUtils.checkFileExists(file, options);
+                Boolean status = IoUtils.checkFileExistsAnySymlinks(file, !IoUtils.followLinks(options));
                 if (status == null) {
                     throw new AccessDeniedException(file.toString(), file.toString(), "Cannot determine existence of read-dir");
                 }
@@ -747,7 +747,7 @@ public class SftpSubsystem
     @Override
     protected String doOpenDir(int id, String path, Path dir, LinkOption... options) throws IOException {
         SftpPathImpl.withAttributeCache(dir, p -> {
-            Boolean status = IoUtils.checkFileExists(p, options);
+            Boolean status = IoUtils.checkFileExistsAnySymlinks(p, !IoUtils.followLinks(options));
             if (status == null) {
                 throw signalOpenFailure(id, path, p, true,
                         new AccessDeniedException(p.toString(), p.toString(), "Cannot determine open-dir existence"));
@@ -807,7 +807,9 @@ public class SftpSubsystem
         Path file = fileHandle.getFile();
         LinkOption[] options = accessor.resolveFileAccessLinkOptions(
                 this, file, SftpConstants.SSH_FXP_FSTAT, "", true);
-        return resolveFileAttributes(file, flags, options);
+
+        boolean followLinks = resolvePathResolutionFollowLinks(SftpConstants.SSH_FXP_FSTAT, handle, file);
+        return resolveFileAttributes(file, flags, followLinks, options);
     }
 
     @Override

--- a/sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystem.java
+++ b/sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystem.java
@@ -94,6 +94,11 @@ public class RootedFileSystem extends BaseFileSystem<RootedPath> {
         return rootFs.getFileStores();
     }
 
+    @Override
+    protected boolean hostFsHasWindowsSeparator() {
+        return "\\".equals(getRoot().getFileSystem().getSeparator());
+    }
+
     @Override
     public String toString() {
         return rootPath.toString();

--- a/sshd-common/src/main/java/org/apache/sshd/common/file/util/BaseFileSystem.java
+++ b/sshd-common/src/main/java/org/apache/sshd/common/file/util/BaseFileSystem.java
@@ -79,7 +80,7 @@ public abstract class BaseFileSystem<T extends Path> extends FileSystem {
     public T getPath(String first, String... more) {
         StringBuilder sb = new StringBuilder();
         if (!GenericUtils.isEmpty(first)) {
-            appendDedupSep(sb, first.replace('\\', '/')); // in case we are running on Windows
+            appendDedupSep(sb, handleWindowsSeparator(first));
         }
 
         if (GenericUtils.length(more) > 0) {
@@ -87,8 +88,7 @@ public abstract class BaseFileSystem<T extends Path> extends FileSystem {
                 if ((sb.length() > 0) && (sb.charAt(sb.length() - 1) != '/')) {
                     sb.append('/');
                 }
-                // in case we are running on Windows
-                appendDedupSep(sb, segment.replace('\\', '/'));
+                appendDedupSep(sb, handleWindowsSeparator(segment));
             }
         }
 
@@ -121,6 +121,23 @@ public abstract class BaseFileSystem<T extends Path> extends FileSystem {
         }
     }
 
+    /**
+     * In case we are running on Windows, accept "\\" as a file separator. Ignore in *nix as "\\" is a valid filename
+     * 
+     * @param  name the name to fix the separator for if running on Windows
+     * @return      the fixed name
+     */
+    protected String handleWindowsSeparator(String name) {
+        if (hostFsHasWindowsSeparator()) {
+            return name.replace('\\', '/');
+        }
+        return name;
+    }
+
+    protected boolean hostFsHasWindowsSeparator() {
+        return OsUtils.isWin32();
+    }
+
     @Override
     public PathMatcher getPathMatcher(String syntaxAndPattern) {
         int colonIndex = Objects.requireNonNull(syntaxAndPattern, "No argument").indexOf(':');

--- a/sshd-sftp/src/main/java/org/apache/sshd/sftp/client/fs/SftpFileSystemProvider.java
+++ b/sshd-sftp/src/main/java/org/apache/sshd/sftp/client/fs/SftpFileSystemProvider.java
@@ -621,7 +621,7 @@ public class SftpFileSystemProvider extends FileSystemProvider {
         }
 
         // delete target if it exists and REPLACE_EXISTING is specified
-        Boolean status = IoUtils.checkFileExists(target, linkOptions);
+        Boolean status = IoUtils.checkFileExistsAnySymlinks(target, noFollowLinks);
         if (status == null) {
             throw new AccessDeniedException("Existence cannot be determined for copy target: " + target);
         }
@@ -698,7 +698,7 @@ public class SftpFileSystemProvider extends FileSystemProvider {
         }
 
         // delete target if it exists and REPLACE_EXISTING is specified
-        Boolean status = IoUtils.checkFileExists(target, linkOptions);
+        Boolean status = IoUtils.checkFileExistsAnySymlinks(target, noFollowLinks);
         if (status == null) {
             throw new AccessDeniedException("Existence cannot be determined for move target " + target);
         }

--- a/sshd-common/src/main/java/org/apache/sshd/common/util/io/IoUtils.java
+++ b/sshd-common/src/main/java/org/apache/sshd/common/util/io/IoUtils.java
@@ -394,18 +395,13 @@ public final class IoUtils {
      *                 explained above
      */
     public static Boolean checkFileExists(Path path, LinkOption... options) {
-        boolean followLinks = true;
-        for (LinkOption opt : options) {
-            if (opt == LinkOption.NOFOLLOW_LINKS) {
-                followLinks = false;
-                break;
-            }
-        }
+        boolean followLinks = followLinks(options);
+
         try {
             if (followLinks) {
                 path.getFileSystem().provider().checkAccess(path);
             } else {
-                Files.readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);
+                Files.readAttributes(path, BasicFileAttributes.class, options);
             }
             return Boolean.TRUE;
         } catch (NoSuchFileException e) {
@@ -415,6 +411,63 @@ public final class IoUtils {
         }
     }
 
+    /**
+     * Checks that a file exists with or without following any symlinks.
+     *
+     * @param  path                the path to check
+     * @param  neverFollowSymlinks whether to follow symlinks
+     * @return                     true if the file exists with the symlink semantics, false if it doesn't exist, null
+     *                             if symlinks were found, or it is unknown if whether the file exists
+     */
+    public static Boolean checkFileExistsAnySymlinks(Path path, boolean neverFollowSymlinks) {
+        try {
+            if (!neverFollowSymlinks) {
+                path.getFileSystem().provider().checkAccess(path);
+            } else {
+                // this is a bad fix because this leaves a nasty race condition - the directory may turn into a symlink
+                // between this check and the call to open()
+                for (int i = 1; i <= path.getNameCount(); i++) {
+                    Path checkForSymLink = getFirstPartsOfPath(path, i);
+                    BasicFileAttributes basicFileAttributes
+                            = Files.readAttributes(checkForSymLink, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);
+                    if (basicFileAttributes.isSymbolicLink()) {
+                        return false;
+                    }
+                }
+            }
+            return true;
+        } catch (NoSuchFileException e) {
+            return false;
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Extracts the first n parts of the path. For example <br>
+     * ("/home/test/test12", 1) returns "/home", <br>
+     * ("/home/test", 1) returns "/home/test" <br>
+     * etc.
+     *
+     * @param  path           the path to extract parts of
+     * @param  partsToExtract the number of parts to extract
+     * @return                the extracted path
+     */
+    public static Path getFirstPartsOfPath(Path path, int partsToExtract) {
+        String firstName = path.getName(0).toString();
+        String[] names = new String[partsToExtract - 1];
+        for (int j = 1; j < partsToExtract; j++) {
+            names[j - 1] = path.getName(j).toString();
+        }
+        Path checkForSymLink = path.getFileSystem().getPath(firstName, names);
+        // the root is not counted as a directory part so we must resolve the result relative to it.
+        Path root = path.getRoot();
+        if (root != null) {
+            checkForSymLink = root.resolve(checkForSymLink);
+        }
+        return checkForSymLink;
+    }
+
     /**
      * Read the requested number of bytes or fail if there are not enough left.
      *

--- a/sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java
+++ b/sshd-sftp/src/main/java/org/apache/sshd/sftp/server/AbstractSftpSubsystemHelper.java
@@ -645,9 +645,11 @@ public abstract class AbstractSftpSubsystemHelper
          * SSH_FXP_LSTAT does not.
          */
         SftpFileSystemAccessor accessor = getFileSystemAccessor();
+
+        boolean followLinks = resolvePathResolutionFollowLinks(SftpConstants.SSH_FXP_LSTAT, "", p);
         LinkOption[] options = accessor.resolveFileAccessLinkOptions(
                 this, p, SftpConstants.SSH_FXP_LSTAT, "", false);
-        return resolveFileAttributes(p, flags, options);
+        return resolveFileAttributes(p, flags, !followLinks, options);
     }
 
     protected void doSetStat(
@@ -675,7 +677,7 @@ public abstract class AbstractSftpSubsystemHelper
 
         Path p = resolveFile(path);
         if (followLinks == null) {
-            followLinks = resolvePathResolutionFollowLinks(cmd, extension, p);
+            followLinks = resolvePathResolutionFollowLinks(SftpConstants.SSH_FXP_SETSTAT, extension, p);
         }
         doSetAttributes(cmd, extension, p, attrs, followLinks);
     }
@@ -1408,12 +1410,14 @@ public abstract class AbstractSftpSubsystemHelper
          */
         Path p = resolveFile(path);
         SftpFileSystemAccessor accessor = getFileSystemAccessor();
+        boolean followLinks = resolvePathResolutionFollowLinks(SftpConstants.SSH_FXP_STAT, "", p);
         LinkOption[] options = accessor.resolveFileAccessLinkOptions(
-                this, p, SftpConstants.SSH_FXP_STAT, "", true);
-        return resolveFileAttributes(p, flags, options);
+                this, p, SftpConstants.SSH_FXP_STAT, "", followLinks);
+        return resolveFileAttributes(p, flags, !followLinks, options);
     }
 
     protected void doRealPath(Buffer buffer, int id) throws IOException {
+        // do things here.
         String path = buffer.getString();
         boolean debugEnabled = log.isDebugEnabled();
         ServerSession session = getServerSession();
@@ -1467,7 +1471,6 @@ public abstract class AbstractSftpSubsystemHelper
                 result = doRealPathV6(id, path, extraPaths, p, options);
 
                 p = result.getKey();
-                options = getPathResolutionLinkOption(SftpConstants.SSH_FXP_REALPATH, "", p);
                 Boolean status = result.getValue();
                 switch (control) {
                     case SftpConstants.SSH_FXP_REALPATH_STAT_IF:
@@ -1557,14 +1560,14 @@ public abstract class AbstractSftpSubsystemHelper
             int id, String path, Path f, LinkOption... options)
             throws IOException {
         Path p = normalize(f);
-        Boolean status = IoUtils.checkFileExists(p, options);
+        Boolean status = IoUtils.checkFileExistsAnySymlinks(p, !IoUtils.followLinks(options));
         return new SimpleImmutableEntry<>(p, status);
     }
 
     protected void doRemoveDirectory(Buffer buffer, int id) throws IOException {
         String path = buffer.getString();
         try {
-            doRemoveDirectory(id, path, false);
+            doRemoveDirectory(id, path);
         } catch (IOException | RuntimeException e) {
             sendStatus(prepareReply(buffer), id, e,
                     SftpConstants.SSH_FXP_RMDIR, path);
@@ -1574,15 +1577,23 @@ public abstract class AbstractSftpSubsystemHelper
         sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_OK, "");
     }
 
-    protected void doRemoveDirectory(int id, String path, boolean followLinks) throws IOException {
+    protected void doRemoveDirectory(int id, String path) throws IOException {
         Path p = resolveFile(path);
         if (log.isDebugEnabled()) {
             log.debug("doRemoveDirectory({})[id={}] SSH_FXP_RMDIR (path={})[{}]", getServerSession(), id, path, p);
         }
 
         SftpFileSystemAccessor accessor = getFileSystemAccessor();
+
+        final boolean followLinks = resolvePathResolutionFollowLinks(SftpConstants.SSH_FXP_RMDIR, "", p);
+        Boolean symlinkCheck = validateParentExistWithNoSymlinksIfNeverFollowSymlinks(p, !followLinks);
+        if (!Boolean.TRUE.equals(symlinkCheck)) {
+            throw new AccessDeniedException(p.toString(), p.toString(),
+                    "Parent directories do not exist ore are prohibited symlinks");
+        }
+
         LinkOption[] options = accessor.resolveFileAccessLinkOptions(
-                this, p, SftpConstants.SSH_FXP_RMDIR, "", followLinks);
+                this, p, SftpConstants.SSH_FXP_RMDIR, "", false);
         if (Files.isDirectory(p, options)) {
             doRemove(id, p, true);
         } else {
@@ -1618,7 +1629,7 @@ public abstract class AbstractSftpSubsystemHelper
         String path = buffer.getString();
         Map<String, ?> attrs = readAttrs(buffer);
         try {
-            doMakeDirectory(id, path, attrs, false);
+            doMakeDirectory(id, path, attrs);
         } catch (IOException | RuntimeException e) {
             sendStatus(prepareReply(buffer), id, e,
                     SftpConstants.SSH_FXP_MKDIR, path, attrs);
@@ -1629,7 +1640,7 @@ public abstract class AbstractSftpSubsystemHelper
     }
 
     protected void doMakeDirectory(
-            int id, String path, Map<String, ?> attrs, boolean followLinks)
+            int id, String path, Map<String, ?> attrs)
             throws IOException {
         Path resolvedPath = resolveFile(path);
         ServerSession session = getServerSession();
@@ -1640,14 +1651,21 @@ public abstract class AbstractSftpSubsystemHelper
 
         SftpFileSystemAccessor accessor = getFileSystemAccessor();
         LinkOption[] options = accessor.resolveFileAccessLinkOptions(
-                this, resolvedPath, SftpConstants.SSH_FXP_MKDIR, "", followLinks);
+                this, resolvedPath, SftpConstants.SSH_FXP_MKDIR, "", false);
+        final boolean followLinks = resolvePathResolutionFollowLinks(SftpConstants.SSH_FXP_MKDIR, "", resolvedPath);
         SftpPathImpl.withAttributeCache(resolvedPath, p -> {
-            Boolean status = IoUtils.checkFileExists(p, options);
-            if (status == null) {
+            Boolean symlinkCheck = validateParentExistWithNoSymlinksIfNeverFollowSymlinks(p, !followLinks);
+            if (!Boolean.TRUE.equals(symlinkCheck)) {
+                throw new AccessDeniedException(p.toString(), p.toString(),
+                        "Parent directories do not exist ore are prohibited symlinks");
+            }
+
+            Boolean fileExists = IoUtils.checkFileExists(p, options);
+            if (fileExists == null) {
                 throw new AccessDeniedException(p.toString(), p.toString(), "Cannot validate make-directory existence");
             }
 
-            if (status) {
+            if (fileExists) {
                 if (Files.isDirectory(p, options)) {
                     throw new FileAlreadyExistsException(p.toString(), p.toString(), "Target directory already exists");
                 } else {
@@ -1661,7 +1679,6 @@ public abstract class AbstractSftpSubsystemHelper
         listener.creating(session, resolvedPath, attrs);
         try {
             accessor.createDirectory(this, resolvedPath);
-            followLinks = resolvePathResolutionFollowLinks(SftpConstants.SSH_FXP_MKDIR, "", resolvedPath);
             doSetAttributes(SftpConstants.SSH_FXP_MKDIR, "", resolvedPath, attrs, followLinks);
         } catch (IOException | RuntimeException | Error e) {
             listener.created(session, resolvedPath, attrs, e);
@@ -1676,7 +1693,7 @@ public abstract class AbstractSftpSubsystemHelper
             /*
              * If 'filename' is a symbolic link, the link is removed, not the file it points to.
              */
-            doRemoveFile(id, path, false);
+            doRemoveFile(id, path);
         } catch (IOException | RuntimeException e) {
             sendStatus(prepareReply(buffer), id, e, SftpConstants.SSH_FXP_REMOVE, path);
             return;
@@ -1685,17 +1702,20 @@ public abstract class AbstractSftpSubsystemHelper
         sendStatus(prepareReply(buffer), id, SftpConstants.SSH_FX_OK, "");
     }
 
-    protected void doRemoveFile(int id, String path, boolean followLinks) throws IOException {
+    protected void doRemoveFile(int id, String path) throws IOException {
         Path resolvedPath = resolveFile(path);
         if (log.isDebugEnabled()) {
             log.debug("doRemoveFile({})[id={}] SSH_FXP_REMOVE (path={}[{}])", getServerSession(), id, path, resolvedPath);
         }
+        // whether to follow links in the dir up to the final file
+        boolean followLinks = resolvePathResolutionFollowLinks(SftpConstants.SSH_FXP_REMOVE, "", resolvedPath);
 
         SftpFileSystemAccessor accessor = getFileSystemAccessor();
+        // never resolve links in the final path to remove as we want to remove the symlink, not the target
         LinkOption[] options = accessor.resolveFileAccessLinkOptions(
-                this, resolvedPath, SftpConstants.SSH_FXP_REMOVE, "", followLinks);
+                this, resolvedPath, SftpConstants.SSH_FXP_REMOVE, "", false);
         SftpPathImpl.withAttributeCache(resolvedPath, p -> {
-            Boolean status = IoUtils.checkFileExists(p, options);
+            Boolean status = checkSymlinkState(p, followLinks, options);
             if (status == null) {
                 throw signalRemovalPreConditionFailure(id, path, p,
                         new AccessDeniedException(p.toString(), p.toString(), "Cannot determine existence of remove candidate"),
@@ -2293,8 +2313,9 @@ public abstract class AbstractSftpSubsystemHelper
             int id, DirectoryHandle dir, Map<String, Path> entries, Buffer buffer,
             int index, Path f, String shortName, LinkOption... options)
             throws IOException {
+        boolean followLinks = resolvePathResolutionFollowLinks(SftpConstants.SSH_FXP_READDIR, "", f);
         Map<String, ?> attrs = resolveFileAttributes(
-                f, SftpConstants.SSH_FILEXFER_ATTR_ALL, options);
+                f, SftpConstants.SSH_FILEXFER_ATTR_ALL, !followLinks, options);
         entries.put(shortName, f);
 
         SftpFileSystemAccessor accessor = getFileSystemAccessor();
@@ -2392,10 +2413,10 @@ public abstract class AbstractSftpSubsystemHelper
     }
 
     protected NavigableMap<String, Object> resolveFileAttributes(
-            Path path, int flags, LinkOption... options)
+            Path path, int flags, boolean neverFollowSymLinks, LinkOption... options)
             throws IOException {
         return SftpPathImpl.withAttributeCache(path, file -> {
-            Boolean status = IoUtils.checkFileExists(file, options);
+            Boolean status = checkSymlinkState(file, neverFollowSymLinks, options);
             if (status == null) {
                 return handleUnknownStatusFileAttributes(file, flags, options);
             } else if (!status) {
@@ -2406,7 +2427,31 @@ public abstract class AbstractSftpSubsystemHelper
         });
     }
 
-    protected void writeAttrs(Buffer buffer, Map<String, ?> attributes) throws IOException {
+    /**
+     * A utility function to validate that the directories leading up to a file are not symlinks
+     *
+     * @param  path                the file to check for symlink presence
+     * @param  neverFollowSymLinks whether to never follow symlinks in the parent paths
+     * @param  options             whether the file itself can be a symlink
+     * @return                     whether there are symlinks in the path to this file, or null if unknown
+     */
+    public Boolean checkSymlinkState(Path path, boolean neverFollowSymLinks, LinkOption[] options) {
+        Boolean status = validateParentExistWithNoSymlinksIfNeverFollowSymlinks(path, neverFollowSymLinks);
+        if (!Boolean.FALSE.equals(status)) {
+            status = IoUtils.checkFileExists(path, options);
+        }
+        return status;
+    }
+
+    public Boolean validateParentExistWithNoSymlinksIfNeverFollowSymlinks(Path path, boolean neverFollowSymLinks) {
+        Boolean status = true;
+        if (neverFollowSymLinks && path.getParent() != null) {
+            status = IoUtils.checkFileExistsAnySymlinks(path.getParent(), true);
+        }
+        return status;
+    }
+
+    protected void writeAttrs(Buffer buffer, Map<String, ?> attributes) {
         SftpHelper.writeAttrs(buffer, getVersion(), attributes);
     }
 
@@ -2653,7 +2698,11 @@ public abstract class AbstractSftpSubsystemHelper
                 case IoUtils.SIZE_VIEW_ATTR: {
                     long newSize = ((Number) value).longValue();
                     SftpFileSystemAccessor accessor = getFileSystemAccessor();
-                    Set<StandardOpenOption> openOptions = EnumSet.of(StandardOpenOption.WRITE);
+                    Set<OpenOption> openOptions = new HashSet<>();
+                    openOptions.add(StandardOpenOption.WRITE);
+                    if (!IoUtils.followLinks(options)) {
+                        openOptions.add(LinkOption.NOFOLLOW_LINKS);
+                    }
                     try (SeekableByteChannel channel = accessor.openFile(this, null, file, null, openOptions)) {
                         channel.truncate(newSize);
                         accessor.closeFile(this, null, file, null, channel, openOptions);

--- a/sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java
+++ b/sshd-common/src/main/java/org/apache/sshd/common/file/root/RootedFileSystemProvider.java
@@ -157,14 +166,22 @@ public class RootedFileSystemProvider extends FileSystemProvider {
     public InputStream newInputStream(Path path, OpenOption... options) throws IOException {
         Path r = unroot(path);
         FileSystemProvider p = provider(r);
+        try {
             return p.newInputStream(r, options);
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     @Override
     public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {
         Path r = unroot(path);
         FileSystemProvider p = provider(r);
+        try {
             return p.newOutputStream(r, options);
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     @Override
@@ -172,7 +189,11 @@ public class RootedFileSystemProvider extends FileSystemProvider {
             throws IOException {
         Path r = unroot(path);
         FileSystemProvider p = provider(r);
+        try {
             return p.newFileChannel(r, options, attrs);
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     @Override
@@ -181,7 +202,11 @@ public class RootedFileSystemProvider extends FileSystemProvider {
             throws IOException {
         Path r = unroot(path);
         FileSystemProvider p = provider(r);
+        try {
             return p.newAsynchronousFileChannel(r, options, executor, attrs);
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     @Override
@@ -189,82 +214,74 @@ public class RootedFileSystemProvider extends FileSystemProvider {
             throws IOException {
         Path r = unroot(path);
         FileSystemProvider p = provider(r);
+        try {
             return p.newByteChannel(r, options, attrs);
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     @Override
     public DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) throws IOException {
         Path r = unroot(dir);
         FileSystemProvider p = provider(r);
+        try {
             return root(((RootedPath) dir).getFileSystem(), p.newDirectoryStream(r, filter));
+        } catch (IOException ex) {
+            throw translateIoException(ex, dir);
         }
-
-    protected DirectoryStream<Path> root(RootedFileSystem rfs, DirectoryStream<Path> ds) {
-        return new DirectoryStream<Path>() {
-            @Override
-            public Iterator<Path> iterator() {
-                return root(rfs, ds.iterator());
     }
 
-            @Override
-            public void close() throws IOException {
-                ds.close();
-            }
-        };
-    }
-
-    protected Iterator<Path> root(RootedFileSystem rfs, Iterator<Path> iter) {
-        return new Iterator<Path>() {
-            @Override
-            public boolean hasNext() {
-                return iter.hasNext();
-            }
-
-            @Override
-            public Path next() {
-                return root(rfs, iter.next());
+    protected DirectoryStream<Path> root(RootedFileSystem rfs, DirectoryStream<Path> ds) {
+        if (ds instanceof SecureDirectoryStream) {
+            return new RootedSecureDirectoryStream(rfs, (SecureDirectoryStream<Path>) ds);
         }
-        };
+        return new RootedDirectoryStream(rfs, ds);
     }
 
     @Override
     public void createDirectory(Path dir, FileAttribute<?>... attrs) throws IOException {
         Path r = unroot(dir);
         FileSystemProvider p = provider(r);
+        try {
             p.createDirectory(r, attrs);
+        } catch (IOException ex) {
+            throw translateIoException(ex, dir);
         }
-
-    @Override
-    public void createSymbolicLink(Path link, Path target, FileAttribute<?>... attrs) throws IOException {
-        createLink(link, target, true, attrs);
     }
 
     @Override
-    public void createLink(Path link, Path existing) throws IOException {
-        createLink(link, existing, false);
-    }
-
-    protected void createLink(Path link, Path target, boolean symLink, FileAttribute<?>... attrs) throws IOException {
+    public void createSymbolicLink(Path link, Path target, FileAttribute<?>... attrs) throws IOException {
+        // make sure symlink cannot break out of chroot jail. If it is unsafe, simply thrown an exception. This is
+        // to ensure that symlink semantics are maintained when it is safe, and creation fails when not.
+        RootedFileSystemUtils.validateSafeRelativeSymlink(target);
         Path l = unroot(link);
-        Path t = unroot(target);
-        /*
-         * For a symbolic link preserve the relative path
-         */
-        if (symLink && (!target.isAbsolute())) {
-            RootedFileSystem rfs = ((RootedPath) target).getFileSystem();
-            Path root = rfs.getRoot();
-            t = root.relativize(t);
-        }
+        Path t = target.isAbsolute() ? unroot(target) : l.getFileSystem().getPath(target.toString());
 
         FileSystemProvider p = provider(l);
-        if (symLink) {
+        try {
             p.createSymbolicLink(l, t, attrs);
-        } else {
-            p.createLink(l, t);
+
+            if (log.isDebugEnabled()) {
+                log.debug("createSymbolicLink({} => {}", l, t);
+            }
+        } catch (IOException ex) {
+            throw translateIoException(ex, link);
+        }
     }
 
+    @Override
+    public void createLink(Path link, Path existing) throws IOException {
+        Path l = unroot(link);
+        Path t = unroot(existing);
+
+        try {
+            provider(l).createLink(l, t);
             if (log.isDebugEnabled()) {
-            log.debug("createLink(symbolic={}) {} => {}", symLink, l, t);
+                log.debug("createLink({} => {}", l, t);
+            }
+        } catch (IOException ex) {
+            throw translateIoException(ex, link);
         }
     }
 
@@ -275,7 +292,11 @@ public class RootedFileSystemProvider extends FileSystemProvider {
             log.trace("delete({}): {}", path, r);
         }
         FileSystemProvider p = provider(r);
+        try {
             p.delete(r);
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     @Override
@@ -285,19 +306,27 @@ public class RootedFileSystemProvider extends FileSystemProvider {
             log.trace("deleteIfExists({}): {}", path, r);
         }
         FileSystemProvider p = provider(r);
+        try {
             return p.deleteIfExists(r);
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     @Override
     public Path readSymbolicLink(Path link) throws IOException {
         Path r = unroot(link);
         FileSystemProvider p = provider(r);
+        try {
             Path t = p.readSymbolicLink(r);
             Path target = root((RootedFileSystem) link.getFileSystem(), t);
             if (log.isTraceEnabled()) {
                 log.trace("readSymbolicLink({})[{}]: {}[{}]", link, r, target, t);
             }
             return target;
+        } catch (IOException ex) {
+            throw translateIoException(ex, link);
+        }
     }
 
     @Override
@@ -308,7 +337,11 @@ public class RootedFileSystemProvider extends FileSystemProvider {
             log.trace("copy({})[{}]: {}[{}]", source, s, target, t);
         }
         FileSystemProvider p = provider(s);
+        try {
             p.copy(s, t, options);
+        } catch (IOException ex) {
+            throw translateIoException(ex, source);
+        }
     }
 
     @Override
@@ -319,7 +352,11 @@ public class RootedFileSystemProvider extends FileSystemProvider {
             log.trace("move({})[{}]: {}[{}]", source, s, target, t);
         }
         FileSystemProvider p = provider(s);
+        try {
             p.move(s, t, options);
+        } catch (IOException ex) {
+            throw translateIoException(ex, source);
+        }
     }
 
     @Override
@@ -327,21 +364,33 @@ public class RootedFileSystemProvider extends FileSystemProvider {
         Path r = unroot(path);
         Path r2 = unroot(path2);
         FileSystemProvider p = provider(r);
+        try {
             return p.isSameFile(r, r2);
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     @Override
     public boolean isHidden(Path path) throws IOException {
         Path r = unroot(path);
         FileSystemProvider p = provider(r);
+        try {
             return p.isHidden(r);
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     @Override
     public FileStore getFileStore(Path path) throws IOException {
         RootedFileSystem fileSystem = getFileSystem(path);
         Path root = fileSystem.getRoot();
+        try {
             return Files.getFileStore(root);
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     protected RootedFileSystem getFileSystem(Path path) throws FileSystemNotFoundException {
@@ -403,18 +456,26 @@ public class RootedFileSystemProvider extends FileSystemProvider {
         }
 
         FileSystemProvider p = provider(r);
+        try {
             return p.readAttributes(r, type, options);
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     @Override
     public Map<String, Object> readAttributes(Path path, String attributes, LinkOption... options) throws IOException {
         Path r = unroot(path);
         FileSystemProvider p = provider(r);
+        try {
             Map<String, Object> attrs = p.readAttributes(r, attributes, options);
             if (log.isTraceEnabled()) {
                 log.trace("readAttributes({})[{}] {}: {}", path, r, attributes, attrs);
             }
             return attrs;
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     @Override
@@ -424,7 +485,11 @@ public class RootedFileSystemProvider extends FileSystemProvider {
             log.trace("setAttribute({})[{}] {}={}", path, r, attribute, value);
         }
         FileSystemProvider p = provider(r);
+        try {
             p.setAttribute(r, attribute, value, options);
+        } catch (IOException ex) {
+            throw translateIoException(ex, path);
+        }
     }
 
     protected FileSystemProvider provider(Path path) {
@@ -434,10 +499,33 @@ public class RootedFileSystemProvider extends FileSystemProvider {
 
     protected Path root(RootedFileSystem rfs, Path nat) {
         if (nat.isAbsolute()) {
+            // preferred case - this isn't a symlink out of our jail
+            if (nat.startsWith(rfs.getRoot())) {
+                // If we have the same number of parts as the root, and start with the root, we must be the root.
+                if (nat.getNameCount() == rfs.getRoot().getNameCount()) {
+                    return rfs.getPath("/");
+                }
+
+                // We are the root, and more. Get the first name past the root because of how getPath works
+                String firstName = "/" + nat.getName(rfs.getRoot().getNameCount());
+
+                // the rooted path should have the number of parts past the root
+                String[] varargs = new String[nat.getNameCount() - rfs.getRoot().getNameCount() - 1];
+                int varargsCounter = 0;
+                for (int i = 1 + rfs.getRoot().getNameCount(); i < nat.getNameCount(); i++) {
+                    varargs[varargsCounter++] = nat.getName(i).toString();
+                }
+                return rfs.getPath(firstName, varargs);
+            }
+
+            // This is the case where there's a symlink jailbreak, so we return a relative link as the directories above
+            // the chroot don't make sense to present
+            // The behavior with the fs class is that we follow the symlink. Note that this is dangerous.
             Path root = rfs.getRoot();
             Path rel = root.relativize(nat);
-            return rfs.getPath("/" + rel.toString());
+            return rfs.getPath("/" + rel);
         } else {
+            // For a relative symlink, simply return it as a RootedPath. Note that this may break out of the chroot.
             return rfs.getPath(nat.toString());
         }
     }
