--- a/services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java
+++ b/services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java
@@ -379,6 +379,8 @@ public class LogoutEndpoint {
                 session.getProvider(LoginFormsProvider.class).setAttribute(Constants.SKIP_LINK, true);
             }
 
+            event.error(Errors.SESSION_EXPIRED);
+
             return ErrorPage.error(session, logoutSession, Response.Status.BAD_REQUEST, Messages.FAILED_LOGOUT);
         }
 
@@ -414,6 +416,7 @@ public class LogoutEndpoint {
 
             AuthenticationManager.AuthResult authResult = AuthenticationManager.authenticateIdentityCookie(session, realm, false);
             if (authResult != null) {
+                event.error(Errors.LOGOUT_FAILED);
                 return ErrorPage.error(session, logoutSession, Response.Status.BAD_REQUEST, Messages.FAILED_LOGOUT);
             } else {
                 // Probably changing locale on logout screen after logout was already performed. If there is no session in the browser, we can just display that logout was already finished
@@ -440,7 +443,10 @@ public class LogoutEndpoint {
             try {
                 userSession = lockUserSessionsForModification(session, () -> session.sessions().getUserSession(realm, userSessionIdFromIdToken));
 
-                if (userSession != null) {
+                if (userSession == null) {
+                    event.event(EventType.LOGOUT);
+                    event.error(Errors.SESSION_EXPIRED);
+                } else {
                     Integer idTokenIssuedAt = Integer.parseInt(idTokenIssuedAtStr);
                     checkTokenIssuedAt(idTokenIssuedAt, userSession);
                 }

--- a/services/src/main/java/org/keycloak/services/resources/SessionCodeChecks.java
+++ b/services/src/main/java/org/keycloak/services/resources/SessionCodeChecks.java
@@ -178,6 +184,15 @@ public class SessionCodeChecks {
         // See if we are already authenticated and userSession with same ID exists.
         UserSessionModel userSession = authSessionManager.getUserSessionFromAuthCookie(realm);
 
+        if (userSession == null) {
+            // fallback to check if there is an identity cookie
+            AuthenticationManager.AuthResult authResult = lockUserSessionsForModification(session, () -> authenticateIdentityCookie(session, realm, false));
+
+            if (authResult != null) {
+                userSession = authResult.getSession();
+            }
+        }
+
         if (userSession != null) {
             LoginFormsProvider loginForm = session.getProvider(LoginFormsProvider.class).setAuthenticationSession(authSession)
                     .setSuccess(Messages.ALREADY_LOGGED_IN);

--- a/services/src/main/java/org/keycloak/services/managers/AuthenticationSessionManager.java
+++ b/services/src/main/java/org/keycloak/services/managers/AuthenticationSessionManager.java
@@ -196,7 +197,18 @@ public class AuthenticationSessionManager {
             log.debugf("Not found AUTH_SESSION_ID cookie");
         }
 
-        return authSessionIds;
+        return authSessionIds.stream().filter(new Predicate<String>() {
+            @Override
+            public boolean test(String id) {
+                StickySessionEncoderProvider encoder = session.getProvider(StickySessionEncoderProvider.class);
+                // in case the id is encoded with a route when running in a cluster
+                String decodedId = encoder.decodeSessionId(cookiesVal.iterator().next());
+                // we can't blindly trust the cookie and assume it is valid and referencing a valid root auth session
+                // but make sure the root authentication session actually exists
+                // without this check there is a risk of resolving user sessions from invalid root authentication sessions as they share the same id
+                return session.authenticationSessions().getRootAuthenticationSession(realm, decodedId) != null;
+            }
+        }).collect(Collectors.toList());
     }
 
 

--- a/services/src/main/java/org/keycloak/protocol/oidc/utils/RedirectUtils.java
+++ b/services/src/main/java/org/keycloak/protocol/oidc/utils/RedirectUtils.java
@@ -91,6 +93,7 @@ public class RedirectUtils {
         KeycloakUriInfo uriInfo = session.getContext().getUri();
         RealmModel realm = session.getContext().getRealm();
 
+        redirectUri = decodeRedirectUri(redirectUri);
         if (redirectUri != null) {
             try {
                 URI uri = URI.create(redirectUri);
@@ -152,6 +155,42 @@ public class RedirectUtils {
         }
     }
 
+    // Decode redirectUri. We don't decode query and fragment as those can be encoded in the original URL.
+    // URL can be decoded multiple times (in case it was encoded multiple times, or some of it's parts were encoded multiple times)
+    private static String decodeRedirectUri(String redirectUri) {
+        if (redirectUri == null) return null;
+        int MAX_DECODING_COUNT = 5; // Max count of attempts for decoding URL (in case it was encoded multiple times)
+
+        try {
+            KeycloakUriBuilder uriBuilder = KeycloakUriBuilder.fromUri(redirectUri);
+            String origQuery = uriBuilder.getQuery();
+            String origFragment = uriBuilder.getFragment();
+            String encodedRedirectUri = uriBuilder
+                    .replaceQuery(null)
+                    .fragment(null)
+                    .buildAsString();
+            String decodedRedirectUri = null;
+
+            for (int i = 0; i < MAX_DECODING_COUNT; i++) {
+                decodedRedirectUri = Encode.decode(encodedRedirectUri);
+                if (decodedRedirectUri.equals(encodedRedirectUri)) {
+                    // URL is decoded. We can return it (after attach original query and fragment)
+                    return KeycloakUriBuilder.fromUri(decodedRedirectUri)
+                            .replaceQuery(origQuery)
+                            .fragment(origFragment)
+                            .buildAsString();
+                } else {
+                    // Next attempt
+                    encodedRedirectUri = decodedRedirectUri;
+                }
+            }
+        } catch (IllegalArgumentException iae) {
+            logger.debugf("Illegal redirect URI used: %s, Details: %s", redirectUri, iae.getMessage());
+        }
+        logger.debugf("Was not able to decode redirect URI: %s", redirectUri);
+        return null;
+    }
+
     private static String lowerCaseHostname(String redirectUri) {
         int n = redirectUri.indexOf('/', 7);
         if (n == -1) {

--- a/services/src/main/java/org/keycloak/services/managers/UserSessionCrossDCManager.java
+++ b/services/src/main/java/org/keycloak/services/managers/UserSessionCrossDCManager.java
@@ -65,6 +67,18 @@ public class UserSessionCrossDCManager {
     public UserSessionModel getUserSessionIfExistsRemotely(AuthenticationSessionManager asm, RealmModel realm) {
         List<String> sessionCookies = asm.getAuthSessionCookies(realm);
 
+        if (sessionCookies.isEmpty()) {
+            // ideally, we should not rely on auth session id to retrieve user sessions
+            // in case the auth session was removed, we fall back to the identity cookie
+            // we are here doing the user session lookup twice, however the second lookup is going to make sure the
+            // session exists in remote caches
+            AuthenticationManager.AuthResult authResult = lockUserSessionsForModification(kcSession, () -> authenticateIdentityCookie(kcSession, realm, true));
+
+            if (authResult != null && authResult.getSession() != null) {
+                sessionCookies = Collections.singletonList(authResult.getSession().getId());
+            }
+        }
+
         return sessionCookies.stream().map(oldEncodedId -> {
             AuthSessionId authSessionId = asm.decodeAuthSessionId(oldEncodedId);
             String sessionId = authSessionId.getDecodedId();
