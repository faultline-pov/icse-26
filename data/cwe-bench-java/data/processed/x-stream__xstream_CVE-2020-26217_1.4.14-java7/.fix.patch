--- a/xstream/src/java/com/thoughtworks/xstream/XStream.java
+++ b/xstream/src/java/com/thoughtworks/xstream/XStream.java
@@ -656,59 +567,73 @@ public class XStream {
         mapper = new ArrayMapper(mapper);
         mapper = new DefaultImplementationsMapper(mapper);
         mapper = new AttributeMapper(mapper, converterLookup, reflectionProvider);
-        mapper = new EnumMapper(mapper);
+        if (JVM.isVersion(5)) {
+            mapper = buildMapperDynamically("com.thoughtworks.xstream.mapper.EnumMapper", new Class[]{Mapper.class},
+                new Object[]{mapper});
+        }
         mapper = new LocalConversionMapper(mapper);
         mapper = new ImmutableTypesMapper(mapper);
-        mapper = new LambdaMapper(mapper);
+        if (JVM.isVersion(8)) {
+            mapper = buildMapperDynamically("com.thoughtworks.xstream.mapper.LambdaMapper", new Class[]{Mapper.class},
+                new Object[]{mapper});
+        }
         mapper = new SecurityMapper(mapper);
-        mapper = new AnnotationMapper(mapper, converterRegistry, converterLookup, classLoaderReference,
-            reflectionProvider);
+        if (JVM.isVersion(5)) {
+            mapper = buildMapperDynamically(ANNOTATION_MAPPER_TYPE, new Class[]{
+                Mapper.class, ConverterRegistry.class, ConverterLookup.class, ClassLoaderReference.class,
+                ReflectionProvider.class}, new Object[]{
+                    mapper, converterRegistry, converterLookup, classLoaderReference, reflectionProvider});
+        }
         mapper = wrapMapper((MapperWrapper)mapper);
         mapper = new CachingMapper(mapper);
         return mapper;
     }
 
-  //@formatter:off
-    /*
-    private Mapper buildMapperDynamically(final String className, final Class<?>[] constructorParamTypes,
-            final Object[] constructorParamValues) {
+    private Mapper buildMapperDynamically(String className, Class[] constructorParamTypes,
+            Object[] constructorParamValues) {
         try {
-            final Class<?> type = Class.forName(className, false, classLoaderReference.getReference());
-            final Constructor<?> constructor = type.getConstructor(constructorParamTypes);
+            Class type = Class.forName(className, false, classLoaderReference.getReference());
+            Constructor constructor = type.getConstructor(constructorParamTypes);
             return (Mapper)constructor.newInstance(constructorParamValues);
-        } catch (final Exception | LinkageError e) {
-            throw new InitializationException("Could not instantiate mapper : " + className, e);
+        } catch (Exception e) {
+            throw new com.thoughtworks.xstream.InitializationException("Could not instantiate mapper : " + className,
+                e);
+        } catch (LinkageError e) {
+            throw new com.thoughtworks.xstream.InitializationException("Could not instantiate mapper : " + className,
+                e);
         }
     }
-    */
-    //@formatter:on
 
-    protected MapperWrapper wrapMapper(final MapperWrapper next) {
+    protected MapperWrapper wrapMapper(MapperWrapper next) {
         return next;
     }
 
     /**
      * @deprecated As of 1.4.8
      */
-    @Deprecated
     protected boolean useXStream11XmlFriendlyMapper() {
         return false;
     }
 
     private void setupMappers() {
-        packageAliasingMapper = mapper.lookupMapperOfType(PackageAliasingMapper.class);
-        classAliasingMapper = mapper.lookupMapperOfType(ClassAliasingMapper.class);
-        elementIgnoringMapper = mapper.lookupMapperOfType(ElementIgnoringMapper.class);
-        fieldAliasingMapper = mapper.lookupMapperOfType(FieldAliasingMapper.class);
-        attributeMapper = mapper.lookupMapperOfType(AttributeMapper.class);
-        attributeAliasingMapper = mapper.lookupMapperOfType(AttributeAliasingMapper.class);
-        systemAttributeAliasingMapper = mapper.lookupMapperOfType(SystemAttributeAliasingMapper.class);
-        implicitCollectionMapper = mapper.lookupMapperOfType(ImplicitCollectionMapper.class);
-        defaultImplementationsMapper = mapper.lookupMapperOfType(DefaultImplementationsMapper.class);
-        immutableTypesMapper = mapper.lookupMapperOfType(ImmutableTypesMapper.class);
-        localConversionMapper = mapper.lookupMapperOfType(LocalConversionMapper.class);
-        securityMapper = mapper.lookupMapperOfType(SecurityMapper.class);
-        annotationMapper = mapper.lookupMapperOfType(AnnotationMapper.class);
+        packageAliasingMapper = (PackageAliasingMapper)this.mapper.lookupMapperOfType(PackageAliasingMapper.class);
+        classAliasingMapper = (ClassAliasingMapper)this.mapper.lookupMapperOfType(ClassAliasingMapper.class);
+        elementIgnoringMapper = (ElementIgnoringMapper)this.mapper.lookupMapperOfType(ElementIgnoringMapper.class);
+        fieldAliasingMapper = (FieldAliasingMapper)this.mapper.lookupMapperOfType(FieldAliasingMapper.class);
+        attributeMapper = (AttributeMapper)this.mapper.lookupMapperOfType(AttributeMapper.class);
+        attributeAliasingMapper = (AttributeAliasingMapper)this.mapper
+            .lookupMapperOfType(AttributeAliasingMapper.class);
+        systemAttributeAliasingMapper = (SystemAttributeAliasingMapper)this.mapper
+            .lookupMapperOfType(SystemAttributeAliasingMapper.class);
+        implicitCollectionMapper = (ImplicitCollectionMapper)this.mapper
+            .lookupMapperOfType(ImplicitCollectionMapper.class);
+        defaultImplementationsMapper = (DefaultImplementationsMapper)this.mapper
+            .lookupMapperOfType(DefaultImplementationsMapper.class);
+        immutableTypesMapper = (ImmutableTypesMapper)this.mapper.lookupMapperOfType(ImmutableTypesMapper.class);
+        localConversionMapper = (LocalConversionMapper)this.mapper.lookupMapperOfType(LocalConversionMapper.class);
+        securityMapper = (SecurityMapper)this.mapper.lookupMapperOfType(SecurityMapper.class);
+        annotationConfiguration = (AnnotationConfiguration)this.mapper
+            .lookupMapperOfType(AnnotationConfiguration.class);
     }
 
     protected void setupSecurity() {
@@ -716,80 +641,109 @@ public class XStream {
             return;
         }
 
-        addPermission(NullPermission.NULL);
-        addPermission(PrimitiveTypePermission.PRIMITIVES);
-        addPermission(ArrayTypePermission.ARRAYS);
-        addPermission(InterfaceTypePermission.INTERFACES);
-        allowTypeHierarchy(Calendar.class);
-        allowTypeHierarchy(Collection.class);
-        allowTypeHierarchy(Enum.class);
-        allowTypeHierarchy(Map.class);
-        allowTypeHierarchy(Map.Entry.class);
-        allowTypeHierarchy(Member.class);
-        allowTypeHierarchy(Number.class);
-        allowTypeHierarchy(Throwable.class);
-        allowTypeHierarchy(TimeZone.class);
-        allowTypeHierarchy(Path.class);
-
-        final Set<Class<?>> types = new HashSet<>();
-        types.addAll(Arrays.<Class<?>>asList(AtomicBoolean.class, AtomicInteger.class, AtomicLong.class,
-            AtomicReference.class, BitSet.class, Charset.class, Class.class, Currency.class, Date.class,
-            DecimalFormatSymbols.class, File.class, Locale.class, Object.class, Pattern.class, StackTraceElement.class,
-            String.class, StringBuffer.class, StringBuilder.class, URL.class, URI.class, UUID.class));
-        if (JVM.isSQLAvailable()) {
-            types.add(JVM.loadClassForName("java.sql.Timestamp"));
-            types.add(JVM.loadClassForName("java.sql.Time"));
-            types.add(JVM.loadClassForName("java.sql.Date"));
-        }
-        
-        allowTypeHierarchy(Clock.class);
-        types.add(Duration.class);
-        types.add(Instant.class);
-        types.add(LocalDate.class);
-        types.add(LocalDateTime.class);
-        types.add(LocalTime.class);
-        types.add(MonthDay.class);
-        types.add(OffsetDateTime.class);
-        types.add(OffsetTime.class);
-        types.add(Period.class);
-        types.add(JVM.loadClassForName("java.time.Ser"));
-        types.add(Year.class);
-        types.add(YearMonth.class);
-        types.add(ZonedDateTime.class);
-        allowTypeHierarchy(ZoneId.class);
-        types.add(HijrahDate.class);
-        types.add(JapaneseDate.class);
-        types.add(JapaneseEra.class);
-        types.add(MinguoDate.class);
-        types.add(ThaiBuddhistDate.class);
-        types.add(JVM.loadClassForName("java.time.chrono.Ser"));
-        allowTypeHierarchy(Chronology.class);
-        types.add(ValueRange.class);
-        types.add(WeekFields.class);
-        types.add(Optional.class);
-        types.add(OptionalDouble.class);
-        types.add(OptionalInt.class);
-        types.add(OptionalLong.class);
-
-        types.remove(null);
-        allowTypes(types.toArray(new Class[types.size()]));
+        addPermission(AnyTypePermission.ANY);
+        denyTypes(new String[]{"java.beans.EventHandler", "javax.imageio.ImageIO$ContainsFilter"});
+        denyTypesByRegExp(new Pattern[]{LAZY_ITERATORS, JAVAX_CRYPTO});
+        allowTypeHierarchy(Exception.class);
+        securityInitialized = false;
     }
 
     /**
      * Setup the security framework of a XStream instance.
      * <p>
-     * This method was a pure helper method for XStream 1.4.10 to 1.4.17.  It initialized an XStream instance with a
-     * whitelist of well-known and simply types of the Java runtime as it is done in XStream 1.4.18 by default.  This
-     * method will do therefore nothing in XStream 1.4.18 or higher.
+     * This method is a pure helper method for XStream 1.4.x. It initializes an XStream instance with a white list of
+     * well-known and simply types of the Java runtime as it is done in XStream 1.5.x by default. This method will do
+     * therefore nothing in XStream 1.5.
      * </p>
      * 
      * @param xstream
      * @since 1.4.10
-     * @deprecated As of 1.4.18
      */
-    @Deprecated
     public static void setupDefaultSecurity(final XStream xstream) {
-        // Do intentionally nothing
+        if (!xstream.securityInitialized) {
+            xstream.addPermission(NoTypePermission.NONE);
+            xstream.addPermission(NullPermission.NULL);
+            xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);
+            xstream.addPermission(ArrayTypePermission.ARRAYS);
+            xstream.addPermission(InterfaceTypePermission.INTERFACES);
+            xstream.allowTypeHierarchy(Calendar.class);
+            xstream.allowTypeHierarchy(Collection.class);
+            xstream.allowTypeHierarchy(Map.class);
+            xstream.allowTypeHierarchy(Map.Entry.class);
+            xstream.allowTypeHierarchy(Member.class);
+            xstream.allowTypeHierarchy(Number.class);
+            xstream.allowTypeHierarchy(Throwable.class);
+            xstream.allowTypeHierarchy(TimeZone.class);
+
+            Class type = JVM.loadClassForName("java.lang.Enum");
+            if (type != null) {
+                xstream.allowTypeHierarchy(type);
+            }
+            type = JVM.loadClassForName("java.nio.file.Path");
+            if (type != null) {
+                xstream.allowTypeHierarchy(type);
+            }
+
+            final Set types = new HashSet();
+            types.add(BitSet.class);
+            types.add(Charset.class);
+            types.add(Class.class);
+            types.add(Currency.class);
+            types.add(Date.class);
+            types.add(DecimalFormatSymbols.class);
+            types.add(File.class);
+            types.add(Locale.class);
+            types.add(Object.class);
+            types.add(Pattern.class);
+            types.add(StackTraceElement.class);
+            types.add(String.class);
+            types.add(StringBuffer.class);
+            types.add(JVM.loadClassForName("java.lang.StringBuilder"));
+            types.add(URL.class);
+            types.add(URI.class);
+            types.add(JVM.loadClassForName("java.util.UUID"));
+            if (JVM.isSQLAvailable()) {
+                types.add(JVM.loadClassForName("java.sql.Timestamp"));
+                types.add(JVM.loadClassForName("java.sql.Time"));
+                types.add(JVM.loadClassForName("java.sql.Date"));
+            }
+            if (JVM.isVersion(8)) {
+                xstream.allowTypeHierarchy(JVM.loadClassForName("java.time.Clock"));
+                types.add(JVM.loadClassForName("java.time.Duration"));
+                types.add(JVM.loadClassForName("java.time.Instant"));
+                types.add(JVM.loadClassForName("java.time.LocalDate"));
+                types.add(JVM.loadClassForName("java.time.LocalDateTime"));
+                types.add(JVM.loadClassForName("java.time.LocalTime"));
+                types.add(JVM.loadClassForName("java.time.MonthDay"));
+                types.add(JVM.loadClassForName("java.time.OffsetDateTime"));
+                types.add(JVM.loadClassForName("java.time.OffsetTime"));
+                types.add(JVM.loadClassForName("java.time.Period"));
+                types.add(JVM.loadClassForName("java.time.Ser"));
+                types.add(JVM.loadClassForName("java.time.Year"));
+                types.add(JVM.loadClassForName("java.time.YearMonth"));
+                types.add(JVM.loadClassForName("java.time.ZonedDateTime"));
+                xstream.allowTypeHierarchy(JVM.loadClassForName("java.time.ZoneId"));
+                types.add(JVM.loadClassForName("java.time.chrono.HijrahDate"));
+                types.add(JVM.loadClassForName("java.time.chrono.JapaneseDate"));
+                types.add(JVM.loadClassForName("java.time.chrono.JapaneseEra"));
+                types.add(JVM.loadClassForName("java.time.chrono.MinguoDate"));
+                types.add(JVM.loadClassForName("java.time.chrono.ThaiBuddhistDate"));
+                types.add(JVM.loadClassForName("java.time.chrono.Ser"));
+                xstream.allowTypeHierarchy(JVM.loadClassForName("java.time.chrono.Chronology"));
+                types.add(JVM.loadClassForName("java.time.temporal.ValueRange"));
+                types.add(JVM.loadClassForName("java.time.temporal.WeekFields"));
+            }
+            types.remove(null);
+
+            final Iterator iter = types.iterator();
+            final Class[] classes = new Class[types.size()];
+            for (int i = 0; i < classes.length; ++i) {
+                classes[i] = (Class)iter.next();
+            }
+            xstream.allowTypes(classes);
+        } else {
+            throw new IllegalArgumentException("Security framework of XStream instance already initialized");
+        }
     }
 
     protected void setupAliases() {

--- a/xstream/src/java/com/thoughtworks/xstream/converters/extended/FileConverter.java
+++ b/xstream/src/java/com/thoughtworks/xstream/converters/extended/FileConverter.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2004 Joe Walnes.
- * Copyright (C) 2006, 2007, 2014, 2018 XStream Committers.
+ * Copyright (C) 2006, 2007, 2018 XStream Committers.
  * All rights reserved.
  *
  * The software in this package is published under the terms of the BSD
@@ -11,33 +11,27 @@
  */
 package com.thoughtworks.xstream.converters.extended;
 
-import java.io.File;
-
 import com.thoughtworks.xstream.converters.basic.AbstractSingleValueConverter;
 
+import java.io.File;
 
 /**
- * Converts a {@link File}.
- * 
- * <p>This converter will take care of storing and retrieving {@link File} with either an absolute path OR a relative path
- * depending on how they were created.</p>
+ * This converter will take care of storing and retrieving File with either
+ * an absolute path OR a relative path depending on how they were created.
  *
  * @author Joe Walnes
  */
 public class FileConverter extends AbstractSingleValueConverter {
 
-    @Override
-    public boolean canConvert(final Class<?> type) {
+    public boolean canConvert(Class type) {
         return type == File.class;
     }
 
-    @Override
-    public Object fromString(final String str) {
+    public Object fromString(String str) {
         return new File(str);
     }
 
-    @Override
-    public String toString(final Object obj) {
+    public String toString(Object obj) {
         return ((File) obj).getPath();
     }
 
