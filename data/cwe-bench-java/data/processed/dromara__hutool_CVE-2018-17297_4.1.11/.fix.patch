--- a/hutool-core/src/main/java/cn/hutool/core/util/ZipUtil.java
+++ b/hutool-core/src/main/java/cn/hutool/core/util/ZipUtil.java
@@ -552,60 +460,49 @@ public class ZipUtil {
 	 * @since 4.5.8
 	 */
 	public static File unzip(ZipFile zipFile, File outFile) throws IORuntimeException {
-		return unzip(zipFile, outFile, -1);
-	}
-
-	/**
-	 * 限制解压后文件大小
-	 *
-	 * @param zipFile zip文件，附带编码信息，使用完毕自动关闭
-	 * @param outFile 解压到的目录
-	 * @param limit   限制解压文件大小(单位B)
-	 * @return 解压的目录
-	 * @throws IORuntimeException IO异常
-	 * @since 5.8.5
-	 */
-	public static File unzip(ZipFile zipFile, File outFile, long limit) throws IORuntimeException {
 		if(outFile.exists() && outFile.isFile()){
-			throw new IllegalArgumentException(
-					StrUtil.format("Target path [{}] exist!", outFile.getAbsolutePath()));
-		}
-
-		// pr#726@Gitee
-		if (limit > 0) {
-			final Enumeration<? extends ZipEntry> zipEntries = zipFile.entries();
-			long zipFileSize = 0L;
-			while (zipEntries.hasMoreElements()) {
-				final ZipEntry zipEntry = zipEntries.nextElement();
-				zipFileSize += zipEntry.getSize();
-				if (zipFileSize > limit) {
-					throw new IllegalArgumentException("The file size exceeds the limit");
+			throw new UtilException("Target path [{}] exist!", outFile.getAbsolutePath());
 		}
+		try {
+			final Enumeration<? extends ZipEntry> em = zipFile.entries();
+			ZipEntry zipEntry;
+			File outItemFile;
+			while (em.hasMoreElements()) {
+				zipEntry = em.nextElement();
+				// FileUtil.file会检查slip漏洞，漏洞说明见http://blog.nsfocus.net/zip-slip-2/
+				outItemFile = FileUtil.file(outFile, zipEntry.getName());
+				if (zipEntry.isDirectory()) {
+					// 创建对应目录
+					//noinspection ResultOfMethodCallIgnored
+					outItemFile.mkdirs();
+				} else {
+					// 写出文件
+					write(zipFile, zipEntry, outItemFile);
 				}
 			}
-
-		try (final ZipReader reader = new ZipReader(zipFile)) {
-			reader.readTo(outFile);
+		} finally {
+			IoUtil.close(zipFile);
 		}
 		return outFile;
 	}
 
 	/**
 	 * 获取压缩包中的指定文件流
-	 *
 	 * @param zipFile 压缩文件
-	 * @param charset 编码
 	 * @param path 需要提取文件的文件名或路径
 	 * @return 压缩文件流，如果未找到返回{@code null}
 	 * @since 5.5.2
 	 */
 	public static InputStream get(File zipFile, Charset charset, String path){
-		return get(toZipFile(zipFile, charset), path);
+		try {
+			return get(new ZipFile(zipFile, charset), path);
+		} catch (IOException e) {
+			throw new IORuntimeException(e);
+		}
 	}
 
 	/**
 	 * 获取压缩包中的指定文件流
-	 *
 	 * @param zipFile 压缩文件
 	 * @param path 需要提取文件的文件名或路径
 	 * @return 压缩文件流，如果未找到返回{@code null}
@@ -614,22 +511,13 @@ public class ZipUtil {
 	public static InputStream get(ZipFile zipFile, String path){
 		final ZipEntry entry = zipFile.getEntry(path);
 		if(null != entry){
-			return getStream(zipFile, entry);
+			try {
+				return zipFile.getInputStream(entry);
+			} catch (IOException e) {
+				throw new IORuntimeException(e);
 			}
-		return null;
-	}
-
-	/**
-	 * 读取并处理Zip文件中的每一个{@link ZipEntry}
-	 *
-	 * @param zipFile  Zip文件
-	 * @param consumer {@link ZipEntry}处理器
-	 * @since 5.5.2
-	 */
-	public static void read(ZipFile zipFile, Consumer<ZipEntry> consumer) {
-		try (final ZipReader reader = new ZipReader(zipFile)) {
-			reader.read(consumer);
 		}
+		return null;
 	}
 
 	/**
@@ -1021,19 +1057,80 @@ public class ZipUtil {
 				throw new UtilException(StrUtil.format("File [{}] not exist!", srcFile.getAbsolutePath()));
 			}
 
-			// issue#1961@Github
-			// 当 zipFile =  new File("temp.zip") 时, zipFile.getParentFile() == null
-			File parentFile;
+			// 压缩文件不能位于被压缩的目录内
+			if(srcFile.isDirectory() && FileUtil.isSub(srcFile, zipFile.getParentFile())){
+				throw new UtilException("Zip file path [{}] must not be the child directory of [{}] !", zipFile.getPath(), srcFile.getPath());
+			}
+		}
+	}
+
+	/**
+	 * 关闭当前Entry，继续下一个Entry
+	 *
+	 * @param out ZipOutputStream
+	 */
+	private static void closeEntry(ZipOutputStream out) {
 		try {
-				parentFile = zipFile.getCanonicalFile().getParentFile();
+			out.closeEntry();
 		} catch (IOException e) {
-				parentFile = zipFile.getParentFile();
+			// ignore
+		}
 	}
 
-			// 压缩文件不能位于被压缩的目录内
-			if (srcFile.isDirectory() && FileUtil.isSub(srcFile, parentFile)) {
-				throw new UtilException("Zip file path [{}] must not be the child directory of [{}] !", zipFile.getPath(), srcFile.getPath());
+	/**
+	 * 从Zip中读取文件流并写出到文件
+	 *
+	 * @param zipFile     Zip文件
+	 * @param zipEntry    zip文件中的子文件
+	 * @param outItemFile 输出到的文件
+	 * @throws IORuntimeException IO异常
+	 */
+	private static void write(ZipFile zipFile, ZipEntry zipEntry, File outItemFile) throws IORuntimeException {
+		InputStream in = null;
+		try {
+			in = zipFile.getInputStream(zipEntry);
+			FileUtil.writeFromStream(in, outItemFile);
+		} catch (IOException e) {
+			throw new IORuntimeException(e);
+		} finally {
+			IoUtil.close(in);
+		}
 	}
+
+	/**
+	 * 将Zlib流解压到out中
+	 *
+	 * @param in     zlib数据流
+	 * @param out    输出
+	 * @param nowrap true表示兼容Gzip压缩
+	 */
+	@SuppressWarnings("SameParameterValue")
+	private static void inflater(InputStream in, OutputStream out, boolean nowrap) {
+		final InflaterOutputStream ios = (out instanceof InflaterOutputStream) ? (InflaterOutputStream) out : new InflaterOutputStream(out, new Inflater(nowrap));
+		IoUtil.copy(in, ios);
+		try {
+			ios.finish();
+		} catch (IOException e) {
+			throw new IORuntimeException(e);
+		}
+	}
+
+	/**
+	 * 将普通数据流压缩成zlib到out中
+	 *
+	 * @param in     zlib数据流
+	 * @param out    输出
+	 * @param level  压缩级别，0~9
+	 * @param nowrap true表示兼容Gzip压缩
+	 */
+	@SuppressWarnings("SameParameterValue")
+	private static void deflater(InputStream in, OutputStream out, int level, boolean nowrap) {
+		final DeflaterOutputStream ios = (out instanceof DeflaterOutputStream) ? (DeflaterOutputStream) out : new DeflaterOutputStream(out, new Deflater(level, nowrap));
+		IoUtil.copy(in, ios);
+		try {
+			ios.finish();
+		} catch (IOException e) {
+			throw new IORuntimeException(e);
 		}
 	}
 	// ---------------------------------------------------------------------------------------------- Private method end
